

redis：

当后续线程来获取数据时，虽然第一个还没有从数据库查完并更新缓存，但发现 key-time 存在，会获取旧的数据。

redis服务端是单线程处理客户端请求，也就是说客户端请求在服务端是串行化执行的，因此对服务端来说，并不存在并发问题。但业务方却存在并发操作redis中的同一个key的情况。


 https://www.cnblogs.com/tingyugetc/p/6347286.html
https://www.jianshu.com/p/edef1cb7fee6

http://rango.swoole.com/archives/508

http://www.laruence.com/2015/05/28/3038.html

http://www.cnblogs.com/lynxcat/p/7954456.html

https://github.com/breeze2/lumen-swoole-http

http://www.chinaz.com/manage/2018/0328/868184.shtml


http://docs.telerik.com/fiddler/

对象构造器
function person(firstname,lastname,age,eyecolor)
{
this.firstname=firstname;
this.lastname=lastname;
this.age=age;
this.eyecolor=eyecolor;
}


http://www.w3school.com.cn/css/css_positioning_floating.asp

http://www.w3school.com.cn/jsref/index.asp

http://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp

http://www.w3school.com.cn/js/pro_js_value.asp

http://www.w3school.com.cn/js/pro_js_referencetypes.asp


http://www.w3school.com.cn/js/pro_js_referencetypes.asp

精通C++是一个艰巨的任务。为什么C++比别的语言难学这么多？其实这基本上是因为C++他爹Bjarne Stroustrup说过的一句话“我特别讨厌语言的设计者把自己的喜好强加给用户”（看向go）。结果C++为了不限制你的想法，于是也就变成了现在这个样子——包含若干范式，大概有
面向对象（灵活应用virtual继承+shared_ptr可以达到java/C#的效果）
模板（这里分两类，分别为type rich programming和meta programming，区别很大）
函数式编程（如今有了lambda，配合<algorithm>文件，简直无敌了）
过程式
但是难能可贵的是，这几种东西在C++混在一起用也是多么的自然。不过，这需要你花时间去掌控他。

那到底有没有必要真的学到这个地步呢，我觉得跟你的领域是有关系的。譬如说我，基本上算是人格分裂的，因为：
当我搞语言设计和编译器的时候，我总是会倾向于创造各种小DSL来给自己用，用的都是模板（想想boost的spirit大概就明白我的意思了，虽然我不用它），尽量让跟我有同样背景的人一眼能看懂我代码的意思。
当我做我那个GUI库（www.gaclib.net）的时候，纯粹是用OO和IoC那一套。
当我写3D渲染程序的时候，我会变成一个为了性能不惜牺牲可读性的人。
当我是不同的我的时候，我当然只会用C++的一部分来完成我当前的这个任务。这好像是多重标准，但是实际上是由于项目本身的性质而定的。

到了这个时候你会觉得，C++真是一门好语言。当你需要为了你的项目放弃不同的部分的时候，C++都能帮你做到。当你需要不同的抽象层次需要不同的性能要求的是，C++还是能够帮你做到。如果你用别的语言，你最终会发现那个语言只能做某几类的项目。这是因为，C++能够自由的让你放弃某些部分，而别的语言会阻止你放弃某些部分。

为了达到这个层次，你必须进入一个无限接近于精通C++的状态里，这个时候你才能收放自如，不被C++社区的各种不同的价值观所捆绑。倘若你的项目非常大，不同的部分有不同的特征的时候（什么，一个没有遍布全世界的一两千人写了20年的程序能叫程序吗？），就更加需要你有这种本事了。

说到这里，大家大概都明白精通C++大概是个什么感觉了吧——大丈夫能屈能伸。


http://www.runoob.com/cplusplus/cpp-tutorial.html

https://www.cnblogs.com/hyamw/p/3210398.html

每次定义一个函数，都会产生一个作用域链（scope chain）。当JavaScript寻找变量varible时（这个过程称为变量解析），总会优先在当前作用域链的第一个对象中查找属性varible ，如果找到，则直接使用这个属性；否则，继续查找下一个对象的是否存在这个属性；这个过程会持续直至找到这个属性或者最终未找到引发错误为止。

(function(){
    var hello="hello,world";
    function welcome(hi){
        alert(hi);        //解析到作用域链的第一个对象的属性
        alert(hello);    //解析到作用域链的第二个对象的属性
    }
    welcome("It's easy");
})();


运行结果很简单，一个弹窗It's easy.一个弹窗hello,world。
分析过程如下：
对于函数welcome()，定义welcome的时候会产生一个作用域链对象，为了表示方便，记作scopechain。scopechain是个有顺序的集合对象。
scopechain的第一个对象：为了方便表示记作sc1， sc1有若干属性，引用本函数的参数和局部变量，如sc1.hi ；
scopechain的第二个对象：为了方便表示记作sc2，sc2有若干属性，引用外层函数的参数和局部变量，如sc2.hello；
...
scopechain的最后一个对象：为了方便表示记作scn，scn引用的全局的执行环境对象，也就是window对象！，如scn.eval()；

这里之所以可以弹出hello,world，原因就是变量解析时在welcome函数作用域链的第一个对象上找不到hello属性，然后就去第二个对象上找去了（结果还真找到了）。

所以，JavaScript中的所谓的高大上的闭包其实很简单，根本上还是变量解析。而之所以可以实现，还是因为变量解析会在作用域链中依次寻找对应属性的导致的。

闭包其实很简单，根本上还是变量解析。而之所以可以实现，还是因为变量解析会在作用域链中依次寻找对应属性的导致的。
JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。


例如下面这个常见的例子：
var foo = function(){
    var name = "exe";
    return function inner(){
        console.log( name );
    }
}
var bar = foo();//这里虽然得到的是函数inner的引用，而不是那一坨代码
bar();//这里开始执行inner函数，回头看看上面加粗的那句话


当然理解这句话的前提是要理解值传递和引用传递

如果这个概念没有理解的话，可能对那句话还是很费解

个人认为这应该是大多数人理解闭包的难点所在

另外推荐一本：《你不知道的JavaScript》，里面详细的解释了为什么会出现闭包这种东东（词法作用域），及与之相对应的东东（动态作用域），我想 把两者对立起来就应该会好理解些吧。


入门用《JavaScript高级程序设计》（第3版），进阶用《JavaScript权威指南》


https://github.com/orhanobut/logger

https://packagist.org/packages/monolog/monolog

https://packagist.org/packages/psr/log
https://packagist.org/packages/php-console/php-console

Drupal
mangeto

https://github.com/Kristories/awesome-guidelines

https://github.com/jupeter/clean-code-php

https://github.com/bendc/frontend-guidelines
https://github.com/Microsoft/api-guidelines
https://github.com/elsewhencode/project-guidelines
https://github.com/thedaviddias/Front-End-Checklist
https://www.slimframework.com/
event.preventDefault();


数字索引数组:

array_merge:合并生成的数组的索引统一从0开始,所以不存在覆盖的情况.

"+"操作符:不改变数字索引,如果索引已经存在,则跳过该元素.

字符索引数组:

array_merge:如果两个数组存在相同的键,后面的一个会覆盖前面的.

"+"操作符:如果两个数组存在相同的键,前面的一个会覆盖后面的.


http://es6.ruanyifeng.com/#docs/let
https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Math

https://www.php-fig.org/psr/

https://xoops.org/modules/core/

https://nette.org/en/

https://fuelphp.com/





https://github.com/tymondesigns/jwt-auth

https://codepen.io/tymondesigns/project/editor/XqdGjN
