作者：Raynor
链接：https://www.zhihu.com/question/22017267/answer/26468016
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

操作系统综上所述，计算机发展到一定程度，什么东西都靠人工也未免太累了。比如通过输入设备组织指令给cpu去计算，你希望能够找一个快速的输入设备(比如键盘)，在能看到结果的地方输入(比如屏幕)，然后再用很方便的方式提交给cpu(比如按键或者指令)，让cpu去算好了，再把结果展示出来(比如屏幕)。理想很美好，但是这么复杂的流程，人工管理起来不还是很麻烦吗？除非我构造一个设备，把这些所有设备都管理起来，于是主板就诞生了。现在主板解决了我们大量的问题，但是我发觉我的需求还远远不够！我希望我写过的程序能在任何一台机上运行。我希望我能边听音乐边干活——即同一时间可以运行多个程序。我希望别人写的傻×东西不要影响到我的工作——即多任务控制。我希望计算机里面的各种资源都能得到良好的组织，更快的访问。我希望我的用户界面更好看，使用更方便，功能更强大！我是个小白用户，啥都不懂，别跟我扯这些有的没的，我就像随便操作两下就能达到我想要的！如果这些需求全部都做在主板bios里面，那将是一场灾难！除非bios经过极大的调整和改动，划分出一大块区域存放操作系统，并且完成复杂的体系结构改革。计算机发展到这种程度，早就已经有很多的机构和厂商介入其中，试图从中渔利。他们当然不会求着计算机标准委员会和主板生产厂商去做所谓的主板改革，而是编写自己的程序——操作系统，来解决这些所有的问题。而操作系统问世之后，一方面接管了主板对于系统资源的管理，加入了自己的中间层——驱动程序，另一方面又充分发挥了人机交互的接口——gui界面，成为了计算机必不可少的组成部分。操作系统通过bios引导，即作为应用程序开始运行。我们知道程序的本质上就是在cpu上运行种种指令，比如操作系统需要把硬盘上的模块放入内存，实际上就是运行了一系列复杂的cpu指令，cpu指令通过主板bus（实际上就是传递指令的电路）发送指令给硬盘（比如从哪个扇区偏移多少读多少数据），硬盘再通过芯片组转动磁头，把数据读到缓存中，完成后给cpu发送一个信号（即中断），cpu收到这个信号，就在寄存器中寻址该信号对应的地址（即我们说的中断向量表），运行该地址中的指令，发现该指令是发送拷贝指令给主板芯片组，主板就会在cpu的指导下不断的发送信号，告诉硬盘缓存放电，再把接收的电信号存到指定的内存位置去，如此反复，直到完成cpu的一系列指令为止。操作系统说白了，就是这样通过种种cpu指令，实现自身的所有功能。当然这些指令也不是一条条写进去的，而是通过编程语言完成人类较容易识别的逻辑，然后再通过编译器把这些逻辑翻译成cpu指令，这就涉及编译原理的东西了。既然操作系统对硬件的访问都是通过cpu指令来完成的，那为什么大家都感觉是操作掌管了硬件呢？这就涉及操作系统最本质的功能之一：对系统资源的管控了。我们运行的所有程序，实际上都是操作系统帮我们运行的。操作系统背后进行了很多的工作，如虚拟地址空间的分配，cpu分时调度，硬件中断信号的响应等。这样对于硬件资源的访问，也是通过操作系统安排的。比如操作系统会通过把短时间内硬盘读写合并成顺序的方式，以提高磁头的利用率，降低磁头转向的时间。再比如对内存地址的访问也是由操作系统管控的，某个程序中的内存地址具体落到内存条的哪个位置，还是硬盘中的虚拟内存，就看操作系统的心情了。至此，操作系统和硬件的交互也介绍的差不多了，更详细的东西建议参考操作系统相关的书籍吧，比如《深入理解计算机系统》，《linux内核设计与实现》，《unix环境高级编程》之类的。
