# 算法 Algorithms

逻辑和数学能力，用更少的代码和资源实现更复杂的逻辑

* 场景：用算法来挖掘出数据的价值。没有数据就没有核心价值。当有了数据作为基础，要继续需要思考如何让数据变的有价值
  - 图像识别领域，深度学习算法异军突起，不仅可以进行准确的人脸识别、指纹识别，还可以进行复杂的图像对比。2016年参加的光谷人工智能大会上，听西安电子科技大学公茂果教授分享的“深度神经网络稀疏特征学习与空时影像变化检测”主题，利用图像识别技术，对比汶川地震前后的卫星照片和光感照片，准确地找到了受到地震影响最严重的区域，即震前和震后地貌发生变化最大的区域，快速地为救援队定位到最需要帮助的地点，解救伤者，投放救援物资。
  - 自动驾驶领域，可以通过识别路面的状况来实现自动驾驶、自动停车。Uber无人驾驶汽车已经在匹兹堡上路测试，自动驾驶汽车配备了各式传感器，包括雷达、激光扫描仪以及高分辨率摄像头，以便绘制周边环境的细节。自动驾驶汽车有望改善人类的生活质量，也可挽救数百万人的性命，为人们提供更多的出行方便。5年前，我在听Andrew Ng的斯坦福大学机器学习公开课的时候，就被当时的自动驾驶视频介绍所震撼，科幻电影中的世界就快变成现实了。
  - 用户行为分析，人类有各种各样的行为和需求。衣食住行，吃喝玩乐，都是人的最基本的行为。大多数人的行为是共性的，商家可以收集这些行为数据，通过数据挖掘算法来找到人们行为共性的规律。根据用户的购物行为，商家可以为用户推荐喜欢的商品，这样就有了推荐系统； 根据用户对信息的查询行为，可以发现用户对信息的需求，这样就有了搜索引擎；根据用户位置的变化，可以发现用户的出行需求，这样就有了地图应用；针对用户个性化的行为，可以给用户打上标签，用来标注用户的特征或身份，这样就有了用户画像。用户行为分析，让商家了解用户习惯，同时也让用户了解自己，有巨大的商业价值。
  - 金融征信领域，传统信贷业务都是银行核心业务，但由于中国人数众多且小客户居多，银行无法负担为小客户服务的高成本，导致民间信贷的兴起。2014年底互联网金融P2P的开始爆发，贷款需求被满足的同时，却暴露出了违约风险。征信体系缺失，导致很多P2P公司坏账率很高，到2016年底P2P跑路的多达数千家。征信需求，变得非常迫切。比如，某个人想买车但现金不够，这时就需要进行贷款。商家给用户进行贷款时，通过信用风险的评级就能判断出这个用户的还款能力，从而来决定给他贷多少钱，以什么周期还款，减少违约风险。支付宝的芝麻信用分，是目前被市场一致认可的信用评分模型。
  - 量化投资领域，我认为这个领域最复杂的，最有挑战性的，同时也是最有意思的。可以通过量化算法模型实现赚钱，是最容易变现的一种方法。在金融投资领域中，有各式各样的数据，反应的各种金融市场的规则，有宏观数据，经济数据，股票数据，债券数据，期货数据，还有新闻数据，情绪数据等等，金融宽客(Quant)通过分析各种各样的数据，判断出国家的经济形势和个股的走势，进行投资组合算法，实现投资的盈利。
    + 用个人账号在中国二级投资交易市场，完成交易过程。这种方式没有很多的中间环节，你获得交易所的数据，自己编写算法模型，然后用自己的钱去交易，完全自己把握。只要算法有稳定的收益率，你就可以赚到钱。
    + 作为IT人，懂编程，懂算法，只要再了解金融市场的规则，就能去金融市场抢钱了。中国的金融二级投资交易市场，是一个不成熟的市场，同时又是情绪化的市场。市场中，每天都存在着大量的交易机会，每天都会有“乌龙指”。量化投资的技术，可以帮助我们发现这些由于信息不对称出现的机会，赚取超额的收益。
    + 一个私募基金，募集了1亿资金准备杀入金融市场。基金经理决定按照投资组合的建模思路，对各类金融资产进行组合配置。下图就反应了各类资产，以均值-方差的标准来创建投资组合，符合资本资产定价模型(CAPM)的原理。关于资本资产定价模型详细介绍，请参考文章[R语言解读资本资产定价模]型CAPM(<http://blog.fens.me/finance-capm/>)
    + 需要利用算法进行组合优化，从而找到市场上最优的投资组合。算法本身，才是最能体现价值的部分。在金融市场里，每支基金都配置了不同的资产做组合.从市场上几千支的股票和债券中进行选择，并配置不同的权重，之前都是基金经理干的活，那么我们用算法一样也可以干，说不定用算法模型构建的组合业绩会更好。如果我们用算法模型，取代了年薪几百万的基金经理，那么你就能够获得这个收益。最终实现个人价值，从而用算法改变命运。所以，通过金融变现才是最靠谱的。
* 数据结构是工具，算法是通过合适的工具解决特定问题的方法
* 人理解迭代，神理解递归
* 特征
  - 有穷性：算法必须能在执行有限个步骤之后终止
  - 确切性：每一步骤必须有确切的定义（容错性得好，考虑兼容性）
  - 输入项：有0个或多个输入（有限），用来规定初始情况，所谓0个输入是指算法本身定义了初始条件
  - 输出项：有一个或多个输出，是对输入数据处理后的结果。没有输出的算法毫无意义
  - 可行性：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，每个计算步骤都可以在有限时间内完成

## 方法

* 算法衡量
  - 时间复杂度
  - 空间复杂度
* 算法分析
  - 设计数据结构
* 算法实践
* 思路
  - 养成算法思维是一个长期过程，要时刻问自己几个问题：
    + 结果是什么？
    + 步骤是什么？
    + 判断结果的标准是什么？
  - 化繁为简
    + 很难在第一时间内得到正确思路，这时候可以尝试一种由简至繁的思路。首先把问题规模缩小到非常容易解答的地步。用来解决动态规划问题
  - 分而治之：把问题分为两半，变成两个与原来问题同构的问题
  - 化虚为实
* 刷题指南
  - 先刷二叉树.试着从框架上看问题，而不要纠结于细节问题。
  - 二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题
  - 刚开始刷二叉树的题目，前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；刷完整个专题，再去做什么回溯动规分治专题，就会发现只要涉及递归的问题，都是树的问题
  - 很多动态规划问题就是在遍历一棵树，如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路
* 看书的同时结合刷在线编程算法题的方式
  - 边看数据结构或算法导论，同时在牛客或者leetcode上刷题，因为看书太枯燥很容易失去耐心，在线刷题的好处是你可以每天定目标，享受每个题目通过的快感，有正向反馈更容易坚持下来

```c
// 二叉树题目框架
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```

## 复杂度

* 时间复杂度: 代码执行时间随数据规模增长的变化趋势 T(n) = O(f(n))
  - 只关注循环执行次数最多的一段代码；
  - 加法法则：总复杂度等于量级最大的那段代码的复杂度；
  - 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
  - 量级
    + O(1)
    + O(logn) O(log2 N) 的简写
    + O(n)
    + O(nlogn)
    + O(2^n)
    + O(n!)
    + O(n^2)
  - 最好情况时间复杂度:在最理想的情况下，执行这段代码的时间复杂度
  - 最坏情况时间复杂度:在最糟糕的情况下，执行这段代码的时间复杂度
  - 平均情况时间复杂度:结合概率论分析从最好到最坏每种情况平均下来的加权平均时间复杂度
* 空间复杂度:在程序运行过程中的使用空间的峰值

## 递归

* 定义：直接调用自己或通过一系列调用语句间接调用自己的函数
* 本质：把问题拆分成具有相同解决思路的子问题，直到最后被拆解的子问题再也不能拆分，解决了最小粒度可求解的子问题后，在「归」的过程中自然顺其自然地解决了最开始的问题
* 适用于那些无法预估计算深度的问题
* 条件
  - 问题解可以分解为几个子问题的解
  - 问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
  - 存在递归终止条件
* 特点
  - 一个问题可以分解成具有相同解决思路的子问题，子子问题，换句话说这些问题都能调用同一个函数
  - 分为调用和回退阶段，回退顺序是调用顺序逆序
  - 经过层层分解的子问题最后一定是有一个不能再分解的固定值的（即终止条件）,如果没有的话,就无穷无尽地分解子问题了，问题显然是无解的
  - 程序结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间
  - 在迫不得已的情况下才使用递归，因为递归本身的效率并不理想，但思想却值得留存在记忆之中
  - 大量的递归调用会建立函数的副本，会消耗大量的时间和内存，而迭代则不需要此种代价
* 分析：采用**自上而下**思维(最终问题往前推)，而解决问题有时候采用自下而上的方式能让算法性能得到极大提升,思路比结论重要
  - 「递」:将问题拆解成子问题来解决，子问题再拆解成子子问题，直到被拆解的子问题无需再拆分成更细的子问题（即可以求解）正向展开
  - 「归」:最小的子问题解决了，那么它上一层子问题也就解决了，上一层的子问题解决了，上上层子问题自然也就解决了,直到最开始的问题解决 逆向合并
* 流程
  - 找出基准情形（没有调用自身）。看该函数在基准情形下会做什么
  - 看该函数在到达基准情形的前一步会做什么
  - 就这样往前推，看每一步都在做什么
* 套路
  - 定义函数：明确函数功能，由于递归特点是问题和子问题都会调用函数自身，所以这个函数功能一旦确定了，之后只要找寻问题与子问题递归关系即可
  - 确定条件
    + 寻找问题与子问题间关系（即递推公式），由于问题与子问题具有相同解决思路，*子问题可以调用步骤 1 定义的函数*，符合递归的条件（函数里调用自身）所谓的关系最好能用一个公式表示出来，比如 f(n) = n * f(n-)这样，如果暂时无法得出明确的公式，也可以用伪代码表示
    + 终止条件:寻找最终不可再分解的子问题的解（临界条件），确保子问题不会无限分解下去
  - 将递推公式用代码表示出来补充到定义的函数中
  - 优化：根据问题与子问题关系，推导出时间复杂度,如果发现递归时间复杂度不可接受，则需转换思路对其进行改造，看下是否有更靠谱的解法
* 注意
  - 警惕堆栈溢出，为此要设定好终止条件和合理的递归层数
  - 防止重复计算，因此要经过认证求证，不能凭感觉
  - 递归代码更简洁,可读性不好
  - 切忌试图通过人脑去分解每个步骤，那样会把自己搞晕的
* 迭代和递归区别：迭代使用的是循环结构，递归使用的是选择结构。

```java
public int factorial(int n) {
    if (n < =1) {
        return 1;
    }

    return n * factorial(n - 1)
}
```

## divide and conquer，D&C

* 方法
  - 找出基线条件，这种条件必须尽可能简单。
    + 通常是数组为空或只包含一个元素
  - 不断将问题分解(或者说缩小规模)，直到符合基线条件。
* 适用于这小块地的最大方块，也是适用于整块地的最大方块

## 分治

* 把一个大问题分解成相似的小问题，通过解决这些小问题，再用小问题的解构造大问题的解
  - 各个小模块通常具有与大问题相同的结构
  - 把大的问题分解成小问题的过程就叫“分”
  - 解决小问题的过程就叫“治”
  - 合：用小问题的解构造大问题的解
* 分治法基本都是可以用递归来实现
  - 递归是一种编程技巧，一个函数自己调用自己就是递归
  - 分治法是一种解决问题的思想
* 时间复杂度: O(nlogn)
* 空间复杂度

### 二分查找 Binary Search

折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。时间复杂度可以表示O(h)=O(log2n)

* 时间复杂度是 O(logn)
* 针对的是一个有序的数据集合,每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0
* 适用于变动不是很频繁的静态序列集，如果序列集变动很频繁，经常进行插入删除操作，那么就要不断维护这个序列集的排序，这个成本也很高
* 变形版本
  - 从给定序列中查找第一个或最后一个匹配元素
* 假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功
* 否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，
* 则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功
* 给定一个升序排列的自然数数组，数组中包含重复数字，例如：[1,2,2,3,4,4,4,5,6,7,7]。问题：给定任意自然数，对数组进行二分查找，返回数组正确的位置，给出函数实现。注：连续相同的数字，返回第一个匹配位置还是最后一个匹配位置，由函数传入参数决定。
* 一般是对一个索引页面进行二分查找。索引页面中有可能根本不存在用户的记录(索引页面中的记录全部被删除，又没有与兄弟页面合并时)，此时，low/high均为0，此时如果根据low/high计算出来的mid进行记录的读取，就存在逻辑错误。
* 中值算法
  - mid = (low + high) / 2 ： 存在着溢出的风险
  - mid = low + (high – low)/2 ：一个索引页面(大小一般是8k或者是16k)，能够存储的索引记录是有限的，因此肯定不会出现(low + high)溢出的风险。这也是为什么InnoDB中的中值，采用的就是算法一的实现。
* 递归降低了效率
* 如何查找第一个/最后一个等值：用flag来纠正每次比较的最终结果。例如：比较相等(相等用0表示，大于为1，小于为-1)，但是flag = 1，则返回纠正后的比较结果为1，需要移动二分查找的high到mid，继续二分(反之，若flag = 0，则返回纠正后的结果为-1，需要移动二分查找的low到mid，继续二分)。如此一来，等值仍旧可以进行二分查找，最终的对比只需要9次，远远小于200次。
  - InnoDB针对不同的SQL语句，总结出四种不同的Search Mode
  - 然后根据这四种不同的Search Mode，在二分查找碰到相同键值时进行调整。例如：若Search Mode为PAGE_CUR_G或者是PAGE_CUR_LE，则移动low至mid，继续进行二分查找；若Search Mode为PAGE_CUR_GE或者是PAGE_CUR_L，则移动high至mid，继续进行二分查找。
* 参考
  - [套框架刷通二叉树](https://mp.weixin.qq.com/s/izZ5uiWzTagagJec6Y7RvQ)
  - [线段树](https://mp.weixin.qq.com/s/rjXqcYDaeA8_Ppj48Dg-Nw)

```sql
# b字段有一个B+树索引
select * from t1 where b > 4;  # 就需要跳过所有的4，从最后一个4之后开始返回所有记录
select * from t1 where b >= 4; # 就需要定位到第一个4，然后顺序读取所有记录

select * from t1 where b < 2; # 数据库索引同时支持反向扫描,定位到索引中的第一个2
select * from t1 where b <= 2; # 定位到索引的最后一个2，然后开始反向返回满足查询条件的索引记录。
```

```c
#define    PAGE_CUR_G          1        >查询
#define    PAGE_CUR_GE         2        >=，=查询
#define    PAGE_CUR_L          3        <查询
#define    PAGE_CUR_LE         4        <=查询
```

## LFU Least Frequently Used，即最不经常使用

## LRU Least Recently Used

* 对于在内存中但又不用的 [数据块]（内存块）叫做 LRU，操作系统会根据哪些数据属于 LRU 而将其移出内存而腾出空间来加载另外的数据，常用于页面置换算法，是为虚拟页式存储管理服务的。
* 实现
  - 用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为 0 并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为 0。当数组空间已满时，将时间戳最大的数据项淘汰。
  - 利用一个链表来实现，每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。
  - 利用链表和 hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回 - 1。这样一来在链表尾部的节点就是最近最久未访问的数据项。
* 比较
    + 对于第一种方法，需要不停地维护数据项的访问时间戳，另外，在插入数据、删除数据以及访问数据时，时间复杂度都是 O (n)
    + 对于第二种方法，链表在定位数据的时候时间复杂度为 O (n)
    + 所以在一般使用第三种方式来是实现 LRU 算法

## 字符串操作

* 字符串匹配
  - 主串和模式串。简单来说，要在字符串 A 中查找子串 B，那么 A 就是主串，B 就是模式串
* BF(Brute Force) 算法
* KMP 算法
  - 后缀子串：以某个字符串最后一个字符为尾字符的子串（不包含字符串自身），比如上面的 ababa，后缀子串为 baba、aba、ba、a；
  - 前缀子串：以某个字符串第一个字符为首字符的子串（不包含字符串自身），还是以 ababa 为例，前缀子串为 a、aba、abab；
  - 最长可匹配后缀子串：后缀子串与前缀子串最长可匹配子串，也可叫做共有子串，以 ababa 为例，自然是 aba 了，长度为 3；
  - 最长可匹配前缀子串：与上面定义相对，即前缀子串与后缀子串最长可匹配子串。最长可匹配前缀子串和最长可匹配后缀子串肯定是一样的。
  - 假设坏字符所在位置是 j，最长可匹配后缀子串长度为 k，则模式串需要后移的位数为 j-k。每当我们遇到坏字符，就将模式串后移 j-k 位，直到模式串与对应主串字符完全匹配；如果移到最后还是不匹配，则返回 -1
  - 直接把模式串移到下一个可能和 A 匹配的主串位置
* Trie 树
  - 也叫「前缀树」或「字典树」，顾名思义，它是一个树形结构，专门用于处理字符串匹配，用来解决在一组字符串集合中快速查找某个字符串的问题
  - 本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起
  - 每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串,（红色节点表示是某个单词的结束字符，但不一定都是叶子节点）
  - 应用
    + 敏感词过滤系统
    + 搜索框联想功能

### Depth First Search DFS 深度优先搜索

* 从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底...，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走
* 递归实现:使用栈(逆序压栈),如果层级过深，很容易导致栈溢出
* 非递归实现
  - 对于每个节点来说，先遍历当前节点，然后把右节点压栈，再压左节点(逆序压栈)
  - 弹栈，拿到栈顶节点，如果节点不为空，重复步骤 1，如果为空，结束遍历
* leetcode 104，111: 给定一个二叉树，找出其最大/最小深度

### Breadth First Search BFS 广度优先搜索

* 步骤
  - 让顶点出队，将其设为当前顶点
  - 访问每个顶点的邻接点
* 处理顶点本身，还得处理边：有 O(V)次出队，还有 O(E)次访问  O(V + E) V 个顶点，E 条边
* 最短路径问题 shorterst-path problem:是否有从A到B的路径,如果有，广度优先搜索将找出最短路径
  - 用图来建立模型，再使用广度优先搜索来解决问题
  - 从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点
  - 使用队列弹出当前元素检查
  - 压入当前元素的子元素
  - 按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列
  - 对于检查过的，务必不要再去检查，否则可能导致无限循环
* 参考
  - [使用场景：层序遍历、最短路径问题](https://mp.weixin.qq.com/s?__biz=MzA5ODk3ODA4OQ==&mid=2648167212&idx=1&sn=6af5ffe5b69075b21bb4743ddcee4e7c&chksm=88aa236abfddaa7cae70b42edb299d0a52d9f1cc4fc1fdba1116972fc0ca0275b8bfdf10851b)
* LeetCode 102.Binary Tree Level Order Traversal:给一个二叉树，返回其按层序遍历得到的节点值。（即逐层地，从左到右访问所有节点）
* LeetCode 1162. As Far from Land as Possible 离开陆地的最远距离（Medium）最短路径：结点之间最近路径
* Floyd

## 回溯 backtrack

* 在一棵决策树上做遍历的过程
- 决策树形状主要取决于每个结点处可能的分支，就是在每次做决策时，“可以选什么”、 “有什么可选的”
* 核心就是 for 循环里面的递归，在递归调用**之前做选择**，在递归调用**之后撤销选择**
* backtrack函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列
* 路径：已经做出的选择
* 选择列表：当前可以做的选择
  - 分析问题的候选集合
  - 候选集合的变化规律
  - 已选集合与候选集合关系
  - 一般情况下，候选集合使用数组表示即可。 候选集合上需要做的操作并不是很多，使用数组简单又高效
* 结束条件：到达决策树底层，无法再做选择的条件
* 参考
  - [回溯算法](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4)
  - [回溯法的候选集合](https://mp.weixin.qq.com/s?__biz=MzA5ODk3ODA4OQ==&mid=2648167091&idx=1&sn=82ed3bfa68f92b2826247a0bba40d8ff&chksm=88aa22f5bfddabe322bf5dafeef4f7cd56897d2d7e5b91d55e2baa2b21056694cae7da10c2b5&token=1295540189)
* 启发式搜索算法：A*寻路算法
* 题目
  - 地图着色算法
  - N 皇后问题
  - 最优加工顺序
  - 旅行商问题

```
void traverse(TreeNode root) {
    for (TreeNode child : root.childern)
        // 前序遍历需要的操作
        traverse(child);
        // 后序遍历需要的操作
}

result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        # 做选择
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
        # 撤销选择
        路径.remove(选择)
        将该选择再加入选择列表

    void backtrack(int[] nums, int i, int rest) {
        if (i == nums.length) {
            return;
        }
        backtrack(nums, i + 1, rest - nums[i]);
        backtrack(nums, i + 1, rest + nums[i]);
    }
```

## 图论

* 图的表示：邻接矩阵和邻接表

### 遍历

* 层序遍历
  - 要求的输入结果和 BFS 是不同的
    + 层序遍历要求区分每一层，也就是返回一个二维数组
    + BFS 的遍历结果是一个一维数组，无法区分每一层

## Dijkstra 狄克斯特拉算法

* 带权最短路径问题:每条边都有关联数字的图
* 狄克斯特拉算法找出总权重最小路径，只适用于有向无环图(directed acyclic graph，DAG).
* 如果有负权边，就不能使用狄克斯特拉算法
  - 对于处理过的节点，没有前往该节点的更短路径。 这种假设仅在没有负权边时才成立
* 规则
  - 以起步的顶点为当前顶点
  - 检查当前顶点的所有邻接点，计算起点到所有已知顶点的权重，并记录下来
  - 从未访问过(未曾作为当前顶点)的邻接点中，选取一个起点能到达的总权重最小的顶点，作为下一个当前顶点
  - 重复，直至图中所有顶点都被访问过
* [10行实现最短路算法——Dijkstra](https://mp.weixin.qq.com/s/fZwTBch-pkPrQ5W3AQti1A)
* 最小生成树算法：Prim，Kruskal
* 实际常用算法：关键路径
* 二分图匹配：配对、匈牙利算法
* 拓展：中心性算法、社区发现算法

## 贝尔曼.福德算法 Bellman-Ford algorithm

* 处理包含负权边的图

## [拓扑排序](https://mp.weixin.qq.com/s/MhbBwkMqsfAe3ep8cdMO4w)

* 列表是有序的。如果任务A依赖于任务B，在列表中任务A就必须在任务B后面

## 动态规划 Dynamic Programming

* 解决多阶段决策过程最优化的一种数学方法。把多阶段问题变换为一系列相互联系的的单阶段问题，然后逐个加以解决
  - 在每一个阶段都需要作出决策，从而使整个过程达到最优。各个阶段决策的选取仅依赖当前状态（这里的当前状态指的是当前阶段的输入状态），从而确定输出状态。
  - 当各个阶段决策确定后，就组成了一个决策序列，这个决策序列就决定了问题的最终解决方案。
  - 多阶段决策过程:这种把一个问题可看作是一个前后关联具有链状结构的多阶段过程
* 解决某类问题的一种思路，或者是一种更高意义上的算法，是一种道，而不是术。所以动态规划难就难在即使学会了这种思想，遇到具体问题也需要具体分析，很可能因为构造不出动态规划所需要的形式而无法解决，甚至根本想不到这是一个动态规划问题
* 状态转移方程:每一个阶段可能包括很多状态，前后阶段的状态通过决策联系在一起。如果要利用前阶段子问题的结果解决现阶段的子问题，必须要能够建立前后阶段状态的转移关系，最好可以通过方程表示
* 最优解:让指标函数达到最优值.如果可以将问题拆分成子问题，那么这个指标函数也必须具有分离性，也就是必须能够利用子问题的最优递推的求出整体最优
* 重叠子结构:同类型的子问题,利用前面子结构计算出的结果，用递推不断地调用同一个问题
* 最优子结构：利用前面已经解决的子问题最优解来构造并解决后面的子问题。能够构造的前提就是要满足指标函数的分离性，也就是全局最优解一定能够拆成子问题的最优解，从而递推解决。
* 记住求过的解来节省时间
* 自底向上方法:先解决子问题，再逐步解决大问题
* 方法
  - 在给定约束条件下找到最优解，每种动态规划解决方案都涉及网格
  - 单元格中的值通常就是要优化的值
  - 在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决
  - 每个单元格都是一个子问题，因此应考虑如何将问题分成子问题，这有助于找出网格的坐标轴
* 问题
  - 陷入了穷举的思想
* 步骤
  - 定义子问题:子问题是和原问题相似，规模较小
    + 原问题要能由子问题表示,有的题目需要定义二维、三维的子问题
    + 子问题的解要能通过其他子问题的解求出
  - **写出子问题的递推关系**
    + 选择状态变量，使其满足无后效性
    + 分情况讨论，有复杂的 max、min、sum 表达式
  - 确定 DP 数组计算顺序
    + 自顶向下：备忘录递归方法
    + 自底向上： DP 数组循环方法
  - 空间优化
* 树形DP：背包问题
* 线性DP：最长公共子序列、最长公共子串
* 区间DP：矩阵最大值（和以及积）
* 数位DP：数字游戏
* 状态压缩DP：旅行商
* 一个楼梯有 10 级台阶，从下往上走，每跨一步只能向上迈 1 级或者 2 级台阶，请问一共有多少种走法？
  - F(10) = F(9) + F(8) =》F(x) = F(x-1) + F(x-2)
    + 最优子结构 F(x-1) 和 F(x-2)
    + 状态转移方程 F(x) = F(x-1) + F(x-2)
    + 问题的边界 F(1) = 1, F(2) = 2

### NP完全问题

* 需要计算所有的解，并从中选出最小/最短的那个
* 识别
  - 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
  - 涉及“所有组合”的问题通常是NP完全问题。
  - 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。
  - 如果问题涉及序列(如旅行商问题中的城市序列)且难以解决，它可能就是NP完全问题。
  - 如果问题涉及集合(如广播台集合)且难以解决，它可能就是NP完全问题。
  - 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。
* 最佳做法是使用近似算法
  - 贪婪算法易于实现、运行速度快，是不错的近似算法

## 贪心算法

* 寻找局部最优解，企图以这种方式获得全局最优解

## 流算法

* 最大流：最短增广路、Dinic 算法
* 最大流最小割：最大收益问题、方格取数问题
* 最小费用最大流：最小费用路、消遣
* 在一个像素矩阵中有一条封闭曲线，给出一个点的坐标，怎么判断该点在曲线内
* 在一棵二叉树中找三个数的最小公共祖先，尽量只用一次遍历实现。

## KMP 算法

* 匹配表: ABCABD 000120
  - 前缀:除了最后个字符以外所有的顺序组合方式 A、AB、ABC、ABCA、ABCAB
  - 后缀:除了第一个字符外，其他所有的组合方式 BCABD、CABD、ABD、ABD、BD、D
  - 匹配值：对子串的每个字符组合寻找出前缀和后缀，然后进行比较是否有相同的，相同的字符组合有几位
* 下一次要移动的次数 = 成功匹配的位数 - 匹配值
* 在同一字符串中出现两种相同的字符，比如上面中的 AB，由两个字符组成的，所以匹配值为 2，同时在匹配的过程中，如果 D 前边的字符能够匹配，则子串往后移动 3 位，则再次匹配 AB

## K 最近邻算法 k-nearest neighbours，KNN

* 特征抽取：将物品转换为一系列可比较的数字，能否挑选合适的特征事关KNN算法的成败
* 训练(training)
* 朴素贝叶斯分类器(Naive Bayes classifier)
* 分类：进行编组
* 回归 regression：预测结果

## bitmap

## 布隆过滤器 Bloom Filter

* 1970年由布隆提出的。实际上是一个很长的二进制向量和一系列随机映射函数，可以用于检索一个元素是否在一个集合中
* 优点是空间效率和查询时间都远远超过一般的算法
* 缺点是有一定的误识别率和删除困难
* 某个值存在时，这个值 可能不存在；当它说不存在时，那么 一定不存在
* 使用 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。
* 场景
  - 大数据判断是否存在：这就可以实现出上述的去重功能，如果你的服务器内存足够大的话，那么使用 HashMap 可能是一个不错的解决方案，理论上时间复杂度可以达到 O(1 的级别，但是当数据量起来之后，还是只能考虑布隆过滤器。
  - 解决缓存穿透：经常会把一些热点数据放在 Redis 中当作缓存，例如产品详情。通常一个请求过来之后我们会先查询缓存，而不用直接读取数据库，这是提升性能最简单也是最普遍的做法，但是如果一直请求一个不存在的缓存，那么此时一定不存在缓存，那就会有大量请求直接打到数据库上，造成缓存穿透，布隆过滤器也可以用来解决此类问题。
  - 爬虫/邮箱等系统过滤：有一些正常的邮件也会被放进垃圾邮件目录中，这就是使用布隆过滤器误判导致的
* 原理
  - 长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0
  - 向布隆过滤器中添加数据时，会使用多个 hash 函数对 key 进行运算，算得一个证书索引值，然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作
  - 向布隆过滤器查查询 key 是否存在时，跟 add 操作一样，会把这个 key 通过相同的多个 hash 函数进行运算，查看 对应的位置 是否 都 为 1，只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在。如果这几个位置都是 1，并不能说明这个 key 一定存在，只能说极有可能存在，因为这些位置的 1 可能是因为其他的 key 存在导致的。
  - 记住
    + 使用时不要让实际元素数量远大于初始化数量
    + 当实际元素数量超过初始化数量时，应该对布隆过滤器进行 重建，重新分配一个 size 更大的过滤器，再将所有的历史元素批量 add 进行

* 答案却是很可能是正确
  - 已搜集:实际上并没有搜集
  - 未搜集:肯定未搜集
* 优点在于占用的存储空间很少
* 适用于不要求答案绝对准确的情况

## [HyperLogLog](http://content.research.neustar.biz/blog/hll.html)

* 类似于布隆过滤器的算法
* 近似地计算集合中不同的元素数，不能给出准确的答案， 但也八九不离十，而占用的内存空间却少得多
* [神奇的HyperLoglog解决统计问题](https://mp.weixin.qq.com/s?__biz=MzU4Mjk0MjkxNA==&mid=2247484713&idx=1&sn=adb21a258683aff10098ca13007b03d7)

## 回文数

* 指正序（从左向右）和倒序（从右向左）读都是一样的整数
* 方法
  - 反转后是否相等
  - 将整数转为字符串 ，然后将字符串分割为数组，只需要循环数组的一半长度进行判断对应元素是否相等即可
  - 取整和取余操作获取整数中对应的数字进行比较
  - 取出后半段数字进行翻转
    + 长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）
* 参考
  - [让字符串成为回文串的最少插入次数](https://mp.weixin.qq.com/s/C14WNUpPeBMVSMqh28JdfA)

## 位运算

* 对目标转换思路
* `<< `左移：向左进行移位操作，高位丢弃，低位补 0
* `>>` 右移：向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位
* 判断
* 置位
* 第 n 位置 0 `y = x & ~(1<<n)`
* 第 n 位取反 `y = x ^ (1<<n)`
* 最右边的 1 置 0  `y = x & (x-1)`

## 技巧

* n&(n-1)：消除数字 n 的二进制表示中的最后一个 1
  - 循环计算 1 的个数
  - 判断一个数是不是 2 的指数：二进制表示一定只含有一个 1

## 面试

* 链表
	-   常见面试题有写一个链表中删除一个节点的算法、单链表倒转、两个链表找相交的部分，这个一般必须得完全无误的情况下写出来；
	-   给出两个链表的头结点，找出这两个链表的交点。
	-   java 中数组和链表的区别，各自优势 如何设计拥有高效的随机读取能力的的链表（跳表） 设计跳表，跳表插入开销，跳表随机读取过程
	-   给你一个单向链表，给这个链表做K反转，例如 k=3 1 -> 2 -> 3 -> 4 -> 5 -> 6 反转后为： 3 -> 2 -> 1 -> 6 -> 5 -> 4 链表长度保证为K的倍数
	-   给定一个链表，返回链表开始入环的第一个节点
	-   n个降序的链表返回前K个大的节点构成的链表
	-   链表合并：给出n个有序的链表，将他们合并为一个有序链表。
	-   有k个有序单链表，怎么合并成一个有序单链表？
	-   链表逆序，不能用修改指针的方法，用递归如何实现。
	-   反转单链表
	-   知道双向链表怎么翻转吗
	-   有两个数字非常大已经超出了long型的范围，现在以链表的方式存储其中链表头表示最高位，例如1->2->3->4表示1234，请设计一个算法求出两数之和；
	-   反转数字，不能把数字变成字符串
	-   链表找环的入口
	-   单链表的逆序
	-   两个链表合并，最长公共子串问题
	-   单链表逆序，快排，数组中找两个数和等于目标值
* 数组
	-   在M个大小的数组中找到第K大的数（最大堆）
	-   我现在有一个数组\[1,2,3,4\]，请实现算法，得到这个数组的全排列的数组，如\[2,1,3,4\]，•\[2,1,4,3\]。。。。你这个算法的时间复杂度是多少
	-   数组A，2\*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数 •先说下你的思路 •下一个奇数？怎么找？ •有思路么？ •你这样时间复杂度有点高，如果要求O(N)要怎么做
	-   手写算法，两个有序数组的合并。
	-   十万行二维数组，每行长度为10，每个数组降序，找出最大的15个数。先跟面试官说了思路，然后又在白纸上写了出来
	-   对一个数组进行绝对值排序的算法；
	-   非降序数组，打印某个值最后出现的位置
	-   找出数组中超过半数的那个数字（摩尔投票）
	-   一个数组反转，o(logn)复杂度用什么排序算法；
	-   一个 100长度数组, 里面是 固定的随机数, 要求列出重复的数字的最优算法.；
	-   给定两个数组，每个数组中都有重复的数字。不用类库函数，对这两个数组排序。
	-   给定一个数组，求该数组所有的自子数组 去掉一个字符串中的所有空格
	-   给定一个数组，元素的大小0~25，有重复元素。按出现频次的高低输出所有的数字
	-   给定一个乱序数组，求数组内最大连续的数；
	-   无序数组找第k大的数
	-   给一个数组，和k，求数组中的哪两个数之和为k，除了双层for循环和字典的方式还能用什么方式实现；
* 查找
	-   写二分查找算法
	-   有主字符串A，子字符串B，在A中查找B
	-   手撕一个有序数组的二分查找算法
	-   请说出二分查找的实现思路及时空复杂度。
	-   用二分法查找一个长度为18的，排好的线性表，当查找不成功时，最多需要比较多少次
* 排序

	-   快排怎么实现的，快速排序（包括算法步骤、平均算法复杂度、最好和最坏的情形）
	-   5亿整数的大文件，怎么排？
	-   两个1G排好序的文件，按序合并
	-   手写归并排序。 两个有序数组合并。
	-   常见的排序算法有哪些？各种排序算法的平均时间复杂度和最坏情况下的时间复杂度？
	-   写出你熟悉的排序算法，并说明其优缺点
	-   给了长度为N的有重复元素的数组，要求输出第10大的数。
	-   手写一下快速排序吧，我看你参加过ACM，所以用非递归实现一下。
	-   快排听过吗？他是怎么实现的？
	-   如果是单链表的快速排序，你怎么做？
	-   快排时间空间复杂度，最好最坏的情况，优化方案？
	-   手写了冒泡排序
	-   手写递归排序等
	-   两个排序好的数组，构思算法把一个按序插入另一个数组
	-   手工实现一个快速排序算法
	-   列举数据的几个排序算法
	-   快速排序？快速排序是稳定的么？ 如何实现一个快速排序的稳定性？
	-   给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。
	-   快排会吗？知道原理吗？
	-   排序算法，介绍一下快速排序，快速排序时间复杂度，是不是稳定排序，介绍几种你所知道的稳定排序算法
	-   10亿个数选最大的K个，用什么方法，复杂度多少
	-   说一下冒泡排序的原理
	-   请对3个有序数组进行归并排序
* 树

	-   AVL树和B树的概念、细节，比如会问mysql数据库的索引的实现原理，基本上就等于问你B树了。
	-   红黑树，这个基本上必问的一个数据结构，包括红黑树的概念、平均算法复杂度、最好最坏情况下的算法复杂度、左右旋转、颜色变换。
	-   找出二叉树中任意两个节点的最低公共根节点, 如果树是BST呢. 深度优先搜索+二分查找树性质
	-   B+树如何分裂？
	-   二叉树前中后遍历 二叉树层次遍历 二叉树深度优先遍历(递归、非递归) 二叉树广度优先遍历(递归、非递归) 和为n的二叉树路径 二叉树深度 二叉树是否对称 链表反转
	-   红黑树有啥特性?
	-   二叉树层序遍历输出，每一层输出数组（手写算法）。
	-   JDK1.8采用的红黑树特性，以及采用红黑树的理由而不采用AVL和B树的原因？
	-   一个二叉搜索树，找出某两个节点的公共祖先。
	-   给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 例如，输入: root = \[6,2,8,0,4,7,9,null,null,3,5\], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = \[6,2,8,0,4,7,9,null,null,3,5\], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
	-   平衡二叉树的基本概念 简单介绍一下b+树
	-   多叉树的生成 给定一个数组【\[a,b\]、\[c,b\]、\[e,a\]、\[h,a\]、\[k,h\]】，数组前一个代表子节点、后一个代表父节点，生成一颗多叉树，返回根节点
	-   按照Z字形分层遍历二叉树，要求bug free，并且构造二叉树进行测试
	-   二叉树的右视图。
	-   写一个二叉树的深度遍历
	-   二叉树翻转
	-   二叉树的s型遍历，层序遍历的变种，简单，不过要写测试用例，等于还要写一个数组转二叉树的函数
	-   一颗非平衡二叉树，如何最快的方式找到距离最远的两个叶子节点。
	-   给一个二叉树和一个目标值，找到和等于这个值的所有路径
	-   B和B+树，B+树的搜索次数、为什么不用二叉树。
	-   红黑树最差旋转几次
	-   给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。 最近公共祖先是两个节点的公共的祖先节点且具有最大深度。 假设给出的两个节点都在树中存在。
	-   层次遍历二叉树，返回一个二维数组，每行表示一层
	-   不用迭代方法计算树的高度；
	-   假设一棵二叉树的后序遍历序列为DFGGEBHICA,中序遍历序列为：DBFEGAHCI,则前序遍历序列为？
	-   多叉树的第n层 层次遍历 2.递归太深会怎样？答栈溢出。为什么会栈溢出？python函数中的临时变量存在哪？那很深的时候，用循环会怎样呢？为什么不会栈溢出？
	-   给定一个二叉树，依次打印出每一行
	-   前序遍历 中序遍历 后序遍历 知道那些可以恢复二叉树，只知道前序和后序可以吗？
	-   有N个节点的满二叉树的高度
* 其他

	-   哈希表，对哈希表的细节要求很高，比如哈希表的冲突检测、哈希函数常用实现、算法复杂度；比如百度二面就让我写一个哈希表插入元素算法，元素类型是任意类型。
	-   找出两个有序数组中的重复项，分析时间和空间复杂度，然后就是不断优化优化优化。。 要是数组长度非常大会出现什么情况？
	-   俩线程分别持续打印奇数和偶数，实现俩线程的交替打印（从小到大）
	-   给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k\[encoded\_string\]，表示其中方括号内部的 encoded\_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2\[4\] 的输入。 示例: s = "3\[a\]2\[bc\]", 返回 "aaabcbc". s = "3\[a2\[c\]\]", 返回 "accaccacc". s = "2\[abc\]3\[cd\]ef", 返回 "abcabccdcdcdef".
	-   leetcode213 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: \[2,3,2\] 输出: 3 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2: 输入: \[1,2,3,1\] 输出: 4 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。
	-   有15个瓶子，其中最多有一瓶有毒，现在有四只老鼠，喝了有毒的水之后，第二天就会死。如何在第二天就可以判断出哪个瓶子有毒
	-   看你简历提到了raft算法，讲下raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？有没有了解过paxos和zookeeper的zab算法，他们之前有啥区别？
	-   根据身高重建队列 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意： 总人数少于1100人。 示例 输入: \[\[7,0\], \[4,4\], \[7,1\], \[5,0\], \[6,1\], \[5,2\]\] 输出: \[\[5,0\], \[7,0\], \[5,2\], \[6,1\], \[4,4\], \[7,1\]\]
	-   一个二维数组，每一列的数字从左往右增大，每一行从上往下增大，求一个指定的数字在这个数组中的位置
	-   给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，输入: root = \[6,2,8,0,4,7,9,null,null,3,5\], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = \[6,2,8,0,4,7,9,null,null,3,5\], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
	-   股票买卖的一道题 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 输入: \[1,2,3,0,2\] 输出: 3 解释: 对应的交易状态为: \[买入, 卖出, 冷冻期, 买入, 卖出\]
	-   给你一个 n \* m 的二维整数数组，数字都是大于等于0，现在要你对数组做一种操作，对于所有0，将0所在的行和列全部变为0。要求使用尽量少的空间和时间。
	-   给你一个整数数组，数组中的元素定义一种距离 d\[i\] 为将数组排序后，该元素移动的距离，现在给你一个K数组，即数组中所有元素的距离d <= k，对这个K数组排序，希望尽量小的时间复杂度。
	-   输入一个不含相同整数的整数集合，输出所有子集 输入：\[1,2,3\] 输出：\[\[\],\[1\],\[2\],\[3\],\[1,2\],\[1,3\],\[2,3\],\[1,2,3\]\] 有三十瓶水，十个桶，每个桶能放0-10瓶水，有多少种方案
	-   给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。 示例: 输入: s = "abcdefg", k = 2 输出: "bacdfeg" 要求: （1）该字符串只包含小写的英文字母。 （ 2）给定字符串的长度和 k 在 \[1, 10000\]范围内。
	-   翻转字符串，反转句子等。
	-   判断一串字符串里括号的最大有效长度。用动态规划实现
	-   给一个字符串，找出连续相同的字符，如果有两个以上相同的，取ASCII码小的。
	-   给一个字符串，删除最大连续相同的字符串并返回
	-   有一组未排序的整形数组，你设计一个算法，对数组的元素两两配对，然后输出最大的绝对值差和最小的绝对值差的"对数"
	-   m\*n二维数组整体有序，查找value
	-   返回一个数字数组的排序值，比如数据\[6,2,5,0\]的返回是\[4,2,3,1\]；
	-   一个正数数组，长度为N，且数组元素<N，统计每个正数出现的次数，要求时间复杂度O(n)，空间复杂度O(1)；
	-   实现一个fibonacci函数，输入数字n，输出fibonacci数列的第n项数字，并给该函数加入缓存功能。
	-   100G文本找某个单词出现的频率
	-   是否连接红黑树 •
	-   是否了解数据结构的“堆”
	-   斐波拉契数列非递归实现
	-   算法n的阶乘末尾0的个数
	-   我一个文件,有45亿个阿拉伯数字,如何进行去重啊?如何找出最大的那个数啊?
	-   写一个fibnaccio的相关例子
	-   输入两个字符串str1 str2和整数n，要求两个数以n进制相加，然后输出字符串str3
	-   就是二位数组如何进行螺旋输出 然后第二道的算法题是如何从25匹马中通过赛马的形式找到最快的3匹，每次最多只能5匹马参赛，问最少需要赛几次？答案是7次，我思路对了，不过我把次数给弄错了，多了2次没必要的比赛。
	-   6个元素1.2.3.4.5.6的顺序进栈，请问下列哪个不是合法的出栈序列？ a:345261 b:436521 c:245316 d:124653 e:543612
	-   图的最短路径问题
	-   算法题（爬楼梯，问一个人爬楼梯，每次只能爬一个台阶或两个台阶，问有N个台阶，总共能有多少种爬法）；
	-   实现一个random(m,n)方法，返回m到n的随机数
	-   64只球队找到最强的，找前二强的，前k强的
	-   就是m\*n的矩形从左上面到右下面的路径有多少条
	-   求N内的所有素数
	-   判断字符串是否是一个数字
	-   当一个文本文件中有200万行数据，如何在在每一行的尾部追加一个字符；
	-   求一个字符串中最长不重复子串的长度
	-   三个有符号的整型（long）数a, b, c，怎么判断a+b > c?实现并且设计测试用例（在main函数中调用，打印结果） （考虑同号越界问题）
	-   给一个字符串和一个k，要求找到不超过k个不同字符的最长子串的长度
	-   10进制转16进制（紧张了，有点费时间，啧啧啧）
	-   f(0)=0;f(1)=1; f(n)=f(n-1)+f(n-2) 求f（n）
	-   有主字符串A，子字符串B，在A中查找B
* 基础
  - 数据结构
    + 数组、链表、栈、队列、散列表、二叉树、堆、图的定义等
    + 跳表、并查集、线段树、树状数组
  - 算法
    + 排序、二分查找、二叉树上的操作（遍历、查找、插入、删除等）、图的深度广度优先搜索、字符串朴素匹配算法，以及递归、分治、贪心、回溯、动态规划等基础算法思想。
    + BM算法、KMP算法、AC自动机、红黑树、B+树、图的一些高级算法（比如最大流、二分匹配、Dijkstra、Floyd算法）等。
  - 对于基础的数据结构和算法，需要掌握原理、熟练代码实现、复杂度分析等，毕竟它们是很多算法问题解决的基础，需要掌握牢固
  - 对于高级的数据结构和算法，只需要理解算法原理、掌握应用场景，对于代码实现，基本上不做要求，更不需要像对待基础数据结构和算法那样，要牢记原理和实现
* 用比较长的一段时间（比如半年）来刷题强化训练。目前，最著名的刷题网站非LeetCode莫属，可以针对每种类型，选择一些题目刻意训练
  - 面试前一定要在纸上多练习一下，做到脑袋里想好算法之后，能一气呵成地写出代码
* 解题技巧
  - 跟面试官沟通确认问题，包括数据规模、输入输出要求，以及其他一些不清楚的地方，一定要确认没有理解误差之后，再进行答题。
  - 答题的过程，先思考最简单的解决方案，说给面试官听，然后再行优化，思考更加好的解决方案。这样做的目的是，一方面能缓和自己紧张的心情，不至于大脑放空、卡壳，另一方面，一开始就思考最优解法，可能要闷头想很久，面试官很难知道你的思考进度，也无法基于你现有的思考进度做提示。
  - 不管题目的难易，建议每个题目的思考时间都不要超过10分钟。10分钟还想不出解法，更多的时间可能也无济于事了，而且10分钟是面试官可以忍受的沉默时间的极限。所以，如果10分钟还没有思路，建议跟面试官沟通，以求给与提示。
  - 在想到最优解决思路之后，也不要着急写代码，先要跟面试官沟通，看是否满足面试官的要求。在得到面试官的肯定之后，再进行编码实现，以免进入思维误区，想出来的解决办法有漏洞，并非正确或最优解，急匆匆地写代码，写完才发现有问题，最后也没有时间去改正或优化了。
  - 编码也是一个非常重要的环节。很多算法问题，即便有了解决思路，编码实现也并不简单。比如在O(1)空间复杂度内判断存储在链表中的字符串是否是回文串这样一个题目，实际上，它就是反转链表和链表求中间结点这两个问题的组合，算法并不难，但要正确、快速地用代码实现，并不简单，需要处理很多细节，稍有不慎就会引入bug，非常考验候选人的编码能力。
  - 除此之外，在编写代码的过程中，一定要注意编码规范，保证代码整洁、可读，切记使用i、j、k这样的字母来命名重要的变量。一目了然的命名，清晰的代码结构，会反映出候选人良好的编程习惯，从而赢得面试官的好感。
  - 在写完代码之后，一定要进行单元测试。列举完备的测试用例，特别是一些极端测试用例，比如输入为0、null等，看程序是否运行正确。一方面能验证自己写的代码的正确性，另一方面还能发现一些边界条件处理不到位的情况，再者还能让面试官觉得你思考问题比较全面、细心。
  - 一般情况下，面试官会自己阅读你的代码来判断是否编写正确，但也有些面试官会要求候选人逐行解释代码。为了方面解释，特别是针对链表或树相关的一些复杂问题，我们可以通过具体的例子或者画图来辅助讲解。
  - 算法面试并非笔试，并不只看最终答案，考察的重点是候选人在面试的过程中体现出来的沟通能力、逻辑思维能力、分析问题能力、优秀的编码开发能力等等。所以，有的时候即便你没有给出最优解决思路，也有可能会被录用，而有的时候，你觉得回答的很不错，给出了最优解，也未必会被录用。

## 课程

* [算法导论 Introduction to Algorithms](https://www.bilibili.com/video/av48922404)
  - [MIT](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2008/)
  - [麻省理工学院公开课：算法导论](https://www.bilibili.com/video/av1149902)
  - [cplusplus-_Implementation_Of_Introduction_to_Algorithms](huaxz1986/cplusplus-_Implementation_Of_Introduction_to_Algorithms):《算法导论》第三版中算法的C++实现
* [十大算法精讲](https://www.bilibili.com/video/av18109226/)
* [公开课](http://open.163.com/special/opencourse/algorithms.html)
* [Erickson 算法](http://jeffe.cs.illinois.edu/teaching/algorithms/)
  - [algorithms](https://github.com/jeffgerickson/algorithms):Bug-tracking for Jeff's algorithms book, notes, etc.
  - [作业](http://jeffe.cs.illinois.edu/teaching/algorithms/hwex.html)
* [屈婉玲教授的算法设计分析](https://www.bilibili.com/video/av83623454?p=1)
* 九章算法班 令狐冲 算法面试精选100题

## 图书

* [Algorithms, 4th Edition Sedgewick](https://algs4.cs.princeton.edu/home/)
  - [ppt](https://www.cs.princeton.edu/~wayne/kleinberg-tardos/)
* 算法导论 CLRS 
* The Algorithm Design Manual
  - Steven Skiena’s lectures
* [An Introduction to the Analysis of Algorithms](https://aofa.cs.princeton.edu/home/)
* 算法设计
* 算法设计手册
* 《大话数据结构》
* 《剑指offer》
* 算法图解
* 编程珠玑 Programming pearls
* 《[Python算法教程](https://www.amazon.cn/gp/product/B019NB0VCI)》
* 《[算法设计与分析基础（第3版）](https://www.amazon.cn/gp/product/B00S4HCQUI)》
* 《[数据结构与算法分析 : C++描述（第4版）](https://www.amazon.cn/gp/product/B01LDG2DSG)》
* 《[数据结构与算法分析 : C语言描述（第2版）](https://www.amazon.cn/gp/product/B002WC7NGS)》
* 《[数据结构与算法分析 : Java语言描述（第2版）](https://www.amazon.cn/gp/product/B01CNP0CG6)》
* 《数据结构与算法 JavaScript 描述》
* 《[学习 JavaScript 数据结构与算法](https://www.amazon.cn/gp/product/B016DWSF8M)》
* Algorithms to Live
* [Analytic Combinatorics](https://ac.cs.princeton.edu/home/)
* [Problem Solving with Algorithms and DataStructures](https://www.cs.auckland.ac.nz/compsci105s1c/resources/ProblemSolvingwithAlgorithmsandDataStructures.pdf)

## 工具

* [xxHash](https://github.com/Cyan4973/xxHash):Extremely fast non-cryptographic hash algorithm <http://www.xxhash.com/>
* [cheatsheet](https://www.bigocheatsheet.com/)
* collabedit.com
* coderpad.io

## 参考

* [cosmos](https://github.com/OpenGenus/cosmos):[Show ❤️ love by 🌟] Your personal library of every algorithm and data structure code that you will ever encounter
* [interactive-coding-challenges](https://github.com/donnemartin/interactive-coding-challenges):Huge update! Interactive Python coding interview challenges (algorithms and data structures). Includes Anki flashcards.
* [algorithms](https://github.com/keon/algorithms)Minimal examples of data structures and algorithms in Python
* [algorithm](https://github.com/LeuisKen/algorithm)
* [Dictionary of Algorithms and Data Structures](https://xlinux.nist.gov/dads/)
* [Algorithm](https://github.com/frowhy/Algorithm)
* [python](https://github.com/ssjssh/algorithm)
* [Python](https://github.com/TheAlgorithms/Python):All Algorithms implemented in Python
* [Java](https://github.com/TheAlgorithms/Java):All Algorithms implemented in Java
* [Go](https://github.com/TheAlgorithms/Go):Algorithms Implemented in GoLang
* [Algorithms-Learning-With-Go](https://github.com/skybebe/Algorithms-Learning-With-Go):算法学习 Golang 版，参考 raywenderlich/swift-algorithm-club
* [Javascript](https://github.com/TheAlgorithms/Javascript):A repository for All algorithms implemented in Javascript (for educational purposes only)
* [javascript-algorithms](https://github.com/trekhleb/javascript-algorithms):📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings
* [Algojammer](https://github.com/ChrisKnott/Algojammer):An experimental code editor for writing algorithms
* [algorithm-visualizer](https://github.com/algorithm-visualizer/algorithm-visualizer):🎆Interactive Online Platform that Visualizes Algorithms from Code <https://algorithm-visualizer.org/>
* [VisuAlgo](https://visualgo.net/en):visualising data structures and algorithms through animation
* [algorithm004-01](https://github.com/algorithm004-01/algorithm004-01)
* [over-algorithm](https://github.com/overnote/over-algorithm)
* [](https://github.com/allentofight/algorithm)

* [](https://www.techiedelight.com/)
* <https://www.geekxh.com/>
* [动态规划解题技巧](https://mp.weixin.qq.com/s?__biz=MzI1MzYzMTI2Ng==&mid=2247484431&idx=3&sn=35abe41394f24167b78419edbc36fc7c)
* [我接触过的前端数据结构与算法](https://juejin.im/post/5958bac35188250d892f5c91)
* [wangzheng0822/algo](https://github.com/wangzheng0822/algo):数据结构和算法必知必会的50个代码实现
* [美国高薪计算机大公司流行算法面试题，LeetCode算法题成为破解高薪之道？ - ycombinator](https://www.jdon.com/54814)
