# 原则

- 单一职责：一个类应该只做一类事情 一个方法最多只做一件事情
- 不要做超前的设计
- 第三次重复它的时候才抽出为方法或封装类

## 逻辑

* 拆分逻辑变成步骤的注释；
* 将注释视复杂度变成方法；
* 递归对方法使用此技巧。
* 功能拆分颗粒度，并做架构

## 架构

* 开发过大中型项目就会发现，编码（Coding）其实在整个项目阶段，连三分之一都占不到。
* php不知为什么用分层与框架
    谈到分层，任何一个 java 框架都可以甩 PHP 几条街。

## 思考

* 与人沟通比与机器沟更重要
* 了解在做什么以及为什么：用代码来解决问题
    - 可以抛开技术做决策。这个功能是必需的吗？它解决了什么问题？可以用其他方式来解决这个问题吗？真的有必要解决这个问题吗
    - 这些都是业务问题，如果你想把工作做好，不仅要理解这些业务，还要主动参与其中。即使你在公司里不是 C 级别的人，也不影响你这么做，至少，你要明白自己在做什么。
* 如果代码评审让你感到有压力，那肯定是打开方式出错了
    - 看到臭代码，可能其中会有一些不为人知的原因
    - 当然，也有可能是因为他们的编程技能还不够好，这个时候你要承担起“导师”的角色，给他们提供一些指导。
* 未雨绸缪，应对 墨菲定律
* 不要害怕让别人看到自己的无知
* 分享：当你在教一个人的时候，其实有两个人在学
* 逻辑法则
    - 归纳法 从个别到一般
    - 演绎法 从一般到个别
* 知识广义上来讲可以分为五类：数据、信息、知识、才能和智慧。数据经过整理变成信息，信息能解决某个问题就是知识，知识通过反复实践形成才能，才能融会贯通就是智慧。才能和智慧就属于元认知的范畴。
* 厉害的人就是在任何条件下都能保持稳定质量的输出。

## 定律

* Murphy’s Law：如果事情可能出错，它就会出错。 侥幸心理  别觉得我们逃得过
* Brook’s Law：为已经延期的软件项目增加人手只会让项目延期得更厉害
* Hofstadter’s Law：即使你考虑到了霍夫施塔特定律，项目的实际完成时间总是比预期的要长
* Conway’s Law：组织所设计的系统的结构受限于组织的通信结构。
    - 根据目标软件架构来组建团队可以更容易实现软件架构
* Postel’s Law：保守输出，自由输入
* Pareto Principle：对于很多现象，80％的后果源于 20％的原因。
* The Peter Principle：在一个等级制度中，每个员工都倾向于晋升到他无法胜任的职位。
* Kerchkhoff’s Principle：在密码学中，系统应该是安全的，即使系统的所有东西都是公开的——除了一小部分信息——秘钥。
* Linus’s Law：如果有足够多的眼睛，所有的 bug 都将无所遁形。
    - 大教堂模型——每个软件发行版都提供源代码，但发行版之间的代码开发仅限于一组专有的软件开发人员。
    - 集市模型——代码开发通过互联网公开进行。
* Moore’s Law：单位成本的计算机算力每 24 个月翻一番
* Wirth’s Law：软件比硬件更容易变慢。
* Ninety-Ninety Rule：前 90％的代码占用了 10％的时间，其余的 10％代码占用了剩下的 90％时间。
* Knuth’s Optimization Principle：过早优化是万恶之源。
* Norvig’s Law：任何超过 50％渗透率的技术都不会再次翻倍
* 边际收益递减:发展到比较成熟的阶段以后，以后每一步的进展会越来越小
* 太牛逼的人往往机会成本很高，导致他的人生选择其实是很艰难的，这是人生的几大悖论之一。一定会选择那个时候最好的决定，但是世界往前走的过程一般都是牛逼的衰败，不牛逼的起来，这个时候，能力越强的人，反而会赶不上当初不如他们牛逼的人。
* 人们总是倾向于，多消费时间成本低的东西.做得快的核心，就是要让时间成本降下来，从而多做。

## 个人

* Getting Things Done
* 聪明努力的去做事情，就算不是为了组织，或者很多时候，跟组织的得失关系不大，但是跟你自己关系更大
* 绝对不能仅仅去做一个螺丝钉，对自己的未来发展毫无想法，对技术潮流趋势漠不关心

## 参考

* [nusr/hacker-laws-zh](https://github.com/nusr/hacker-laws-zh):computerbook Laws, Theories, Principles and Patterns that developers will find useful. (对开发人员有用的定律、理论、原则和模式。)
