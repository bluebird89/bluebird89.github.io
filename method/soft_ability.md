# 软能力

* 沟通:停下来跟产品或者客户明确每个功能点
* 工作自主驱动
* 逻辑清楚，具备良好问题定位分析能力
  - 了解问题
  - 解决方案：有侧重点，思路连续
* 真正高级工程师可以带来一种清醒和广阔的视野
* 编程关键根本就不是编程语言，而在于背后思想
  - 分层，抽象，分而治之
  - 把变化的部分和不变的部分给隔离开
  - 让各个功能独立地变化和扩展， 汝等需认真学习，积极思考，多加实践
* 主动、皮实、聪明、担当，有良好沟通和团队协作能力，持续推动拿结果
* Mentor and motivate developers
* Suggest and enforce best code practices
* Perform code reviews
* Aid developers in problem-solving
* Work closely to Project Managers and Business Analysts
* Work closely with the client. Task prioritization.
* Requirements gathering. Create tasks and assign them to a developer
* Identify risks and impediments and give a proper response
* Gather everything needed to start writing code (technical documentation, business documentation, images, task description, acceptance criteria, etc.)
* Delegate activities when needed
* Conduct daily SCRUM stand-up meetings
* Backlog grooming
* Work with other stakeholders of the project, particularly technical ones
* Design solution diagrams when needed
* Data analysis when needed
* Review technical documentation
* API testing and documentation
* Present finished sprint work to the project stakeholders
* Perform tests, work closely with the QA team
* Manage technical debt and iceboxes
* Suggest tools that will improve coding speed and quality
* Determine technical constraints
* Conduct UAT tests
* SPOC (single point of contact) for technical problem solving

## 素养

* 基础扎实
  - 意义:有基础能迅速知道顶层讲什么
* 内功扎实
  - 数据结构:熟知数组、堆栈、队列、链表、树、图、堆和散列表的相关知识点，并能够根据具体问题通过高级编程语言具体实现
  - 算法:熟知时间复杂度、空间复杂度、深度优先、广度优先、图论和动态规划等算法思想
  - 网络
  - 深入操作系统的内核
    + 可以了解计算机如何进行进程管理、内存管理、文件管理以及网络管理
  - 文件系统
  - 设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案
  - 主流编程范式及其思想
    + 命令式编程是行动导向（ Action-Oriented ）的，因而算法是显性而目标是隐性的
    + 声明式编程是目标驱动（ Goal-Driven ）的，因而目标是显性而算法是隐性的
* 擅长抽象思维
* 动手能力强
* 追求效率
* 自动化
* 持续学习
* 代码质量
  - 有很高的追求
  - 写完一段代码之后，应该回头看一看，有没有坏味道？用适当的重构方法把坏味道消除掉，让代码质量保持在良好状态
  - 做前面几件事情的速度要快。只是头脑里知道怎么做，没有用，因为一旦有压力的时候，就很难施展出来，所以需要反复的练习，在压力下也能快速完成这一系列动作
  - 代码规范、质量、注释
    + ESLint 来进行可定制化的代码风格检查
    + 使用持续集成(CI)理念并通过相匹配的 CI 服务器进行软件交付
    + JSDoc 来规范注释代码
* [打字速度](https://typing.io/)至少达到 40WPM+
* 沟通能力
  - 不仅仅是说话或者写文档，能用自动化测试作为媒介，准确地框定需求范围
* 任务拆解
  - **能有效地拆解任务：把任务拆解成可以落地、可以逐步实施的小块**， 需要练习的事情
  - 应该能在保证质量的情况下，把拆解好的任务快速实现出来，让每一行代码都是有测试覆盖、有质量保证的
* 掌握编辑器或 IDE
  - 熟悉快捷键
  - 不用 IDE，用Notepad++：养成一种严谨的习惯
* 撰写软件工程文档
  - 概要设计说明书包括程序系统的基本处理流程、程序系统的组织结构、模块划分、功能分配、接口设计、运行设计、安全设计、数据结构设计和出错处理设计等，为程序的详细设计提供基础。
  - 软件需求说明是软件系统需求的规格化说明，是对将要开发系统的行为的说明。它包括功能性需求及非功能性需求，非功能性需求对设计和实现提出了限制，比如性能要求，质量标准，或者设计限制。
  - 测试说明书包括测试目标、测试范围、性能要求、测试资源、测试环境、测试策略。
  - 善于解释自己代码。代码提交信息几乎跟代码本身一样重要.对开发者的一个希望就是，能够更好地解释他们的代码是干嘛的，为什么需要变更以前的代码
* 代码审查、重构能力
  - 第一个层次：“业务架构”的代码审查与代码重构
  - 第二个层次：“代码架构”的代码审查与代码重构
  - 第三个层次：“设计模式”的代码审查与代码重构
  - 第四个层次：“最优算法”的代码审查与代码重构
  - 第五个层次：“语言与代码规范”的代码审查与代码重构
* 拥有良好版本控制、项目管理意识：Trello、Teambition
* 掌握软件测试相关能力：白盒测试、黑盒测试、单元测试、集成测试、测试驱动开发
  - 黑箱测试测试应用程序的功能，而不是其内部结构或运作，适合集成测试以及系统测试等；
  - 白箱测试测试应用程序的内部结构或运作，而不是应用程序的功能，可应用于单元测试、集成测试中。单元测试的目的是检验基本组成单位（函数）的正确性。
* 熟练绘制概念图、思维导图、流程图、网络拓扑图等
* 掌握持续集成、持续交付、持续部署相关编程能力
* Lambda 演算，编译原理，形式语言，自动机
* 遇到问题解决问题
* 根据文档学习一门知识

* 需求评审
  - 技术需求主要指性能优化、架构演进此类的需求，这个不做讨论，只聊产品需求
  - 产品需求自然是产品经理给的，这里就从产品经理的分类开始讲需求分析能力。
  - 前台产品
    + 主要是指设计用户使用功能界面以及交互的,关注产品原型和交互
    + 输出原型以及简单的逻辑说明,需要逻辑梳理工作并与产品反复确认
  - 后台产品
    + 主要是指设计支撑前台产品所需的后台逻辑架构的,关注后台逻辑架构
* 程序设计
  - 业务建模:把产品方案涉及的流程图和数据模型ER图都整理出来
    + 流程建模
    + 数据建模
* 架构能力：解决代码规模的问题，包含了一些意识，比如解耦、接口隔离，也包含认识业务建立抽象模型，也有一些常见的模式
  - 设计模式
  - 问题往深看一步 想一步，就可能有结果
* 工程能力：解决协作的问题，当系统规模更大，光靠一个人，是没办法完成的，如何保证几个高手互相能够配合好？如何保证项目里面水平最差的人不拖后腿？这个工程化建设，往往会跨越多个业务，以汇报关系上的团队为单位来做。包括前后端解耦，模块化，质量保证，代码风格，等等。
  - 敏捷：快速实现
* 专业软件开发素养：
  - 良好编程实践：能够编写可测试（Testable），可扩展（Extensible），可维护（Maintainable）的代码
  - 把握客户需求：按时交付客户所需要的软件产品
  - 理解现代软件开发过程中的核心概念（例如面向对象程序设计，测试驱动开发，持续集成，和持续交付等等）
* 功能优化、重构
  - 数据库优化

* 文档处理能力，财务基础知识
* 订立计划并监督实行，且中间节点修改，并最终达成和考评的能力。这都是生活里基础的能力和技能。
* 信息获取容易
* 技能是“术”，术能傍身。但人生的目标一定是“道”，所谓的“道”，除了诉所谓的三观和生存能力，更多的是获取新技能的能力和学习的效率，知道自己缺失什么，可以举一反三的获得，且快速而有效。
* 沟通能力
  - 最快速的获取需要的信息
  - 能建立属于双方的中立持平的新的角度和立场
* 倾听能力：倾听并梳理信息，达到影响别人的目的

## 需求管理

## 方案设计

* 往大了讲是指技术选型，搭建整个系统架构基架
* 往小了讲，是指在已经搭建好的框架内，完成产品方案的实现落地。这里讲小的，就是在需求分析、业务建模完成的基础上，做详细设计方案
  - 组件图旨在描述清楚当前模块与其他模块的关联，从微服务划分的角度看，要识别微服务的业务边界，控制好微服务的粒度
  - 类图旨在描述清楚当前模块涉及的类以及类之间的关系。在类设计的过程中，合理的使用设计模式，可以极大的提高代码的可复用、可维护性。
  - 时序图是流程图的另一种表现形式，可以清晰的展现整个代码的执行流程
  - 数据库DDL重点关注的是表结构和索引的设计是否合理
  - 缓存设计重点关注的是数据类型以及更新机制

## 开发编码能力：用代码解决问题能力

* 使用技术的时候一定要用最合适的，而不是最好的
* 业界基本的开发规范
* 多读高质量代码

## 项目管理

* 管控进度和质量。进度怎么管？项目经理应该给出一个有效的团队协作、进度把控方式

## 配置管理

## 质量保障

## 知识学习

对知识学习的目标，理解为亮点，一曰准确，二曰全面

* 寻找线索：找一些比较准确的，你可以确定它真的足够全面的资料当作线索
* 建立联系：其实大部分的 API，可以依据面向对象的数据和操作的观点进行划分。
* 依据知识之间的联系，进行分类，就可以得到一张图谱.全面
* 占了全面两个字，接下来需要确认它的准确性。就是追本溯源，去找它最初的讨论和定义。
* 不断接受新知识，挑战、质疑原有的体系，推翻再重建，每一次循环，你的知识体系都变得更加坚固，更加强大。
* 现代网络世界，信息的获取容易，摘取难。那些真的有信息寻找能力、方法，并能最快速度判别信息价值的技能，将会是未来人与人之间差异的根本点之一。
* 所谓拓宽自己熟悉的领域，是指得知道这个领域都在发生什么，最顶尖的是什么情况，这不代表你一定要采用和最顶尖一样的方案，或者要超过最顶尖的，但至少应该知道最好的是怎么样的，以便更好的根据自己所面对的场景，以及目标，来做适当的决定
* 有意义的学习涉及到新概念和命题纳入现有的认知结构的同化

## 能力培养

* 能力体系，恰恰是难以自己建立的，需要教材去指导。教材一定得花几个月的时间，一边读一边做习题。训练应该是系统的（需要教材）、主动的
* 选择一份对自己来说具有挑战性的工作，正面解决问题
* 永远不重复劳动，当你觉得现在的工作，越来越舒适，越来越缺少风险的时候，就应该引起警惕了

## 方法

* 记录错误日志
  - 依赖关系调用记录、错误记录
* 性能测试方法
* 超时处理
* 任务大多是一次性的，使用脚本语言操作就会比较合适。这些任务需要快速地编程，而代码用过一次一般就舍弃了

## 业务开发

* 做业务开发也能积累开发能力，如果业务比较复杂，一直做下去，还能积累业务壁垒

## 反思

- [ ] 基本功熟练
- [ ] 函数:功能、参数、返回值
- [ ] 理解的模模糊糊：去验证。
- [ ] 经验：自己亲自趟过一条河  ，看到的是别人总结出来的
- [ ] 问题的解决实现
- [ ] 自我认知：对自我有比较合理的认知，知道自己有什么样的水平，知道牛人能有多牛，知道自己相对别人的优势和劣势。行业很大，变化很快，必须有行业视野，才能有更好的自我认知。
- [ ] 成长性：

## 演讲

* 事先策划好扣人心弦的故事内容，配合简短而引人注目的标题，方便听众跟随他的思路步入下一步陈述的内容，同时不忘引入一个共同的对手，提供戏剧所需的情节冲突，引起听众的共鸣。 《乔布斯的魔力演讲》
* Why 有时候比How 更重要
  - 怎么才能通俗易懂地把这个知识点讲解出来呢？该怎么去类比呢？该从哪个角度切入呢
  - 技术本来是很简单的，只是上面笼罩着层层迷雾，让初学者难以看清
* 方法
  - 需求，问题，演进
  - 原理
  - 使用
  - 易理解，趣味
* 准备

## 培训

* 设计课程
* 开始演讲概略与时间
* 分段总结
* 课件材料准备

## 管理

* 熟悉业务，知道问题在哪里，怎样可以解决。领导者是给大家指方向的，必须先知道要走哪个方向，才能带领别人，这是领导力的基础。
* 培养说服能力，能说服他人，问题可以按照你说的方式解决。领导力的表现是，他人愿意服从你。这不能都靠制度压服，而要让他人真心觉得你是对的。如果你可以让他人相信你，你就可以领导。
* 激发他人的热情，让他们产生解决问题的热情。说服他人的更高境界，是让他们真正投身进来，自觉发挥自己的潜力，全力以赴解决需要解决的问题。好的领导和差的领导，区别就在于能否激励下级，让每个人都知道自己的职责，努力工作。
* 培养他人的领导能力

## What habits make a programmer great?

* What habits make a programmer great?Meta-habit: learn to adopt different habits for different situations. With that in mind, some techniques I've found useful for various situations:
* "Researchey" green-field development for data-science-like problems:
  1. If it can be done manually first, do it manually. You'll gain an intuition for how you might approach it.
  2. Collect examples. Start with a spreadsheet of data that highlights the data you have available.
  3. Make it work for one case before you make it work for all cases.
  4. Build debugging output into your algorithm itself. You should be able to dump the intermediate results of each step and inspect them manually with a text editor or web browser.
  5. Don't bother with unit tests - they're useless until you can define what correct behavior is, and when you're doing this sort of programming, by definition you can't.
* Maintenance programming for a large, unfamiliar codebase:
  1. Take a look at filesizes. The biggest files usually contain the meat of the program, or at least a dispatcher that points to the meat of the program. main.cc is usually tiny and useless for finding your way around.
  2. Single-step through the program with a debugger, starting at the main dispatch loop. You'll learn a lot about control flow.
  3. Look for data structures, particularly ones that are passed into many functions as parameters. Most programs have a small set of key data structures; find them and orienting yourself to the rest becomes much easier.
  4. Write unit tests. They're the best way to confirm that your understanding of the code is actually how the code works.
  5. Remove code and see what breaks. (Don't check it in though!)
* Performance work:
  0. Don't, unless you've built it and it's too slow for users. Have performance targets for how much you need to improve, and stop when you hit them.
  1. Before all else (even profiling!), build a set of benchmarks representing typical real-world use. Don't let your performance regress unless you're very certain you're stuck at a local maxima and there's a better global solution just around the corner. (And if that's the case, tag your branch in the VCS so you can back out your changes if you're wrong.)
  2. Many performance bottlenecks are at the intersection between systems. Collect timing stats in any RPC framework, and have some way of propagating & visualizing the time spent for a request to make its way through each server, as well as which parts of the request happen in parallel and where the critical path is.
  3. Profile.
  4. Oftentimes you can get big initial wins by avoiding unnecessary work. Cache your biggest computations, and lazily evaluate things that are usually not needed.
  5. Don't ignore constant factors. Sometimes an algorithm with asymptotically worse performance will perform better in practice because it has much better cache locality. You can identify opportunities for this in the functions that are called a lot.
  6. When you've got a flat profile, there are often still very significant gains that can be obtained through changing your data structures. Pay attention to memory use; often shrinking memory requirements speeds up the system significantly through less cache pressure. Pay attention to locality, and put commonly-used data together. If your language allows it (shame on you, Java), eliminate pointer-chasing in favor of value containment.
* General code hygiene:
  1. Don't build speculatively. Make sure there's a customer for every feature you put in.
  2. Control your dependencies carefully. That library you pulled in for one utility function may have helped you save an hour implementing the utility function, but it adds many more places where things can break - deployment, versioning, security, logging, unexpected process deaths.
  3. When developing for yourself or a small team, let problems accumulate and fix them all at once (or throw out the codebase and start anew). When developing for a large team, never let problems accumulate; the codebase should always be in a state where a new developer could look at it and say "I know what this does and how to change it." This is a consequence of the reader:writer ratio - startup code is written a lot more than it is read and so readability matters little, but mature code is read much more than it is written. (Switching to the latter culture when you need to develop like the former to get users & funding & stay alive is left as an exercise for the reader.)

## 表达

> 程序员修炼之道

* Care About Your Craft关心你的技艺:我其实一直没有想明白这句话是什么意思. 我的理解是, 我们现在所学所掌握的技艺最后可能是要过时的, 要时刻关心最新的技术并尝试去学习. 不过虽然这么说, 但是如何做就是见仁见智了, 我在最近可能看了看 shell 编程, 学了学 Node.js, 还看了两眼 Golang, 最终我真正吸收的还是 Node.js, 对于 shell 和 Golang 看的我实在提不起兴趣. 不过我也没有强求, 毕竟不是靠这个吃饭的, 而且自己也没有什么兴趣, 索性就放弃了. 不过对于 Node 我还是巨有兴趣的. 这个月我都在为 SportJoin 编写 Node API.
* Think! About Your Work 思考! 你的工作
* Provide Options, Don’t Make Lame Excuses 提供这种选择, 不要找蹩脚的借口
* Don’t Live with Brokwn Windows  不要容忍破窗户
* Be a Catalyst for Change 做变化的催化剂
* Remember the Big Picture 记住大图景
* Make Quality a Requirements Issue 使质量成为需求问题
* Invert Regularly inYour Knowledge Portfolio 定期为你的知识资产投资
* Critically Analyze What You Read and Hear批判地分析你读到的和听到的
* It’s Both What You Say and the Way You Say it你说什么和你怎么说同样重要
* DRY — Don’t Repeat Yourself不要重复你自己
* Make It Easy to Reuse让复用变得更容易
* Eliminate Effects Between Unrelated Things消除无关事物之间的影响
* There Are No Final Decisions不存在最终决策
* Use Tracer Bullets to Find the Target用曳光弹找到目标
* Prototyle to Learn为了学习而制作模型
* Program Close to the Problem domain靠近问题领域编程
* Estimate to Avoid Surprises估算, 以避免发生意外
* Iterate the Schedule with the Code通过代码对进度表进行迭代
* Keep Knowledge in Plain Text用纯文本来保存知识
* Use the Power of Command Shells利用命令 shell 的力量
* Use a Single Editor Well用好一种编辑器
* Always Use Source Code Control总是使用源码控制
* Fix the Problem, Not the Blame要修正问题, 而不是发出指责
* Don’t Panic不要恐慌
* “Select” Isn’t Broken“Select” 没有问题
* Don’t Assume it — Prove It不要假定, 要证明
* Learn a Text Manipulation Language学习一种文本操纵语言
* Write Code That Writes Code编写能编写代码的代码
* You Can’t Write Perfect Software你不可能写出完美的软件
* Design with Contracts通过合约进行设计
* Crash Early早崩溃
* If It Can’t Happen, Use Assertions to Ensure That It Won’t如果它不可能发生, 用断言确保它不会发生
* Use Exceptions for Exceptional Problems将异常用于异常的问题
* Finish What You Start要有始有终
* Minimize Coupling Between Modules使模块的之间的耦合减少
* Configure, Don’t Integrate要配置, 不要集成
* Put Abstractions in Code, Details in Metadata将抽象放进代码, 细节放进元数据
* Analyze Workflow to Improve Concurrency分析工作流, 以改善并发性
* Design Using Services用服务进行设计
* Always Design for Concurrency总是为并发设计
* Separate Views from Models使视图与模型分离
* Use Blackboards to Coordinate Workflow用黑板协调工作流
* Don’t Program by Coincidence不要靠巧合编程
* Estimate the Order of Your Algorithms估算你算法的阶
* Test Your Estimates测试你的估算
* Refactor Early, Refactor Often早重构, 常重构
* Design to Test为测试而设计
* Test Your Software, or Your Users Will测试你的软件, 否则你的用户就得测试
* Don’t Use Wizard Code You Don’t Understand不要使用你不理解的向导代码
* Don’t Gather Requirements — Dig for Them不要搜集需求 — 挖掘它们
* Work with a User to Think Like a User与用户一同工作, 以像用户一样思考
* Abstractions Live Longer than Details抽象比细节活得更长久
* Use a Project Glossary使用一个项目词汇表
* Don’t Think Outside the Box — Find the Box不要在盒子外面思考 — 要找到盒子
* Listen to Nagging Doubts — Start When You’re Ready倾听反复出现的疑虑 — 等你准备好再开始
* Some Things Are Better Done than Described对有些事情”做”胜于”描述”
* Don’t Be a Slave to Formal Methods不要做形式的奴隶
* Expensive Tools Do Not Produce Better Designs昂贵的工具不一定能制作出更好的设计
* Organize Around Functionality, Not Job Functions围绕功能, 而不是工作职务进行组织
* Don’t Use Manual Procedures不要使用手工流程
* Test Early. Test Often. Test Automatically.早测试, 常测试, 自动测试.
* Coding Ain’t Done ‘Til All the Tests Run要到通过全部的测试, 编码才算完成
* Use Saboteurs to Test Your Testing通过”蓄意破坏”测试你的测试
* Test State Coverage, Not Code Coverage测试状态覆盖, 而不是代码覆盖
* Find Bugs Once一个 bug 只抓一次
* Treat English as Just Another Programming Language把英语当作又一种编程语言
* Build Documentation In, Don’t Bolt It On把文档建在里面, 不要栓在外面
* Gently Exceed Your User’s Expectations温和地超过用户的期望
* Sign Your Work在你的作品上签名

## 培养好的 Taste

* 不要局限于代码，去看那些好的文章，去看那些让你流泪的电影，去听那些让你心潮澎湃的音乐，去学 LaTeX 细究下各种字体的排版细节，去学学 Mathematica 看看什么叫做令人惊艳的交互，去买一个顶尖的降噪耳机体验下什么叫做瞬间安静的世界……
* 跳出你固有的思维舒适区，多体验多尝试多思考，当你的手、眼、脑、耳变得挑剔，当你听到 work around/trade off 这类字眼就本能得反感恶心和不舒服，你就明白，什么叫做“由俭入奢易，由奢入俭难”，你就懂得什么是好，什么是差，什么叫做 taste。

## [工程师职级胜任力框架](https://github.com/spring2go/engineer_completency_model)

* 目标
  - 作为工程师职业开发和成长路径的对标参考
  - 作为管理者评估工程师职级/能力+目标设定的对标参考
  - 作为HR开发工作描述(JD)和评估候选人职级/能力的对标参考
  - 作为企业文化建设的一种手段，将企业的核心价值观和文化融入职级胜任力框架(codify core value and culture into engineering level & competency matrix)，通过职级框架来引导工程师的价值认同和文化行为。
* 等级：各个工程级别的最主要差异在所能hold住的工作的范围scope，或者说影响力范围，其中
  - E1 ～ E3 属于独立贡献者(individual contributor)，工作范围有限，偏任务执行(Execution of Work)
    + E1 - 助理工程师(Associate Engineer) 任务范围内
    + E2 - 工程师(Engineer) 项目范围内
    + E3 - 高级工程师(Senior Engineer)小组/团队内
  - E4 ～ E6 能够善用人力(一般要带团队)和产品等杠杆进行规模化的生产(Utilizing skills to scale and generate leverage)，职级越高越偏向战略方向、理念和文化建设
    + E4 - 资深工程师(Staff Engineer) 整个团队范围
    + E5 - 高级资深工程师(Senior Staff Engineer)几个相关团队范围
    + E6 - 首席工程师(Principal Engineer)整个技术部门甚至公司
* 评估的纬度：5个关键区Key area-》15个价值Value维度-〉27个胜任力Competency纬度
* 技术技能(Technical skills)
  - 质量和测试
    + 写代码
      * 写代码时能意识到代码的可测试性和可读性的重要性，能意识到边界情况和错误处理。
      * 总是能写出易于测试和易于他人理解的代码，能考虑到各种边界情况并做合理错误处理。能书写有效的代码文档。
      * 总是能写出易于测试和易于其他开发者理解的生产级的代码，能充分考虑各种边界情况和做充分的错误处理。知道在必要时写代码注释，同时尽量让代码自注释self-documenting。
      * 同E3
      * 同E3
      * 同E3
    + 测试
      * E1  知道测试金字塔。能写单元测试(有时需要高级工程师的协助)。
      * E2  理解测试金字塔原理，并能根据测试金子塔的原理来编写单元测试，能在高级别工程师指导下编写高层测试(组件、集成、e2e测试等)。不仅能测试成功路径(happy path)，同时也能充分测试边界和错误情况。
      * E3  理解测试金字塔原理，并根据其原理来编写底层单元测试和中高层测试。能写出高质量的测试用例，全面覆盖成功路径、边界和错误情况。
      * E4  理解团队所使用的测试方法，通过质量指标改进测试。能根据团队所采用的测试框架和测试金字塔原理来改进测试方法。
      * E5  理解多个团队所使用的测试方法，并通过质量指标来改进测试。和这些团队协作，根据所采用的测试框架和测试金字塔原理来改进测试方法。能对组织的测试战略施加影响。
      * E6  理解公司级的测试方法，并通过质量指标来改进测试。和所有团队合作，根据所采用的测试框架和测试金子塔原理来改进测试方法。推进公司级的测试战略。
    + 调试
      * E1  理解调试基础，知道如何使用调试工具。
      * E2  能够使用系统性方法定位和调试单个服务的问题。
      * E3  能够熟练使用系统性方法定位和调试单个服务中的所有问题。能够使用系统性方法定位和调试跨服务问题(有时需要更高级工程师协助)。
      * E4  在所负责的领域内，能熟练使用系统方法定位和调试所有问题。
      * E5  在所负责的几个领域内，能熟练使用系统方法定位和调试所有问题。
      * E6  在需要时领导跨部门的事件应急响应机制。使用系统性方法定位和调试跨部门边界的问题。
    * 可观测性(Observability)
      * E1  N/A(该级别暂无要求)
      * E2  知道组织的监控理念，并熟悉自己团队领域内的主要运维监控指标。
      * E3  知道组织的监控理念。能帮助团队改进监控。能根据团队领域内的运维监控数据，对系统的稳定性和性能改进提出合理建议。
      * E4  根据组织的监控理念推动所在团队的监控工作。清楚知道所在领域的运维监控数据，能利用这些数据来推动团队改善服务的稳定性和性能。
      * E5  在多个团队间推动可观测的DevOps文化，帮助工程师利用运维数据来提升各自领域服务的稳定性和性能。
      * E6  在多个部门间推进可观测的DevOps文化，帮助公司内不同部门的工程团队利用运维数据来提升各自领域服务的性能和稳定性。
  - 软件设计和架构
    + 理解领域(domain)
      * E1  在高级工程师的帮助下，对团队的领域上下文有初步理解。
      * E2  对团队内的某部分领域有较深入理解，能在该领域内高产出地工作。
      * E3  对团队内的某个子领域有专业级掌握，能够进行一定的抽象建模，能利用领域抽象能力高产出地工作
      * E4  对团队负责的整个领域有专家级的掌握，包括领域内的服务，它们之间的交互，系统间的数据流等。对周边领域也要有一定理解，因为它们会影响自己团队的领域。
      * E5  对若干个相关领域有专家级掌握，包括领域内的服务，它们之间的交互，系统间的数据流等。
      * E6  对组织的整体架构有专家级的掌握，包括所有的领域，领域之间的边界，以及它们之间如何交互。
    + 软件架构
      * E1  对服务化架构有总体认识，在此基础上能够设计基本的服务/模块，同时尽量避免冗余代码/功能，减少对接口的不兼容变更。
      * E2  设计的服务要和总体服务化架构对齐(align with)。
      * E3  设计的服务/系统和总体架构始终对齐。能高效地利用抽象、模块化和重用机制。
      * E4  使用行业沉淀下来的成熟的设计模式来架构服务和系统，让团队可以增量和自治的开发，并考虑未来的扩展性。考虑未来的可能用例场景，在做设计决策时，以最小化未来变更成本为主要目标(也就是架构要灵活适应未来的变化)。
      * E5  在多个团队之间宣导能支持增量和自治开发的，并且能支持未来扩展的架构文化。指导多个团队考虑未来的可能用例场景，在做设计决策时，以最小化未来的变更成本为主要目标。
      * E6  在整个组织内宣导能支持增量和自治开发的，并且能支持未来扩展的架构文化。指导组织内的所有团队考虑未来的可能用例场景，在做设计决策时，以最小化未来的变更成本为目标。
    + 安全
      * E1  理解安全的重要性。
      * E2  理解安全的重要性。在做对安全可能有影响的决策时，咨询更高级工程师的意见。
      * E3  所有工程工作都要经过“安全放大镜”的检视。在做code review和peer review时，主动留意安全漏洞。
      * E4  积极和安全团队，还有自己的团队进行合作，根据组织的安全战略改进团队的安全方法。在团队中鼓励**安全优先(security first)**的理念，并作出榜样(leading by example)。
      * E5  积极和安全团队，还有其他多个团队进行合作，保障组织安全战略的落地。在多个团队间鼓励安全优先(security first)的理念，并作出榜样。
      * E6  积极和安全团队进行合作来制定和完善组织级别的安全战略。在多部门间宣导安全优先的理念。能够识别不易被他人察觉的安全威胁。
* 交付(Delivery)
  - 增量价值交付
    + 任务分解
      * E1  理解合理地将工作分解为大小适当的任务对持续集成和增量交付的重要性。
      * E2  在开始工作之前，确保任务已经被分解到适合持续集成和增量交付的大小(通常需要团队成员和管理者的帮助)。
      * E3  带着批判性眼光评审任务分解，确保任务已经被分解到适合持续集成和增量交付的大小。
      * E4  带着批判性眼光评审项目分解，确保项目已经被分解到适当大小并排优先级，并且团队成员充分理解这种分解和优先级。
      * E5  带着批判性眼光评审跨团队的工作分解，确保工作已经被分解到适当大小并排了优先级。并且所有涉及的团队都理解这种分解和优先级。
      * E6  带着批判性眼光评审组织级的工作分解，确保工作已经被适当分解并且在多部门间排了工作优先级。
    + 优先级和依赖分析
      * E1  按照优先级执行任务。
      * E2  理解并按照优先级执行任务。关注和说明任务依赖。
      * E3  确保任务的优先级设定合理，并且能说明依赖关系。
      * E4  确保任务级别的依赖关系已经被说明，并且团队也理解这些依赖关系。在团队中宣导优先级文化：集中力量解决优先级高的任务 + 优先级的设定要和组织战略对齐。
      * E5  确保跨团队的项目依赖关系已经被说明，并且所有涉及的团队和干系人stakeholders都充分理解这些依赖关系。在多个团队间宣导优先级文化：集中力量解决优先级高的任务/项目 + 优先级的设定要和组织战略对齐。
      * E6  识别组织的多个部门间的项目依赖关系，并且和相关团队合作，在这些依赖变成实际问题之前先想办法解决它们，并设计出预防性措施以防止依赖问题的重复出现。在多个部门间宣导优先级文化：集中力量解决优先级高的项目 + 优先级的设定要和组织战略对齐。
    + 应对不确定性(Dealing with ambiguity)
      * E1  N/A(该级别暂无要求)
      * E2  在个人工作范围内，通常能够有效处理风险、变更和不确定性。在日常业务处理(甚至在高压情况)中，即使没有明确的下一步指示，也能自动自发地决策和行动。
      * E3  在个人工作范围内，能够有效处理风险、变更和不确定性。在日常业务处理(甚至在高压情况)中，即使没有明确的下一步指示，也能自动自发地决策和行动。
      * E4  在团队范围内，能够有效处理风险、变更和不确定性。在团队范围内，在日常业务处理(甚至在高压情况)中，即使没有明确的下一步指示，也能自动自发地决策和行动。
      * E5  在多个团队范围内，能够有效处理风险、变更和不确定性。在多个团队范围内，在日常业务处理(甚至在高压情况)中，即使没有全景(total picture，足够的上下文)，也能自动自发地决策和行动。
      * E6  在多个部门范围内，能够有效处理风险、变更和不确定性。在多个部门范围内，在日常业务处理(甚至在高压情况)中，即使没有全景，也能自动自发地决策和行动。
  - 自我组织(self-organization)
    + 可信赖和责任感
      * E1  能够每天和团队交流工作进度。能够履行已经承诺的交付，并且具有一定的交付紧迫感。
      * E2  承诺和自身工作能力匹配的工作量(不夸大也不低估)，和团队保持沟通，以确保他们理解你的工作的优先级和紧迫性，并按照承诺履行交付。如果有任何阻碍(blockers)、延迟和成本激增问题，则每天要及时将这些问题升级反馈到团队。和团队澄清各自对工作的预期是什么(避免last minute surprise)。
      * E3  确保理性和现实的承诺，确保团队理解你的工作的优先级和紧迫性，并按照承诺履行交付。在需要升级阻碍、延迟和成本激增等问题之前，提前预期并沟通这些潜在的问题(防患于未然)。确保在团队中，所有相关人员对各自的工作的预期都是清楚的。
      * E4  在所在团队的项目中，在需要升级阻碍、延迟和成本激增等问题之前，提前预期并沟通这些潜在的问题(防患于未然)。确保在所在团队和外部干系人中，所有相关人员对各自的工作的预期都是清楚的。
      * E5  能够成功管理多个团队的交付承诺，交付路线图和进度汇报。在多个团队的项目中，在需要升级阻碍、延迟和成本激增等问题之前，提前预期并沟通这些潜在的问题(防患于未然)。确保在多个团队和外部干系人中，所有相关人员对各自的预期都是清楚的。
      * E6  能够成功管理整个组织级的交付承诺，交付路线图和进度汇报。确保在多个部门和外部干系人中，所有相关人员对各自的预期都是清楚的。
    + 经济思维
      * E1  理解在决策中的成本 vs 价值权衡的重要性。在工作中如果碰到需要这种决策的场景时，能够向更高级的工程师求助。
      * E2  在采取具体行动方案时，能够做成本 vs 价值分析，并采用最经济的行动方案，必要时向更高级的工程师咨询。在对团队成员提供建议时，有时能采用这种经济思维。
      * E3  在采取具体行动方案时，能够做成本 vs 价值分析，并采用最经济的行动方案，必要时咨询更高级的工程师。在自己的工作中，和对团队提供建议时，经常使用这种经济思维。
      * E4  在采取具体行动方案时，能够做成本 vs 价值分析，并采用最经济的行动方案。在自己的工作中经常使用这种经济思维。在所在团队中宣导这种经济思维文化(economic thinking culture)，确保作出及时且经济的决策。
      * E5  在采取具体行动方案时，能够做成本 vs 价值分析，并采用最经济的行动方案。在自己的工作中经常使用这种经济思维。在多个团队中宣导经济思维文化，确保作出及时且经济的决策。
      * E6  在采取具体行动方案时，能够做成本 vs 价值分析，并采用最经济的行动方案。在自己的工作中经常使用这种经济思维。在整个组织中宣导经济思维文化，确保作出及时且经济的决策。
* 反馈、沟通和协作(Feedback, Communication, Collaboration)
  * 反馈
    - 提供反馈
      * E1  知道如何有效地赞扬他人，如何提出建设性反馈。
      * E2  能够对团队组员和管理者表达赞扬和提出建设性反馈。
      * E3  能够对团队组员和管理者表达赞扬和提出建设性反馈。在时机恰当时，能够对团队的业务干系人提供反馈。
      * E4  在团队和团队的业务干系人中，鼓励赞扬和提出建设性反馈的文化。自己身体力行展示这种行为。
      * E5  在多个团队和团队的业务干系人中，鼓励赞扬和提出建设性反馈的文化。身体力行展示这种行为。
      * E6  在整个组织中，鼓励赞扬和提出建设性反馈的文化。自己身体力行展示这种行为。
    * 寻求和接收反馈
      * E1  积极主动向团队组员和管理者寻求反馈，并以寻求和接收反馈作为个人成长的重要途径。
      * E2  同E1
      * E3  同E1
      * E4  在团队和相关的业务干系人中鼓励主动寻求反馈的文化，并以反馈作为成长的重要途径。身体力行展示这种行为。
      * E5  在多个团队和相关的业务干系人中鼓励主动寻求反馈的文化，并以反馈作为成长的重要途径。身体力行展示这种行为。
      * E6  在整个组织中鼓励主动寻求反馈的文化，并以反馈作为成长的重要途径。身体力行展示这种行为。
  + 沟通
    * 有效沟通(Effective communication)
      * E1  能够面向听众(in an audience-oriented way，以听众为中心而不是自顾自表达)，有效、清晰和简洁地沟通(包括书面和口头形式)。积极聆听对方的反馈，确保你真正理解对方的关切。关注肢体语言。
      * E2  在和团队成员沟通时，不管是技术还是非技术主题，通常都能够面向听众，有效、清晰和简洁地沟通(包括书面和口头形式)。积极聆听对方的反馈，确保你真正理解对方的关切。关注肢体语言。
      * E3  在和团队成员沟通时，不管是技术还是非技术主题，始终都能够面向听众，有效、清晰和简洁地沟通(包括书面和口头形式)。积极聆听对方的反馈，确保你真正理解对方的关切。关注肢体语言。
      * E4  能够在具有多样背景和性格的团队中有效沟通。在团队中，鼓励清晰、简洁、有效和面向听众的沟通文化。确保团队成员能够积极聆听对方的反馈，真正理解对方的关切。身体力行展示这种行为。关注肢体语言。
      * E5  能够在具有多样背景和性格的多个团队间有效沟通。在多个团队间，鼓励清晰、简洁、有效和面向听众的沟通文化。确保团队成员能够积极聆听对方的反馈，真正理解对方的关切。身体力行展示这种行为。关注肢体语言。
      * E6  能够在整个公司中有效沟通。在整个公司中，鼓励清晰、简洁、有效和面向听众的沟通文化。确保团队成员能够积极聆听对方的反馈，真正理解对方的关切。身体力行展示这种行为。关注肢体语言。
    * 知识分享
      * E1  理解自己的职责范围内的工作，经常和团队成员分享知识。
      * E2  理解自己的工作领域，经常和团队成员分享知识，并积极充实团队文档库。留意可以分享知识的机会。
      * E3  理解所在团队的工作领域，经常和团队成员分享知识，并积极充实团队文档库。留意可以分享知识的机会，鼓励其他人也积极分享知识。
      * E4  在所在团队和相关业务干系人中，鼓励积极分享和书写文档的分享文化。身体力行展示这种行为。
      * E5  在多个团队和各自的相关业务干系人中，鼓励积极分享和书写文档的分享文化。身体力行展示这种行为。
      * E6  在整个组织中，鼓励分享和积极书写文档的分享文化。身体力行展示这种行为。
  + 协作
    * 团队合作(Teamwork)
      * E1  在组员请求帮忙的情况下，给予力所能及的帮助。为自己积累乐于助人的信誉，在得到别人的帮助时，也要记得别人的信誉。
      * E2  在组员请求的情况下，帮助组员一起克服阻碍完成工作。为自己积累乐于助人的信誉，在得到别人帮助时，也要记得别人的信誉。
      * E3  有时能主动帮助组员一起克服阻碍完成工作。为自己积累乐于助人的信誉，在得到别人帮助时，也要记得别人的信誉。
      * E4  总是能主动帮助组员一起克服阻碍完成工作。为自己积累乐于助人的信誉，在得到别人帮助时，也要记得别人的信誉。
      * E5  在多个团队范围内，总是能主动帮助组员一起克服阻碍完成工作。为自己积累乐于助人的信誉，在得到别人帮助时，也要记得别人的信誉。
      * E6  在整个组织范围内，赋能团队互帮互助，人人乐于积累和给予信誉。
    * 关系建设(Relationship building)
      * E1  在工作中和团队成员、管理者建立密切关系。
      * E2  在工作中和团队成员、管理者，以及对口的产品团队建立密切关系。
      * E3  在工作中和团队成员，管理者，以及相关业务的干系人建立密切关系。
      * E4  在工作中和团队成员，管理者，团队相关的业务干系人，以及组织内的高级别工程师之间建立密切关系，并不断提升这种关系。在做团队定位和计划的时候，充分利用这些建立的关系。
      * E5  在多个团队范围内，和工程师、管理者，还有相关业务干系人建立密切的关系。在为这些团队做定位和计划时，充分利用这些建立的关系。
      * E6  和整个组织范围内的成员建立密切的关系。在为整个组织做定位和计划时，充分利用这些建立的关系。
    * 解决分歧(Handling disagreement)
      * E1  讨论时，能积极参与讨论，公开表达自己的观点，同时尊重他人的意见。当发生意见分歧时，能以积极健康的方式解决分歧。能够根据他人的观点输入来调整和改变自己的视角和计划。
      * E2  讨论时，能积极参与讨论，公开表达自己的观点，同时尊重他人的意见。当发生意见分歧时，能够开诚布公(而非保守固执)，在有分歧观点的基础上，进行建设性的和富有成效的对话，通过深入理解对方关切来解决分歧。能够根据他人的观点输入来调整和改变自己的视角和计划。
      * E3  鼓励团队成员在讨论时，能积极参与讨论，公开表达自己的观点，同时尊重他人的意见。当发生意见分歧时，能够开诚布公(而非保守固执)，在有分歧观点的基础上，进行建设性的和富有成效的对话，通过深入理解对方立场来解决分歧。能够根据他人的观点输入来调整和改变自己的视角和计划。
      * E4  在团队内鼓励开诚布公和就事论事文化，鼓励团队成员在讨论时，能积极参与讨论，公开表达自己的观点，同时尊重他人的意见。当发生意见分歧时，能够开诚布公(而非保守固执)，在有分歧观点的基础上，进行建设性的和富有成效的对话，通过深入理解对方立场来解决分歧。能够根据他人的观点输入来调整和改变自己的视角和计划。
      * E5  在多个团队范围内，鼓励开诚布公和就事论事文化，鼓励团队成员在讨论时，能积极参与讨论，公开表达自己的观点，同时尊重他人的意见。当发生意见分歧时，能够开诚布公(而非保守固执)，在有分歧观点的基础上，进行建设性的和富有成效的对话，通过深入理解对方立场来解决分歧。能够根据他人的观点输入来调整和改变自己的视角和计划。深入挖掘表层分歧的背后关切，并将这些关切整合到各自的视角和计划中。
      * E6  在整个组织范围内，鼓励开诚布公和就事论事文化，鼓励团队成员在讨论时，能积极参与讨论，公开表达自己的观点，同时尊重他人的意见。当发生意见分歧时，能够开诚布公(而非保守固执)，在有分歧观点的基础上，进行建设性的和富有成效的对话，通过深入理解对方立场来解决分歧。能够根据他人的观点输入来调整和改变自己的视角和计划。将整个组织的背后关切整合到各自的视角和计划中。
* 领导力(Leadership)
  - 推进对齐(Driving alignment)
    + 推进对齐
      * E1  在初步了解组织战略和原则的基础上，在时机恰当时能积极参与相关内容的小组讨论。在初步理解组织目标的基础上，全力投入实现小组目标(目标导向)
      * E2  在了解组织战略和原则的基础上，在时机恰当时能发起一些相关内容的小组讨论。在初步理解组织目标的基础上，全力投入实现团队目标。
      * E3  在理解组织战略和原则的基础上，在时机恰当时能发起一些相关内容的团队讨论，确保团队目标和组织目标对齐。在理解组织目标的基础上，确保团队全力投入实现共同目标。
      * E4  在团队中鼓励目标对齐文化，在理解组织战略和原则的基础上，按需发起一些相关内容的团队讨论，确保团队目标和组织目标的对齐。在理解组织目标的基础上，确保团队全力投入实现团队目标。
      * E5  在多个团队中鼓励目标对齐文化，在理解组织战略和原则的基础上，按需发起一些相关内容的多团队讨论，确保团队目标和组织目标的对齐。在深入理解组织目标的基础上，确保多个团队全力投入实现各自的团队目标。
      * E6  在整个组织内推动目标对齐文化，在深入理解组织战略和原则的基础上，按需发起战略和目标讨论，确保团队目标和组织目标的对齐。确保在整个组织范围内，大家既理解整个组织的大目标，也清楚各自的团队目标。
  - 流程思考
    + 流程思考
      * E1  理解团队所采用的实践和流程。
      * E2  有时能思考团队所采用的实践和流程，并能和团队讨论改进办法。
      * E3  经常能思考团队所采用的实践和流程，并能和团队讨论改进办法。
      * E4  经常能思考团队所采用的实践和流程，并能和团队讨论改进办法。有时能和其他团队合作来改进组织的实践和流程。
      * E5  经常思考对多个团队会产生影响的实践和流程，和相关团队讨论改进办法，并推进落地。经常能和其他团队合作来改进组织的实践和流程。
      * E6  对组织的实践和流程的持续改进总负责。
  - 协调促进(Facilitation)
    + 协调促进
      * E1  N/A(该级别暂无要求)
      * E2  N/A(该级别暂无要求)
      * E3  在团队中协调促进讨论，确保每个人都有机会分享观点和被倾听，并且讨论的结果和会议目标议题紧密关联。鼓励那些不太愿意说话的参与者，同时防止某人全程垄断讨论。
      * E4  同E3
      * E5  在多个团队间协调促进讨论，确保每个人都有机会分享观点和被倾听，并且讨论的结果和会议目标议题紧密关联。确保相关团队都参加讨论。协调讨论向有结果产出的方向推进，协助澄清观点，对于最终讨论结果，确保大家的认同(buy-in)。
      * E6  在整个组织间协调促进讨论，确保每个人都有机会分享观点和被倾听，并且讨论的结果和会议目标议题紧密关联。确保相关团队都参加讨论。协调讨论向有结果产出的方向推进，协助澄清观点，对于最终讨论结果，确保大家的认同(buy-in)。
  - 教导(Mentoring)
    + 教导
      * E1  主动寻找能帮助自己提升工作经验的导师。
      * E2  主动寻找能帮助自己提升工作经验的导师。有时也能以开放灵活、相互尊重和富有同理心的方式去教导其他初级组员。
      * E3  能够以开放灵活、相互尊重和富有同理心的方式去教导其他初级组员。从保持团队技能适度冗余和关键岗位要有候补的角度考虑，主动寻找教导机会。
      * E4  能够以开放灵活、相互尊重和富有同理心的方式去教导其他组员。从保持团队技能适度冗余和关键岗位要有候补的角度考虑，主动寻找教导机会。必要时能够对其他团队的组员进行教导。
      * E5  在多个团队间，能够以开放灵活、相互尊重和富有同理心的方式去教导其他成员。在多个团队间鼓励教导文化，主动为自己和他人寻找教导机会，同时作为导师帮助他人成长。
      * E6  在整个组织中，能够以开放灵活、相互尊重和富有同理心的方式去教导其他成员。鼓励组织级的教导文化，主动为自己和他人寻找教导机会，同时作为导师帮助他人成长。
* 战略性影响(Strategic Impact)
  - 业务敏锐和战略
    + 业务敏锐
      * E1  基本理解团队的领域和整个公司的主营业务。
      * E2  基本理解团队的领域，并且理解团队在整体业务战略中的定位和作用。
      * E3  深入理解团队的领域，并且理解团队在整体业务战略中的定位和作用。对周边团队的业务领域有基本的理解。
      * E4  深入理解团队的领域和战略，以及如何将其映射到公司的总体战略版图。充分理解周边团队的战略，理解自己团队在其他团队战略中的定位/作用和接口点。
      * E5  深入理解多个团队的领域，理解这些团队在公司整体业务战略中的定位和作用。
      * E6  深入理解整个公司的业务，包括每一个领域，理解它们是如何拼装成公司的整体战略版图的。
    + 战略工作
      * E1  N/A(该级别不适用)
      * E2  理解公司的工程技术战略。
      * E3  理解公司的工程技术战略，经常能参与讨论该战略给团队带来的机会和影响。
      * E4  根据公司的工程技术战略，和团队成员+高级工程师协作，讨论并决定本团队的工作重点。有时能参与公司的工程技术战略制定。
      * E5  经常参与战略性的组织决策和计划。领导跨团队战略工作制定，对决策施加影响以确保多团队和公司总体战略目标的对齐。
      * E6  领导战略性的组织决策和计划。经常在战略层次思考和工作，对决策施加影响以确保组织级的战略目标对齐。
    + 产品思维
      * E1  理解团队所产出产品的基本功能。
      * E2  理解团队所专注的产品区，理解它们在总体业务中的定位和作用，有时能提出产品改进建议。
      * E3  充分理解公司的业务模式和当前团队所专注产品区的关系。有时能参与产品团队的路线图制定，并提出反馈意见。寻找机会简化产品和技术设计。
      * E4  和产品团队一起协作评估和开发新产品功能。经常参与产品路线图的制定。通过主动对话来简化产品和技术设计。
      * E5  能够识别新产品机会，以及和竞争对手产品之间的差异点。在多个团队间，经常能根据技术战略和限制来协助细化产品路线图。有时能改变技术战略或限制来定义和创造新产品。
      * E6  在整个组织范围内，和产品/业务方通力协作，积极寻找能够创造新产品或重新定义产品路线图的任何机会。
