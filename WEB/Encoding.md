# 编码

* 字符(Character):人类语言中最小的表义符号。例如’A’、’B’等
* 编码(Encoding):给定一系列字符，对每个字符赋予一个数值，用数值来代表对应的字符。例如，给字符’A’赋予数值0，给字符’B’赋予数值1，则0就是字符’A’的编码
* 字符集(Character Set):给定一系列字符并赋予对应的编码后，所有这些字符和编码对组成的集合。例如，给定字符列表为{‘A’,’B’}时，{‘A’=>0, ‘B’=>1}就是一个字符集
* 字符序(Collation):在同一字符集内字符之间的比较规则
    - 确定字符序后，才能在一个字符集上定义什么是等价的字符，以及字符之间的大小关系
    - 每个字符序唯一对应一种字符集，但一个字符集可以对应多种字符序，其中有一个是默认字符序(Default Collation)；
* 计算机中都是以二进制形式进行存储和运算,用8个比特（bit）作为一个字节（byte），一个字节能表示的最大的整数就是255，如果要表示更大的整数，就必须用更多的字节
* 字符集同时定义了一套同名的字符编码规则,Unicode 就只定义了字符集，而对应的字符编码是 UTF-8，UTF-16。本质上是字符到字节的转换过程
* 字符集是一个系统支持的所有抽象字符的集合。是各种文字和符号的总称，不同的字符集规定了有限个字符
    - 字符集种类
        + ASCII:范围是0-127，其中0-31和127是控制字符，共33个。其余95个，即32-126是可打印字符，包括数字、大小写字母、常用符号等
        + GBK 包含了汉字
        + Unicode 字符集包含了世界上所有的文字符号
* 编码时字符集到数字的映射

## ASCII

* 字符集
    - 0-31和127是控制字符，共33个
    - 其余95个，即32-126是可打印字符：26个字母（大小写）、10个数字、标点符号
* 一个字节可以表示256个字符，所以当前只利用了字节的7位，最高位用来当作奇偶校验
* 字符编码是将这128个字符转换为计算机可识别的二进制数据的一套规则
* EASCII：扩展的ASCII
    - 把第八位也利用起来，那么可表示的字符个数就是 256.比 ASCII 码扩充出来的符号包括表格符号、计算符号、希腊字母和特殊的拉丁符号
    - 国际标准化组织（ISO）及国际电工委员会（IEC）联合制定的一系列8位元字符集的标准，叫 ISO 8859，全称ISO/IEC 8859，它在 ASCII 基础之上扩展而来
    - ISO 8859 字符编码方案所扩展的这128个编码中，只有0xA0~0xFF(十进制为160~255)被使用，其实 ISO 8859是一组字符集的总称，旗下共包含了15个字符集，分别是 ISO 8859-1 ~ ISO 8859-15
        + ISO 8859-1 又称之为 Latin-1，它是西欧语言，其它的分别代表 中欧、南欧、北欧等字符集

![ASCII码](../_static/ascii.jpg)

### GBK

* GB2312：每个汉字符号由两个字节组成，理论上它可以表示65536个字符，不过它只收录了7445个字符，6763个汉字和682个其他字符，同时它能够兼容 ASCII，ASCII 中定义的字符只占用一个字节的空间
* GBK：在 GB2312 的基础上创建了一种叫 GBK 的字符编码，GBK 不仅收录了27484 个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字
    -  利用了 GB2312 中未被使用的编码空间上进行扩充，所以它能完全兼容 GB2312和 ASCII
* GB 18030 是现时最新的字符集，兼容 GB 2312-1980 和 GBK， 共收录汉字70244个，采用多字节编码，每个字符可以有1、2、4个字节组成，某种意义上它能容纳161 万个字符，包含繁体汉字以及日韩汉字，单字节与ASCII兼容，双字节与GBK标准兼容

### Unicode

* 一个囊括了世界上所有字符的字符集，其中每一个字符都对应有唯一的编码值（code point）
* 它不是字符编码，仅仅是字符集而已
* Unicode 字符如何进行编码，可以是 UTF-8、UTF-16、甚至用 GBK 来编码
* 真正存储的时候需要多少个字节是由具体的编码格式决定的。比如：字符 「A」用 UTF-8 的格式编码来存储就只占用1个字节，用 UTF-16 就占用2个字节，而用 UTF-32 存储就占用4个字节
* ASCII编码和Unicode编码的区别
    - ASCII编码是1个字节，而Unicode编码通常是2个字节.乱码问题从此消失了
    - 如果文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算

#### UTF-8：Unicode编码

UTF（ Unicode Transformation Format）编码 和 USC（Universal Coded Character Set） 编码分别是 Unicode 、ISO/IEC 10646 编码体系里面两种编码方式，UCS 分为 UCS-2 和 UCS-4，而 UTF 常见的种类有 UTF-8、UTF-16、UTF-32。

UCS-2 使用两个定长的字节来表示一个字符，UTF-16 也是使用两个字节，不过 UTF-16 是变长的，遇到两个字节没法表示时，会用4个字节来表示，因此 UTF-16 可以看作是在 UCS-2 的基础上扩展而来的。而 UTF-32 与 USC-4 是完全等价的，使用4个字节表示，显然，这种方式浪费的空间比较多。

UTF-8 的优势是：它以单字节为单位用 1~4 个字节来表示一个字符，从首字节就可以判断一个字符的UTF-8编码有几个字节。如果首字节以0开头，肯定是单字节编码，如果以110开头，肯定是双字节编码，如果是1110开头，肯定是三字节编码，以此类推。除了单字节外，多字节UTF-8码的后续字节均以10开头。把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。

- 单字节可编码的 Unicode 范围：\u0000~\u007F（0~127）
- 双字节可编码的 Unicode 范围：\u0080~\u07FF（128~2047）
- 三字节可编码的 Unicode 范围：\u0800~\uFFFF（2048~65535）
- 四字节可编码的 Unicode 范围：\u10000~\u1FFFFF（65536~2097151）

|   字符   | ASCII | Unicode | UTF-8|
|----------|----------|----------|----------|
| A|  01000001 |   00000000 01000001 |  01000001 |
| 中| x |  01001110 00101101 |  11100100 10111000 10101101 |

UTF-8 兼容了 ASCII，在数据传输和存储过程中节省了空间，其二是UTF-8 不需要考虑大小端问题。这两点都是 UTF-16 的劣势。不过对于中文字符，用 UTF-8 就要用3个字节，而 UTF-16 只需2个字节。而UTF-16 的优点是在计算字符串长度，执行索引操作时速度会很快。Java 内部使用 UTF-16 编码方案。而 Python3 使用 UTF-8：Unicode编码

UTF8占用的数据库比GBK大

### utf8mb4

4个字节UTF编码,一个字符最多能有4字节
MySql 5.5 之前，UTF8 编码只支持1-3个字节，只支持BMP( 0000 ~ FFFF )这部分的unicode编码区

#### 大端与小端

大小端是数据在存储器中的存放顺序，大端模式，是指数据的高字节在前，保存在内存的低地址中，与人类的读写法一致，数据的低字节在后，保存在内存的高地址中，小端与之相反，小端模式，是指数据的高字节在后，保存在内存的高地址中，而数据的低字节在前，保存在内存的低地址中

为什么会有大端和小端之分呢？

对于 16 位或者 32 位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节排放的问题，因为不同操作系统读取多字节的顺序不一样，，x86和一般的OS（如windows，FreeBSD,Linux）使用的是小端模式。但比如Mac OS是大端模式。因此就导致了大端存储模式和小端存储模式的存在，两者并没有孰优孰劣。

UTF-8 的编码单元是1个字节，所以就不用考虑字节序问题。而 UTF-16 是用 2个字节来编码 Unicode 字符，编码单位是两个字节，因此需要考虑字节序问题，因为2个字节哪个存高位哪个存低位需要确定。

### python编码

Python的第一个版本一直延续到Python2.7，Python 的默认编码都是 ASCII。所以在 Python 源代码，要能够正常保存中文字符就必须先指定utf-8 或者 gbk 格式

#### 字符vs字节

* 字符就是一个符号，比如一个汉字、一个字母、一个数字、一个标点都可以称为一个字符
* 字节就是字符就是编码之后转换而成的二进制序列，一个字节是8个比特位。例如字符 “p” 存储到硬盘是一串二进制数据 01110000，占用一个字节。
* 字节方便存储和网络传输，而字符用于显示方便阅读。

Python2 中把字符串分为 unicode 和 str 两种类型。本质上 str 类型是二进制字节序列， unicode 类型的字符串是字符。要把 unicode 字符保存到文件或者传输到网络就需要经过编码处理转换成二进制形式的 str 类型，于是 python 的字符串提供了 encode 方法，从 unicode 转换到 str，反之亦然。

Python3 把系统默认编码设置为 UTF-8，字符和二进制字节序列区分得更清晰，分别用 str 和 bytes 表示。文本字符全部用 str 类型表示，str 能表示 Unicode 字符集中所有字符，而二进制字节数据用一种全新的数据类型，用 bytes 来表示，尽管Python2中也有bytes类型，但那只不过是str的一个别名。
在字符引号前加‘b’，明确表示这是一个 bytes 类型的对象，实际上它就是一组二进制字节序列组成的数据，bytes 类型可以是 ASCII范围内的字符和其它十六进制形式的字符数据，但不能用中文等非ASCII字符表示。

bytes 类型提供的操作和 str 一样，支持分片、索引、基本数值运算等操作。但是 str 与 bytes 类型的数据不能执行 + 操作，尽管在python2中是可行的。

### 计算机中的转换

计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码
从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件

### 分隔符

* CRLF(\r\n)分隔

## base64

用64个字符来表示任意二进制数据的方法，可用于在HTTP环境下传递较长的标识信息

* 共包含64个字符。包括大小写拉丁字母各26个、数字10个、加号+和斜杠/，共64个字符。此外还有等号=用来作为后缀用途
* 早期的一些传输协议，例如邮件传输协议SMTP，只能传输可打印的ASCII字符。ASCII中原本的8bit字节码（0-255）就会超出使用范围，从而导致无法传输，利用6bit字符来表达原本的8bit字符
    - 6bit显然不够容纳8bit的数据。6和8的最小公倍数是24，所以我们用4个Base64字符刚好能够表示三个传统的8bit字符。会多1/3的长度
    - 对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit.得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串
    - 待编码的字符串长度不是三的倍数
        + 假设待编码字符串长度为10。这前9个字符可以用12个Base64字符表示
        + 第10个字符的前6bit作为一个Base64字符，剩下的2bit后面需要先补0，补到6位（此处补4个0）作为第二个Base64字符，至于第三个和第四个Base64字符，虽然没有相对应的内容，仍需以=填充。
* 注意
    - 不能用于加密
    - 适用于小段内容的编码，比如数字证书签名、Cookie的内容
    - =用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉
    - 去掉=的解码 加上=把Base64字符串的长度变为4的倍数，就可以正常解码

![字符与索引的对应关系](../_static/base64_string.jpg "Optional title")

## 信息论

* 狗狗狗狗猫猫鱼鸟
    - 狗 0(50%) 猫 10(25%) 鱼 110(12.5%) 鸟 111(12.5%):0表示狗，1就必须空出来,0开头的编码不能用了，只剩下10和11可用，用10表示猫，为了表示"鱼"和"鸟"，必须将11空出来，使用三个二进制位表示
    - 概率越大，所需要的二进制位越少, 根据香农公司  L(x) = log2(1/p(x)) 获取位数
    - H(p) = p(x)log2(1/p(x))  H = 0.5 x 1 + 0.25 x 2 + 0.125 x 3 + 0.125 x 3 = 1.75
* 不均匀分布时，某个词出现的概率越高，编码长度就会越短,如果信息内容存在大量冗余，重复内容越多，可以压缩的余地就越大
* 信息被定义成不确定性的相关概念：概率分布越分散，不确定性越高，信息量越大；反之，信息量越小.
* H（平均编码长度），其实就是信息量的度量。H越大，表示需要的二进制位越多，即可能发生的结果越多，不确定性越高。
* H称为"信息熵"（information entropy）。在物理学里，熵表示无序，越无序的状态，熵越高。
* 一张 480 x 640、16级灰度的图片，需要123万个二进制位（约为 150KB） 480 x 640 x log₂(16) = 1,228,800

## 参考

* [字符编码的前世今生](http://blog.csdn.net/gitchat/article/details/78021539)
