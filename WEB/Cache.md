# 缓存

动静分离，分级缓存，主动失效。

## 模板语法

Mustache、jade、hbs

## 缓存机制

一般会有主动失效和自动失效缓存机制。
* 主动更新一般会用 API 调用方式实现。比如删除 key,或者调用 CDN 接口进行删除操作

缓存穿透：一般会在第一次请求的时候生成缓存，如果服务器端没有缓存，然后在同一时刻出现高并发请求，请求会直接到达业务逻辑部分，很可能导致系统直接挂掉。

* 主动创建缓存。缓存求由系统定时创建。
* 请求的时候设置标志位。第一个请求到达，标识这个 url 正在创建缓存，其他请求进入等待队列。

在 CDN 配置自主源站。意味着请求 CDN 地址的时候，CDN 会去源站请求数据，然后缓存到 CDN 节点。

cname www.localhost.com 到 CDN 提供的空间域名

平台的识别来自 UserAgent，不同的浏览器或者 app，都有不同的UserAgent。不同的来源我们称之为 Origin。Origin + url 就可以生成唯一的 key，去识别唯一的缓存。缓存不限于 redis 和 文件缓存。

## 分类

* 操作系统缓存：减少池畔机械操作
* 数据库缓存：减少文件系统I/O
* 应用程序缓存：减少数据库的查询
* Web服务器缓存：减少应用服务器请求
* 客户端浏览器缓存：减少对网站的访问

## 缓存策略

### 缓存穿透

项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了

可以将这个不存在的key预先设定一个值。比如，”key” , “&&”。在返回这个&&值的时候，我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待继续访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是&&，则可以认为这时候key有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。

### 缓存并发

如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。

对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。

### 缓存失效

并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。

可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，

### DB和缓存一致性

当修改了数据库后，有没有及时修改缓存。这种问题，以前有过实践，修改数据库成功，而修改缓存失败的情况，最主要就是缓存服务器挂了。而因为网络问题引起的没有及时更新，可以通过重试机制来解决。而缓存服务器挂了，请求首先自然也就无法到达，从而直接访问到数据库。那么我们在修改数据库后，无法修改缓存，这时候可以将这条数据放到数据库中，同时启动一个异步任务定时去检测缓存服务器是否连接成功，一旦连接成功则从数据库中按顺序取出修改数据，依次进行缓存最新值的修改。
