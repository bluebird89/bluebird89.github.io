# 缓存

有效的吸收不均匀的请求，抵挡流量波峰

* 分级缓存
* 客户端浏览器缓存：减少对网站的访问
* Web服务器缓存：减少应用服务器请求 模版缓存：动静分离
* 数据库缓存：减少数据库的查询 减少文件系统I/O
* 操作系统缓存：减少池畔机械操作

## 模板语法

* Mustache
* jade
* hbs

## 概念

* 过期时间问题：设计缓存的过期时间需要非常的有技巧，且必须与业务实际情况相结合。
    * 设计过期时间太短了，那会导致缓存效果不佳，且还会造成频繁的从数据库中往缓存里写数据。
    * 如果缓存设计的过期时间太长了，又会导致内存的浪费。
* 命中率问题：这也是设计缓存中需要存放哪些数据的很重要一点，如果设计的不好，可能会导致缓存命中率过低，失去缓存效果。一般对于热点数据而言，要保证命中率达到70%以上效果最佳。
* 穿透/雪崩问题：
    * 穿透：是指如果缓存服务一旦宕机或全部丢失，那么有可能一瞬间所有的流量都直接打到了后端数据库上
        - 可以将这个不存在的key预先设定一个值。比如，”key” , “&&”。
        - 在返回这个&&值的时候，我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待继续访问，还是放弃掉这次操作。
        - 如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是&&，则可以认为这时候key有值了
    * 并发：如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况
        + 对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；
        + 其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。
    * 雪崩：瞬间的请求高峰极有可能导致数据库无法承载。

## 缓存机制

多份数据一致性问题

* 缓存 + 数据库 必须保持一致性:读请求和写请求串行化，串到一个内存队列里去
    - 可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上请求
* Cache Aside
    - 读：先从缓存Cache中读取数据，如果缓存中没有，则从数据库中读取数据，取出数据后放入缓存，同时返回响应
    - 写：先更新数据库，然后再删除缓存
        + 在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值.需要关联与计算
        + 更新缓存的代价有时候是很高的，是否一定要将其对应的缓存更新一份（缓存到底会不会被频繁 冷数据）
        + 删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算
    - 问题
        + A先读 B后更新数据库，B先更新缓存A后更新缓存：不管B是失效缓存还是更新缓存造成数据库与缓存不一致，引起脏数据
        + 删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据：先删除缓存，再修改数据库
        + 删除了缓存，还没来得及修改数据库，一个请求过来，去读缓存，发现缓存空了后去查询数据库，查到了修改前的旧数据，放到了缓存中
            * 每秒并发读很高时，会出现上面情况
* Read/Write Through：将 缓存服务 作为主要的存储，应用的所有读写请求都是直接与缓存服务打交道，而不管最后端的数据库了，数据库的数据由缓存服务来维护和更新
    - 应用要读数据和更新数据都直接访问缓存服务
    - 缓存服务同步的将数据更新到数据库
    - 缺点：出现脏数据的概率就比较低，但是就强依赖缓存了，对缓存服务的稳定性有较大要求，另外，增加新缓存节点时还会有初始状态空数据问题。
* Write Behind：是 Read/Write Through 模式 的一个变种。区别就是 Read/Write Through 模式的缓存写数据库的时候是同步的，而 Write Behind 模式 的缓存操作数据库是异步的
    * 应用要读数据和更新数据都直接访问缓存服务
    * 缓存服务异步的将数据更新到数据库（通过异步任务）
    * 缺点：速度很快，效率会非常高，但是数据的一致性比较差，还可能会有数据的丢失情况，实现逻辑也较为复杂。

## 失效

* 主动失效：用 API 调用方式实现。比如删除 key,或者调用 CDN 接口进行删除操作
* 自动失效：
    - 原有的失效时间基础上增加一个随机值，比如1-5分钟随机，
* 主动创建缓存。缓存求由系统定时创建。
* 请求的时候设置标志位。第一个请求到达，标识这个 url 正在创建缓存，其他请求进入等待队列。

在 CDN 配置自主源站。意味着请求 CDN 地址的时候，CDN 会去源站请求数据，然后缓存到 CDN 节点。

cname www.localhost.com 到 CDN 提供的空间域名

平台的识别来自 UserAgent，不同的浏览器或者 app，都有不同的UserAgent。不同的来源我们称之为 Origin。
Origin + url 就可以生成唯一的 key，去识别唯一的缓存。缓存不限于 redis 和 文件缓存。

### DB和缓存一致性

* 现象：当修改了数据库后，有没有及时修改缓存成功
* 原因：
    缓存服务器挂了。
    因为网络问题引起的没有及时更新，可以通过重试机制来解决。
* 解决：可以将这条数据放到数据库中，同时启动一个异步任务定时去检测缓存服务器是否连接成功，一旦连接成功则从数据库中按顺序取出修改数据，依次进行缓存最新值的修改。
