# 前后端分离

前端html页面通过ajax调用后端的restuful api接口并使用json数据进行交互

* 前端倾向于呈现，着重处理用户体验相关的问题；包括用户在进行业务操作时的流动方向和相关处理；
* 后端则倾处于业务逻辑、数据处理和持久化等，关注的是数据完整、有效、安全。
* 在设计清晰的情况下，后端只需要以数据为中心对业务处理算法负责，并按约定为前端提供 API 接口；而前端使用这些接口对用户体验负责。
* 实现 SOA 架构的 API 可以服务于各种前端，而不仅仅是 Web 前端，可以做到一套服务，各端使用
* 对于前端来说，不依赖后端技术的前端部分可以独立部署，也可以应于 Hybrid 架构，嵌入各种“壳”（比如 Electron、Codorva 等），迅速实现多终端。

数据和页面剥离：技术栈的隔离

* 分工颗粒度更细
* 前端采用静态网页相关的技术，HTML + CSS + JavaScript，通过 AJAX 技术调用后端提供的业务接口。负责 View 和 Controller 层
* 前后端协商好接口方式通过 HTTP 提供，统一使用 POST 谓词。负责 Model 层
* 接口数据结构使用 JSON 实现，形式使用REST

![前后分离式 Web 架构示意](../static/fbs.png "前后分离式 Web 架构示意")

* 最上端是服务端，就是我们常说的后端。后端对于我们来说，就是一个接口的集合，服务端提供各种各样的接口供我们使用。因为有 Node.js 层，也不用局限是什么形式的服务。对于后端开发来说，他们只用关心业务代码的接口实现。
* 服务端下面是 Node.js 应用。
* Node.js 应用中有一层 Model Proxy 与服务端进行通讯。这一层主要目前是抹平我们对不同接口的调用方式，封装一些 View 层需要的 Model。
* Node.js 层还能轻松实现原来 vmcommon, tms（引用淘宝内容管理系统）等需求。
* Node.js 层要使用什么框架由开发者自己决定。不过推荐使用 Express + XTemplate 的组合，XTemplate 能做到前后端公用。
* 怎么用 Node.js 大家自己决定，但是令人兴奋的是，我们终于可以使用 Node.js 轻松实现我们想要的输出方式： JSON/JSONP/RESTful/HTML/BigPipe/Comet/Socket/同步、异步，想怎么整就怎么整，完全根据你的场景决定。
* 浏览器层在我们这个架构中没有变化，也不希望因为引入 Node.js 改变你以前在浏览器中开发的认知。
* 引入 Node.js，只是把本该就前端控制的部分交由前端掌控。

![淘宝基于 Node.js 的前后端分离分层](../static/taobao.jpg "淘宝基于 Node.js 的前后端分离分层")

## 实现

* 统一认识
* 划分边界，确定流程：梳理清楚开发流程，及相应的角色职责
* 有指定的文档输出及相应的评审
* 项目管理
    - 第一个核心任务就是讨论出最小的工程子集，目标是可以跑通所有的流程及相应的技术框架。
    - 从 0 到 0.1 的过程中的实现
    - 进度管理：
        + 前端：可以基于 Mock 接口的方式，搭建模拟后端环境，分成三个阶段
            * 按页面划分，快速出所有的页面 只考虑量，不考虑质，以基本跑通所有的 Mock 接口为标准。 这里更多的考虑在于，前端接触新的框架，会积累很多问题，包括 CSS 之类的，包括接口调用之类的，这些问题都有共通性，可以在下一次迭代的时候，总结出问题，分不同的人去解决。
            * 基于所有的页面进行迭代 划分不同的人去解决团队积累下来的问题，并统一修复。可以尝试抽出一些共性的组件
            * 通过了mock来提供一些假数据，我们先规定好了API接口，设计出了一套API文档，然后我们就可以通过API文档，利用mock(http://mockjs.com)来返回一些假数据，这样就可以模拟发送API到接受响应的整一个过程，
            * 分批接入后端的模块接口 到这个阶段的时候，后端的接口理论上 QA 根据模块，已经验收了一部分了，可以开始分批接入，并最终提交给 QA 进行功能上的测试
        + 后端
            * 按模块切分开发，接口分批提交验收。
            * 后端可以基于业务来切分子模块，然后，各个模块并行开发
        + 测试
            * 分批次验收后端的模块接口 在没有页面的前提下，使用工具，参考集成测试用例，对接口的健壮性，可靠性进行详细验证，保证在前端页面开始接入接口的时候，接口是稳定可靠的。
            * 分批次验收前端的功能页面 基于功能测试用例，进行页面级别上的功能回归
            * 整合前后端的 BUG 信息 前后端的 BUG 信息全部是反馈给 QA，由 QA 统一去追相应的技术人员。 比如说前端发现有个接口有问题，只反馈给 QA，剩下的工作就是由 QA 去找相应的后端负责人。
* 需要的是耐心及专注。团队的技术成长都是有节奏的，是没有办法一步到位的。

### 增加一层nodejs

让前端能控制 Controller 层

* 有了 Node.js 之后，前端可以在 Node.js 中去代理这 5 个异步请求，还能很容易的做 Bigpipe，这块的优化能让整个渲染效率提升很多。在无线端，在客户手机上建立一个 HTTP 请求开销很大，有了这个优化，性能一下提升好几倍。
* 前端能够在本地运行服务程序、开发、调试
- 跨域的问题，无法发出ajax请求的(浏览器跨域的限制)，需要本地服务器。http-proxy-middleware插件
* nodejs本身有着独特的异步、非阻塞I/O的特点，这也就意味着他特别适合I/O密集型操作，在处理并发量比较大的请求上能力比较强，因此，利用它来充当前端服务器，向客户端提供静态文件以及响应客户端的请求
    - 前端资源部署到Node Server中
    + 根据请求类型从后端服务器上通过RPC服务请求页面的模板数据，然后进行页面的组装和渲染；
    - Node Server还实现了一层数据代理服务，负责与提供数据的后端服务进行通信。API请求则直接转发到后端服务器，完成响应。

## 职责

用户体验和业务处理的解耦

* 前端可以根据用户不同时期的体验需求迅速改版，后端对此毫无压力
    - 主导者应该是架构师或者设计师：他们的主要技术栈会极大的影响前后端在整个项目中的主次作用
    - 前端接触的到角色会比后端更多，前端可以成为项目沟通的中心，所以比后端更合适承担主导的角色。
        + 项目/产品经理或客户的直接影响
        + 美工对接
        + 后端对接
    - 前端服务器
        - 作为静态文件服务器，当用户访问网站的时候，将index.html以及其引入的js、css、fonts以及图片返回给用户
            + 将开发完的前端代码，利用webpack打包成静态压缩文件
            + 在服务器上，利用pm2负载均衡器来执行以下的代码来开启服务器
        - 负责将客户端发来的ajax请求转发给后台服务器
* 后端进行的业务逻辑升级，数据持久方案变更，只要不影响到接口，前端可以毫不知情。当然如果需求变更引起接口变化的时候，前后端又需要坐在一起同步信息了。
    - 接口设计：粒度的大小往往代表了前后端工作量的大小
        + 接口粒度太小，前端要处理的事情就多，尤其是对各种异步处理就可能会感到应接不暇；
        + 粒度太大，就会出现高耦合，降低灵活性和扩展性，当然这种情况下后端的工作就轻松不了。
    - 在输入参数和输出结果上，最好一开始就有相对固定的定义，这往往取决于前端架构或采用的 UI 框架
        + 参数的数据形式
            * 键值对，用于 URL 中的 QueryString 或者 POST 等方法的 Payload
            * XML/JSON/…，通常用于 POST 等方法的 Payload，也可以使用 multipart 传递
            * ROUTE，由后端路由解析 URL 取得，在 RESTful 中常用
        + 完整的响应至少需要包含状态码、消息、数据三个部分的内容：
            * 状态码，HTTP 状态码或响应数据中特定的状态属性，0 表示 API 调用成功，非0 表示调用失败，其中 1 表示需要登录、2 表示未获取授权
            * 消息，通常是放在响应内容中，作为数据的一部分
            * 数据，根据接口协议，可能是各种格式，当前最流行的是 JSON
* 用户认证：使用基于 Token 和 OAuth 或者 JWT
    - 基于 Cookie/Session 的认证方案
        + 前端部分和后端部分同源：可以直接迁移过来
        + 不同源：使用与 Cookie 无关的方案
    - OAuth 的认证方案：要注意的是首次认证不是使用已注册的 AppID 和 AppToken，而是使用用户名和密码。
    - 基于 Token/JWT 的认证方案：JWT 是相对较为成熟，也得到多数人认可的一种。从 jwt.io 上可以找到各种技术栈的 JWT 实现，应用起来也比较方便。

```js
var express = require('express')
var proxy = require('http-proxy-middleware')
var app = express()

app.use('/api', proxy({
  target: 'http://119.29.163.132:48403',
  changeOrigin: true,
  pathRewrite: {
    '^/api': ''
  }
}))
app.use(express.static('dist'))

app.get('*', function (req, res) {
  res.sendfile('./dist/index.html')
})

app.listen(80, function () {
  console.log('连接成功')
})
```

### 文档

* 接口契约文档 用于定义前端与后端之间的接口定义
    - 责任方: 前端团队 第一个版本的接口契约定义，一定是前端团队出的。 是的，你没有看错，后端团队并不适合出接口的定义，因为前端团队的思维方式是 基于页面交互 来考虑的，后端团队的思维方式是 基于结构化实体 来考虑的。
    - 评审方：后端团队，测试 QA，产品经理
* 集成测试用例文档 用于定义验收接口的用例
    *责任方: 测试 QA 团队
    *评审方: 后端团队，产品经理
* 功能测试用例文档 用于定义验收页面功能的用例
    - 评审方: 前端团队，产品经理
    - 责任方: 测试 QA 团队
* 单元测试用例文档 用于定义后端各个功能模块的单元用例
    - 评审方: 后端团队，产品经理
    - 责任方: 后端团队

### 测试

* 前端的测试将以用户体验测试和集成测试为主
    - 用例可以只关注前端体验性的问题
* 后端则主要是进行单元测试和 Web API 接口测试
    - 永远不要相信前端
    - 后端必须保证数据的安全性和有效性，前后端都要做数据有效性验证，那一定要严格按照文档来进行，不然很容易出现前后端数据验证不一致的情况
* 流程
    - 提交接口测试
    - 后端接口对接
    - 提交功能测试

## 缺点

* 业务处理的设计谁来主导
* Cookie/Session 的方式虽然可用，但并不是特别合适，相对来说，基于 Token 的认证则更适合一些。采用基于 Token 的认证就意味着后端的认证部分需要重写

## 部署

前后端不同端口
后端允许跨域

## 服务端渲染

[前端性能优化之加载技术](https://juejin.im/post/59b73ef75188253db70acdb5)

[SSR VR CSR](https://medium.com/walmartlabs/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8) 什么是服务端渲染

服务端渲染也称作 SSR(Server Side Render) 。不同于客户端渲染，服务端渲染会在后端把页面 DOM 的结构树转成 String 吐出来，然后到前端（如浏览器）解析渲染。

优势

SEO

现在单页面应用由于体验好，广泛流行。但单页应用的做法往往是后端只吐出一个页面的框架，里面没有具体内容，然后前端通过 Ajax 动态拉取内容。这就导致爬虫去访问你的站点时，服务端返回给爬虫的只有一个架子，爬虫无法抓取页面关键词之类等信息。

首屏直出

意思很好理解，就是在用户首次访问的时候不用再看到菊花在那里转呀转 (Loading...) ，首屏就可以看到页面所有内容。另外可以在服务端通过 HTTP 接口合并请求等方式，让页面打开的首屏时间缩短。

Node 服务端渲染有什么特别？

同构（isomorphic）！我想这个应该是用 Node 做服务端渲染最大的优势。那么什么是同构呢？

其实同构大多是由 isomorphic 单词翻译来的，这个单词含义比较难理解，现在也有很多叫做 universal app。意思差不多，就是说能够实现一套代码在服务端跟客户端同时运行。

假如我们客户端的页面是 React 写的，那么这套代码也能在服务端运行，并进行渲染，这就是同构的概念。同一份代码，运行构建于两端。因为都是 javascript 语法，所以用 Node 做服务器渲染在这方面有天生的优势。

用 Node 做同构有什么难点？

运行环境支持

现在的前端开发，大多数用的是 ES6/7 的语法，然后用 Babel 编译成 ES5/3 后让浏览器运行。 Node 对 ES6/7 的支持并不是十分友好，就算是最新版本的 node，也不还是不支持 ES Module （就是我们常看到的 import 语法引入模块）。所以要达到同一份代码两端运行的目的，就必须磨平运行环境的差异。

那么该如何做呢？答案就是 babel-register。

babel-register 模块会改写 require 命令，为它加上一个钩子。此后，每当使用 require 加载 .js 、 .jsx 、 .es 和 .es6 后缀名的文件，就会先用 Babel 进行转码。当然，这就要求你必须在你服务端入口文件的顶部率先加载这个模块。

资源加载

如果说磨平环境差异还不算困难，那让 Node 支持多种资源类型加载估计是要让你头皮发麻了。 比如说我们现在用 react 开发 app ，app 中必然涉及到 css/scss 、 png/jpg 、 font 等文件的加载吧？我们一般是通过webpack的loader来处理的，那这段代码运行在服务端会怎么样？必然是血崩。。。

node require 默认就只支持加载 .json .js 等几种文件，所以如何保证客户端渲染出来的代码跟服务端渲染出来的代码一致呢（在 react 应用中，react 会检查客户端渲染出来的结构是否跟客户端渲染出来的一致，如果不一致的话，会在客户端重渲染）？这里提供两套思路：

客户端跟服务端用同一套 webpack 打包后的资源。webpack-isomorphic-tools 可以很好的解决这个问题，或者最新的 webpack 版本 target: node 也能实现。

png/jpg/font 等文件直接忽略（在 babel-register 里可以设置），scss/css的话，用 css in js 的方式写。

总结

Node服务端渲染好处多多，但除了上述技术性的问题需要解决外，仍然有些线上问题需要注意。

首当其冲的就是服务器 cpu 过高问题，因为现在页面结构是在服务端以 renderToString 的方式输出，所以页面请求路由会涉及到大量的计算。这就会导致如果页面并发高一点的话，会出现 cpu 过高的问题。

另外在服务端可没有什么 window 、 document 对象，这些东西也需要去 hook 掉；在 React 应用中，componentDidMount 等生命周期函数也不会在服务端触发；定时器记得及时释放，否则可能会导致内存泄露的风险！

如果你确定要用 node 做服务端渲染的话，建议你应该用一些开源成熟的框架。比如在 react 体系下比较有代表性的 next.js， vue 体系下的 Nuxt.js。

## 工具

* [airbnb/hypernova](https://github.com/airbnb/hypernova):A service for server-side rendering your JavaScript views
