# Architect 架构

* 所解决问题的复杂度决定了技术实力高度。技术人不应仅仅满足于每天去实现业务逻辑细节，还要能从更高层面去设计和构建企业的技术架构
* 技术为业务服务，开发的更多的是应用系统或者称之为业务系统，业务的不同特点决定了应用（业务）架构也必然有不同的特点
* 不同特点单纯靠技术肯定解决不了，应用架构设计的一条重要原则是 **技术中立**，更多时候要从应用角度而不是技术角度去考虑问题
  - 容易的在于不需过多关注技术实现
  - 难的在于必须根据实际业务场景和业务需要及时间、成本、资源等给出当下最合适、一定不是最完美的架构方案
* 所有大型互联网系统初期一定不是设计成现在这个样子的，都是伴随着业务从小到大、从少到多、从简单到复杂的过程演进而来，架构的演进过程也见证了业务的发展历程
* 应用架构（业务系统）对技术追求要有所止境，当 DB 瓶颈解决不了时换个思路，来个排队系统和预约系统，技术难度就降低了很多；分布式事务解决不了，那就做好回滚、补偿、对账这些基础工作。多从应用架构的角度去思考解决方案
* 宏观系统架构中很多设计来源于微观东西
  - 云计算中的很多虚拟化技术的原理，和传统的虚拟内存不是很像么
  - Unix下的那些I/O模型，也放大到了架构里的同步异步的模型
  - Unix发明的管道不就是数据流式计算架构吗
  - TCP的好些设计也用在不同系统间的通讯中
  - 要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透

## 定义

* 软件架构（software architecture）是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。把架构当成一个技能、工种、职位、岗位，核心还是为了应对软件设计、构建中的复杂度，降低成本、提升效率
* 事中业务：常见业务系统。如：电商、交易系统等等大多属于这类。实际业务中，对业务反馈需要越实时，实现难度相对越高，比如：共享单车 app、股票交易等，需要实时的提示、预警、交互。除了传统型业务型架构外，对大数据流计算架构要求逐步提高
* 事后业务：事后肯定有数据沉淀，有数据肯定可以对未来决策做指导。自然而然查询统计、报表决策、数据挖掘、事后总结等数据应用类系统
* 事前业务：事前基本为业务预测、分类、推荐、决策辅助等业务。随着机器学习、深度学习的火热，这部分应用越来越广泛。例如：量化投资、广告点击率预测、短视频推荐、电商推荐等
* 目的
  - 业务复杂、数据量、用户数引起复杂度
* 需求
  - 高并发
  - 高性能
  - 高可用
  - 安全性
  - 规模扩展性
  - 规模成本

## [特质](https://insights.thoughtworks.cn/the-well-rounded-architect/)

* 技术领导者
  - 并不一定要告诉开发人员做什么。相反，好的架构师就像一个导师，能够带领开发团队向同一个技术愿景前进
  - 会借助于讲故事、影响力、引导冲突、构建信任等领导技能，将他们的架构愿景变成现实
  - 同时也是一个好的架构师。他/她会仔细听取每个参与者的意见，通过与团队的反馈互动调整他们的愿景
* 开发人员
  - 一个良好的架构选择需要权衡理想的架构状态与软件系统的当前状态,如果不考虑技术选型与问题域之间的匹配度，那么会很容易受到各种技术的诱惑——这也就是常见的“象牙塔式架构师”行为模式
  - 缓解这种情况的最佳方式是让架构师多与开发人员待在一起，花一些时间在代码上。了解系统的构建方式及系统的约束，这将帮助架构师在当下环境做出正确的选择
* 聚焦系统
* 具备企业家思维
* 具备权衡策略思维与战术思维
* 能够进行良好的沟通

## 演进之路

* 单机架构:单体数据库->用户超过 100 万，日访问量超过 20 万，峰值并发 2 万，而数据库的表会趋近于亿级的量。撑不住的
* Tomcat与数据库分开部署
* 引入本地缓存(memcached)和分布式缓存(Redis)
* 引入反向代理实现负载均衡
* 数据库读写分离
* 数据库按业务分库:一个大库拆成若干小库，保持数据库对象都一致，这样每个小库分摊掉一部分流量，->一系列的事情来满足和留住用户。比如促销、打折、团购等等。会大量查询他们的数据，带来的是读请求远远大于写入请求
    + 通过中间件
    + 现在的硬件服务 4000 个并发，对于不复杂的商用没有问题。具体能负责多少看系统上线后的 baseline （基线）监测，这里我们假定 4000 并发。所以分成 5 个相同的库，来做分库。这样同时写入 4000 并发够用。
    + 分库路由：依据地理位置分成 5 个库，根据用户身份证哈希成 5 个散列值，分别对应了这 5 台数据库，用户就被分流了。
    + 读请求耗尽服务器的 CPU\IO\Network 资源
* 把大表拆分为小表(垂直分表)
* 使用LVS或F5来使多个Nginx负载均衡
* 通过DNS轮询实现机房间的负载均衡
* 引入NoSQL数据库和搜索引擎等技术
* 大应用拆分为小应用
* 复用的功能抽离成微服务
* 引入企业服务总线ESB屏蔽服务接口的访问差异
* 引入容器化技术实现运行环境隔离与动态服务管理
* 以云平台承载系统

## 设计

* 在时间、安全、稳定、性能等方面做权衡，同时注意控制复杂度
  - 权衡需要宽阔视野、良好沟通能力、多样化价值观，不能钻牛角尖，要能妥协而且懂得如何妥协
  - 控制复杂度的很大一部分工作则是合理划分责任：事情还是那些事情，切成多少个部分，每个部分放在哪里，怎么实现，怎么组合。这工作有时候看起来像拼图一样简单，其实需要之前修炼的经验和眼光才能决策，而架构设计的水平高下，往往就存在于那些拼图方案之中
* N+1设计｜冗余设计：系统中的每个组件都应做到没有单点故障，对服务、数据库的做结点冗余，保证服务的高可用。通过数据库主从模式、应用集群来实现
* 回滚设计：确保系统可以向前兼容，在系统升级时应能有办法回滚版本，对于任何业务尤其是关键业务，都具有恢复机制。可以使用基于日志的WAL、基于事件的Event sourcing等来实现可回滚
* 可禁用/自我保护：应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能。具有限流机制，当上游的流量超过自身的负载能力时，能够拒绝溢出的请求。可以通过手动开关或者自动开关（监测异常流量行为），在应用前端挡住流量
* 监控设计：在设计阶段就要考虑监控的手段，可监控是保障系统能够稳定运行的关键。包括对业务逻辑的监控、应用进程的监控以及应用依赖的CPU、硬盘等系统资源的监控。每一个系统都需要做好这几个层面的监控
  - 问题可追踪：当系统出现问题时，能够定位请求的轨迹、每一步的请求信息等。分布式链路追踪系统即解决的此方面的问题
* 多活数据中心设计：若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用，为了容灾，从根本上保障应用的高可用性。需要构建多活的数据中心，以防止一个数据中心由于不可控因素出现故障后，引起整个系统的不可用
* 采用成熟技术：刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难，使用市面上主流、成熟、文档、支持资源多的技术，选择合适的而非最火的技术实现系统
* 资源隔离设计：应避免单一业务占用全部资源
* 故障隔离：将系统依赖的资源(线程、CPU)和服务隔离开来能够使得某个服务的故障不会影响其他服务的调用。通过线程池或者分散部署结点可以对故障进行隔离
* 架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题
* 非核心则购买：非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品
* 使用商用硬件：商用硬件能有效降低硬件故障的机率
* 快速迭代：系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险
* 无状态设计：服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态，API、接口等的设计不能有前后依赖关系，一个资源不受其他资源改动的影响。无状态的系统才能更好地进行扩展。如果非得有状态，则要么客户端管理状态，要么服务端用分布式缓存管理状态
  - 尽量减少共享状态:在一个对象中，相对于成员变量，更应该优先选择静态的无状态变量
* 避免过度设计：最简单的方案最容易实现和维护，也可以避免浪费资源。但方案中需要包括扩展

* 梯级存储：内存->SSD硬盘->传统硬盘->磁带，可以根据数据的重要性和生命周期对数据进行分级存储
* 缓存设计：隔离请求与后端逻辑、存储，是就近原则的一种机制。包括客户端缓存（预先下发资源）、Nginx缓存、本地缓存以及分布式缓存
* 异步设计：对于调用方不关注结果或者允许结果延时返回的接口，采用队列进行异步响应能够很大程度提高系统性能；调用其他服务的时候不去等待服务方返回结果直接返回，同样能够提升系统响应性能。异步队列也是解决分布式事务的常用手段
* 前瞻性设计：根据行业经验和预判，提前把可扩展性、后向兼容性设计好
* 水平扩展：相比起垂直扩展，能够通过堆机器解决问题是最优先考虑的问题，系统的负载能力也才能接近无限扩展。此外，基于云计算技术根据系统的负载自动调整容量能够在节省成本的同时保证服务的可用性
* 小步构建和发布：快速迭代项目，快速试错。不能有跨度时间过长的项目规划
* 自动化：打包、测试的自动化称为持续集成，部署的自动化称为持续部署。自动化机制是快速迭代和试错的基础保证
* 将“副作用(例如：打印到控制台、日志记录、更改全局状态、文件系统操作等)”局部化
* 架构关注点
  - 内聚与耦合、功能性、可变性、性能、容量
  - 生态系统、模块化、可构建性、产品化、安全性
  - 架构原则：分而治之
* 架构演进
  - 项目需求扩张，旧的架构不适应新的需求
  - 开发团队人员增加，协作要求变高
  - 新技术引入
  - 更高的软件质量要求
* 基本原则
  - KISS(Keep it simple,sutpid) ：保持每件事情都尽可能的简单。用最简单的解决方案来解决问题。Guide：简单即是复杂！拿你的代码来说，你想要写的简单且容易理解的话，你就需要花更多的时间去思考
  - YAGNI(You aren’t gonna need it)：不要去搞一些不需要的东西，需要的时候再搞吧。之前的时候，总是臆想觉得某个功能以后可能会用到，然后就顺手把它实现了，实际到了后面并没用上，反而造成了代码冗余
  - 爬，走，跑。换句话说就是先保证跑通，然后再优化变得更好，然后继续优化让其变得伟大。迭代着去做事情，敏捷开发的思路。对于每个功能点，创建里程碑（最大两周），然后去迭代
  - 创建稳定、高质量的产品的唯一方法就是自动化测试。所有的都可以自动化，当你设计时，不妨想想这一点。Guide：单侧还是很有必要的，但是没有一个恒定的标准说你应该怎么去做
  - 时刻要想投入产出比（ROI）。就是划得来不
  - 单一职责原则
  - 了解用户，然后基于此来平衡你需要做哪些事情。不要花了几个月时间做了一个 devops 用户界面，最后你发现那些人只喜欢命令行。此原则是原则 5 的一个具体表现。Guide:是否有站在用户的角度思考问题呢？是否是为了用新技术而用新技术？
  - 设计和测试一个功能，尽可能独立。当做设计时，应该想想这一条。从长远来看这能给你解决很多问题，否则功能只能等待系统其他所有的功能都就绪了才能测试，这显然很不好。有了这个原则， 你的版本将会更加的顺畅
  - 不要搞花哨的。我们都喜欢高端炫酷的设计。最后搞了很多功能和解决方案到架构中，然后这些东西根本不会被用到。Guide:简单点！说话的方式简单点！
* 功能选择
  - 原则 9：不可能预测到用户将会如何使用我们的产品。所以要拥抱 MVP（Minimal Viable Product），最小可运行版本。这个观点主要思想就是你挑几个很少的使用场景，然后把它搞出来，然后发布上线让用户使用，然后基于体验和用户反馈再决定下一步要做什么
  - 原则10：尽可能的做较少的功能。当有疑问的时候，就不要去做，甚至干掉。很多功能从来不会被使用。最多留个扩展点就够了
  - 原则 11：等到有人提出再说（除非是影响核心流程，否则就等到需要的时候再去做）
  - 原则 12：有时候你要有勇气和客户说不。这时候你需要找到一个更好的解决方案来去解决。记住亨利福特曾经说过的 ：”如果我问人们他们需要什么，他们会说我需要一匹速度更快的马”。记住：你是那个专家，你要去引导和领导。要去做正确的事情，而不是流行的事情。最终用户会感谢你为他们提供了汽车
* 服务端设计和并发
  - 原则 13：要知道一个 server 是如何运行的，从硬件到操作系统，直到编程语言。优化 IO 调用的数量是你通往最好架构的首选之路
  - 原则 14：要了解 Amdhal 同步定律。在线程之间共享可变数据会让你的程序变慢。只在必要的时候才去使用并发的数据结构，只在必须使用同步（synchronization）的时候才去使用同步。如果要用锁，也要确保尽可能少的时间去 hold 住锁。如果要在加锁后做一些事情，要确保自己在锁内会做哪些事情
  - 原则 15：如果你的设计是一个无阻塞且事件驱动的架构，那么千万不要阻塞线程或者在这些线程中做一些 IO 操作，如果你做了，你的系统会慢的像骡子一样
* 分布式系统
  - 原则 16：无状态的系统的是可扩展的和直接的。任何时候都要考虑这一点，不要搞个不可扩展的，有状态的东东出来，这是起码的。
  - 原则 17：保证消息只被传递一次，不管失败，这很难，除非你要在客户端和服务端都做控制。试着让你的系统更轻便（使用原则 18）。你要知道大部分的承诺 exactly-once-delivery 的系统都是做了精简的
  - 原则 18：实现一个操作尽可能的幂等。这样的话就比较好恢复，而且你还处于至少一次传递（at least once delivery）的状态
  - 原则 19：知道 CAP 理论。可扩展的事务（分布式事务）是很难的。如果可能的的话，尽可能的使用补偿机制。RDBMS 事务是无法扩展的
  - 原则 20：分布式一致性无法扩展，也无法进行组通信，也无法进行集群范围内的可靠通信。理想情况下最大的节点限制为 8 个节点
  - 原则 21：在分布式系统中，你永远无法避免延迟和失败
* 用户体验
  - 原则 22：要了解你的用户和清楚他们的目标。他们是新手、专家还是偶然的用户？他们了解计算机科学的程度。极客喜欢扩展点，开发者喜欢示例和脚本，而普通人则喜欢 UI
  - 原则 23：最好的产品是不需要产品手册的。Guide：这个是说产品易用。很多人觉得敏捷开发下不需要文档，实际上，一个系统即是在敏捷开发的情况下，有些必要的文档比如重
  - 原则 24：无法在两个选择中做决定的时候，请不要直接把这个问题通过提供配置选项的方式传递给用户。这样只能让用户更加的发懵。如果连专家都无法选择的情况下，交给一个比你了解的还少的人这样合适吗？最好的做法的是每次都找到一个可行的选项；次好的做法是自动的给出选项，第三好的做法是增加一个配置参数，然后设置一个合理的默认值
  - 原则 25：总是要为配置设置一个合理的默认值
  - 原则 26：设计不良的配置会造成一些困扰。应该总是为配置提供一些示例值
  - 原则 27：配置值必须是用户能够理解和直接填写的。比如：不能让用户填写最大缓存条目的数量，而是应该让用户填写可被用于缓存的最大内存
  - 原则 28：如果输入了未知的配置要抛出错误。永远不要悄悄的忽略。悄悄的忽略配置错误往往是找 bug 花了数小时的罪魁祸首
* 艰难的问题
  - 原则 29：梦想着新的编程语言就会变得简单和明了，但往往要想真正掌握会很难。不要轻易的去换编程语言
  - 原则 30：复杂的拖拉拽的界面是艰难的，不要去尝试这样的效果，除非你准备好了 10 人年的团队

## 原则

### KISS Keep It Simple and Stupid

* 考虑逻辑复杂度、实现难度、代码的可读性
* 工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响
* 本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。
* 原则
  - 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。
  - 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。
  - 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。

### YAGNI You Ain’t Gonna Need It

* 只考虑和设计必须的功能，避免过度设计
* 需不需要做的问题

### DRY Don’t Repeat Yourself

* 逻辑重复的应该合并
* 语义不重复：从代码实现逻辑上看起来是重复的，从功能上来看，两个函数干的是完全不重复的两件事情
* 执行重复的应该合并

### Composition over inheritance（喜欢组合而不是继承）

* 继承为实现不同功能，通过不断继承的方法赵成继承层次过深、继承关系过于复杂，会影响到代码的可读性和可维护性
  - 依赖于抽象类来定义行为，导致过于复杂的继承关系，而通过接口定义行为能够有效地分离行为与实现
* 通过组合、接口、委托三个技术手段可以替换掉继承,代码复用可以通过组合和委托来实现
* 组合可以通过注入实现
* 判断
  - 继承改写成组合意味着要做更细粒度的类的拆分
  - 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，就可以大胆地使用继承
  - 系统越不稳定，继承层次很深，继承关系复杂，就尽量使用组合来替代继承。

```
public interface Flyable {
    void fly()；
}
public class FlyAbility implements Flyable {
    @Override public void fly() {
        //...
    }
}

public class Ostrich implements Tweetable, EggLayable {//鸵鸟
    private TweetAbility tweetAbility = new TweetAbility(); //组合

    @Override
    public void tweet() {
        tweetAbility.tweet(); // 委托
    }
```

### Command-Query Separation (CQS) – 命令-查询分离原则


### Hollywood Principle – 好莱坞原则
### High Cohesion & Low/Loose coupling & – 高内聚， 低耦合
### Convention over Configuration（CoC）– 惯例优于配置原则
### Separation of Concerns (SoC) – 关注点分离
### Design by Contract (DbC) – 契约式设技

## [SOLID](https://mp.weixin.qq.com/s/JOVSkcC48qwoaByxUtgcFA)

* 单一职责原则 Single Responsibility Principle SRP
  - There should never be more than one reason for a class to change.
  - 类只承担单一职责,尽可能地降低类变更可能性，不同职责分开单独定义
  - 不仅仅适用于类，还适用于接口以及方法的设计
  - 让一个类只处理一组相关的事情，控制了它的变化方向，后期也能更好的定位。如果引发变化的因素很多，会导致类的职责过多，难以维护
* 开闭原则 Open-Closed Principle OCP
  - Softeware entities like classes,modules and functions should be open for extension but closed for modifications.
  - 一个软件实体如类、模块和函数，应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。比如参数类型、引用对象尽量使用接口或者抽象类，而不是具体实现类
  - 对修改关闭，对扩展开放。建议为你的服务调用者提供一个他需要的抽象、高层次的行为接口，后期你的服务有新的种类，你只需要新增一个实现该抽象、高层次接口具体服务，而不需要修改调用者的使用方式。
* 依赖倒转原则 Dependence Inversion Principle DIP
  - High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.
  - 高层模块不应该依赖低层模块，一旦低层模块发生变化，将引起高层模块不必要的改变，同时高层模块之上可能有更高层模块存在，因此两者都应该依赖于抽象
  - 抽象不依赖具体实现细节，而让具体实现细节依赖抽象。抽象不变，具体实现细节改变可以使影响最小化，也就是要针对接口编程
  - 使用者依赖一个抽象的服务接口，而不是去依赖一个具体的服务执行者，从依赖具体实现转向到依赖抽象接口，倒置过来。
* 里氏代换原则 Liskov Substitution Principle LSP
  - Functions that use pointers or referrnces to base classes must be able to use objects of derived classes without knowing it.
  - 任何基类可以出现的地方，透明地使用其子类的对象，且必须遵从基类所有规则定义
  - 反过来说，除了扩展基类，又为什么要违背基类规则定义呢？这一条与开关原则结合起来理解就是，基类遵循关原则，子类遵循开原则，子类必须满足LSP才允许继承，否则就断开这种继承关系
  - 为了尽可能地减少修改以及修改带来的安全隐患
  - 对使用者来说，能够使用父类的地方，一定可以使用其子类，并且预期结果是一致的。
* 接口隔离原则 Interface Segregation Principle ISP
  - Clients should not be forced to depend upon interfaces that they don't use.The dependcy of one class to another one should depend on the smallest possible interface.
  - 使用多个隔离接口，比使用单个接口要好，也有利于降低类之间的耦合度。类间的依赖关系要建立在最小接口之上，要防止类必须实现接口中对于自己来说无用的方法情形的出现；
  - 一个接口中所有方法都是围绕一个职责，但是这个接口仍可能不符合接口隔离原则
  - 提倡不要将一个大而全的接口扔给使用者，而是将每个使用者关注的接口进行隔离。
* 迪米特法则 Law of Demeter|最少知识原则 Least Knowledge Principle LoD|LKP
  - Only talk to your immedate friends.
  - 一个模块或子系统应当尽量少地与其他模块或子系统之间发生直接相互作用，可以通过增加“即时朋友”这个中间人来中转通信，只与“朋友”保持联系，与“陌生人”概不谋面，当模块或子系统出现版本升级更新或环境移植之后，只要朋友不变就好
  - 只和自己直接朋友交流：出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友
  - 不要将依赖类以局部变量的形式在类中使用
  - 依赖类尽可能少地公布公有方法
  - 如果一个方法放在本类中，既不增加类间关系，也不对本类产生负面影响，那就放置在本类中
* 合成/聚合复用原则 Composite/Aggregate ReusePrinciple ，CARP
  - 在设计上尽量使用合成/聚合来达到复用的目的，而不是使用继承，也就是说前者优先于后者而被运用。
  - 继承会将基类的细节暴露给子类，也称白箱复用，如果基类发生改变，子类也必须相应做出变动，且多继承不易维护。
  - CARP几乎可用于任何环境，依赖少，但是合成/聚合造成类中多对象需要管理

### 单一职责原则 SRP Single Responsibility Principle

* 概念：A class or module should have a single reponsibility
* 不要设计大而全的类，要设计粒度小、功能单一的类
* 不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。
* 持续重构：可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，就可以将这个粗粒度的类，拆分成几个更细粒度的类
* 判断原则
  - 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，就需要考虑对类进行拆分。行数最好不能超过 200 行，函数个数及属性个数都最好不要超过 10 个
  - 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，就需要考虑对类进行拆分；
  - 私有方法过多，就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
  - 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
  - 类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。

### 开闭原则 OCP Open Closed Principle

* software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。
* 只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试
* 代码的扩展性问题，是判断一段代码是否易扩展的“金标准”
  - 一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，就可以事先做些扩展性设计
  - 可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用
* 需要在扩展性和可读性之间做权衡

### 里式替换原则 LSP Liskov Substitution Principle

* If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。
* 子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。
* 多态和里式替换有点类似，但它们关注的角度是不一样的
  - 多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。
  - 里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。
* Design By Contract：按照协议来设计
  - 父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括
    + 函数声明要实现的功能
    + 对输入、输出、异常的约定
    + 甚至包括注释中所罗列的任何特殊说明

### 接口隔离原则 ISP Interface Segregation Principle

* Clients should not be forced to depend upon interfaces that they do not use。
* 接口概念
  - 一组 API 接口集合:如果部分接口只被部分调用者使用，那就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口
  - 单个 API 接口或函数:函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现
  - OOP 中的接口概念:接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数
    + 职责单一就意味了通用、复用性好 更加灵活
* 接口隔离原则与单一职责原则的区别
  - 单一职责原则针对的是模块、类、接口的设计
  - 接口隔离原则相对于单一职责原则
    + 一方面更侧重于接口的设计
    + 另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

### 迪米特法则 LOD Law of Demeter

* Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.
* 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）
* 实现代码的“高内聚、松耦合”
  - 高内聚：相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中
  - 松耦合：类与类之间的依赖关系简单清晰
  - “高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。

```java
// 既不想违背高内聚的设计思想，也不想违背迪米特法则
public interface Serializable {
  String serialize(Object object);
}

public interface Deserializable {
  Object deserialize(String text);
}

public class Serialization implements Serializable, Deserializable {
  @Override
  public String serialize(Object object) {
    String serializedResult = ...;
    ...
    return serializedResult;
  }

  @Override
  public Object deserialize(String str) {
    Object deserializedResult = ...;
    ...
    return deserializedResult;
  }
}

public class DemoClass_1 {
  private Serializable serializer;

  public Demo(Serializable serializer) {
    this.serializer = serializer;
  }
  //...
}

public class DemoClass_2 {
  private Deserializable deserializer;

  public Demo(Deserializable deserializer) {
    this.deserializer = deserializer;
  }
  //...
}
```

## 评测

* Service-Level Agreement SLA 服务等级协议:系统服务提供者（Provider）对客户（Customer）的一个服务承诺。这是衡量一个大型分布式系统是否“健康”的常见方法。SLA 设定一些指标，来考核、衡量系统
  - 系统可用性：也就是常说的 4 个 9、5 个 9 指标
  - 准确性或错误率：可以简单理解为 错误请求数/全部请求数=错误率
  - 系统容量/吞吐量/预期负载：也就是常说的 QPS/TPS 等， 每秒可处理的查询数或事务数
  - 延迟或 RT 等：系统响应时间
* 真正架构难度，不是业务架构，而是支撑核心业务稳定运行的点点滴滴，以微服务为例来看：
  - 冗余部署是提高系统可用性唯一法宝。服务的冗余部署，是为了提升系统可用性。另外使用微服务架构，有个很重要目标，就是要无感知升级系统模块。汽车的备用轮胎也可以提升汽车可用性，但汽车爆胎后，需要换轮胎的时间，这个可用级别上不去。 而微服务，把功能拆分成小服务，可以通过技术手段，无感知的升级
    -服务治理都会包含服务监测、预警功能。当服务错误率达到一定阈值，很可以报警或开启限流、服务降级、熔断等策略，把影响降低到最小
  - 微服务架构中，通常会在在 gateway 层，甚至 service,dao 层设置限流措施。当流量大于预期时，开启防御手段。也有一些弹性扩容的设定，当流量大于阈值时，自动扩展服务，应对突发流量，这个过程甚至不用人工参与
  - 系统延迟或相应时间，也会在服务监测平台设置相应指标，超过阈值时，启动相关服务降级、限流、熔断等策略
    注：个人理解，其实微服务、K8s 等，很大一部分功能都是为了应对 SLA 的智能化扩展

## 手段

* 单机：高性能、高并发手段相关
  - 单机高性能手段：可以上网查询 C10k 问题，获取相关文章。把进程、线程、池、IO 多路复用相关知识点弄清楚
  - 分清楚 IO 密集型和 CPU 密集型场景：一般互联网应用多为 IO 密集型。但是类似：滴滴出行、股市量化投资、在线游戏之类，属于 IO 密集型和 CPU 密集型并存的场景，甚至对响应时间要求也很高。 幸好大多数 CPU 密集型应用也是多租户、区域独立性架构，容易扩展拆分
  - 程序访问存储介质或链路快慢： 程序肯定要与存储进行消息交换。一定明白，CPU 高速存储器、内存、SSD 硬盘、机械硬盘、同交换机网络、同机房网络、同城网络、同运营商网络等。细节展开很多内容，包含缓存、cdn、多机房...从细节编程到部署架构的知识点
* 集群：高性能、高并发相关
  - 负载均衡反向代理：其实把 nginx 了解就可以了。如果是初创小公司，基本使用云上 SLB 负载均衡(ServerLoadBalancer)就可以，如果需要自建机房，有专门运维负责这些工作，到时候补补 LVS、F5 相关技术即可
  - 服务无状态：以微服务为例来说，服务无状态会带来太多的好处，扩展冗余部署服务会很方便。不谈微服务，就说前后端分离，鉴权这块 token 的实现，其实根本目的也是把用户状态剥离出来，实现服务的无状态化。 （提个小插曲，估计老人才了解 j2ee EJB 规范，当初居然专门设计了一个 sessionBean 有状态的服务规范）
  - 任务（服务）拆分：可以理解为服务拆解、功能拆解。其实拆分准则很多，可以按照实际需求来权衡。比如：按照人头分、按照功能划分、按照数据库表划分、按照功能重要性划分、按照功能访问频度划分,不过，水平按照 gateway、逻辑层、数据层、存储层算基本规范了
  - 常用的语言及框架：了解语言特性，如 node 语言的快速开发、前后端语言一致带来的便利、多路复用回调的原生支持等；go 语言“goroutines”特性带来的编程便利；java 优秀的生态及开源框架；c++性能优势等。当然技术选型，跟团队及业务成熟度很大关系。
  - 缓存：分布式缓存是提升系统性能利器。基本掌握 Redis 即可，需要知晓 codis 和 redis 官方集群部署方式。
  - 消息队列：消息队列也是常用提升系统性能利器，如业务逻辑异步化、削峰、解耦等。熟悉 kafka、rocketMq 即可。
* 高可用手段（集群）： 高可用手段核心解决思路是冗余部署，同样的服务冗余多份，会带来服务出错通知、服务自动切换、容错等一系列问题。高可用的实现更有技术含量，现在微服务框架服务治理组件，很多在高可用上做创新突破。（高性能冗余部署为了扩展节点，带来更高的处理性能）
  - 服务无状态：当某个服务故障时，自动切换到新的服务，不用产生状态丢失等问题。
  - 调用方支持超时、重试配置：由于网络抖动等原因，某个服务可能某次调用不可用，调用方需要重试重新调用。当然超时是调用方通用遇到的故障之一，也会有在其它故障发生，然后发起重试的配置。
  - 被调用方需要幂等支持：显而易见，无论是重试、还是调用方自动切换到的新的服务， 被调用方服务幂等支持的必备的。
  - 服务状态监测：所有服务都可用，那是理想情况。当某个服务发生故障时，整个体系必须知道这个服务有问题了，重试调用多少次也不会成功了。按照微服务框架来说，需要两方知道这个信息：1、服务注册组件。2、服务上游调用方。当然报警让运维技术恢复是常规。
  - 服务状态通知：按照微服务架构，服务的状态 在注册中心都会体现。但是注册中心跟服务之间一般是通过心跳来检测的，有时间延时。 另外，服务调用方会缓存注册中心数据，其中就包含服务状态。  所以说，从注册中心获取服务状态，是有延时，可能会造成很多无效的请求。  高效的服务状态机制，很难组件化框架化，  所以这块需要高性能、较实时的自研通信机制或高性能集中存储机制保证。具体可以留言讨论或后续文章探讨。
  - 调用方智能路由：除了负载均衡以外，当调用方 A1 知晓下游服务 C1 故障后，可以自动切换到 C2 等服务上。 另外，通过服务状态通知机制，最好可以告诉 A2、A3，C1 服务故障了，你们别去尝试了。
  - 服务故障恢复有，状态通知机制：这部分就比较简单了。注册中心状态变化后，调用方会慢慢更新注册中心元数据，来获取最新状态。 当时，如果有更实时的消息机制，时效性会更高。
* 系统可靠性（牺牲少部分可容忍体验，降低问题到最低）
  - 服务（功能）分类：不管是微服务框架也好，单体框架也好，架构师必须对功能、服务进行分类。分类维度很多，比如：重要程度、qps 量级、是否可以降级停止等等。
  - 应用限流：对于一般规模的应用，在 gateway 层做即可，从源头保护整个应用。对于超大应用（个人没经验），我觉得架构会更加复杂，可能 gateway 会分为很多层或多个，甚至有业务中台，层次会更复杂。
  - 服务降级：服务是在服务分类的基础上的。比如：百度贴吧的发帖功能，信息流广告功能，紧急情况下是可以降级处理的。可以人工或自动执行。其实 限流也是一种特殊的服务降级。（服务可以是个功能、也可以是接口，就看团队内如何达成一致）
  - 接口熔断：熔断一般在接口方法级别，因为调用链路很长，容易引起调用雪崩。让某个接口方法出现问题，我们可以按照预定配置处理业务，快速返回预设结果，防止整个链路的奔溃。
  - 弹性扩容：弹性扩容是理想的智能运维，但是具体操作也做大厂才会做相关工作。例如新年红包业务，双十一电商业务，秒杀业务，明星结婚对新浪微博的影响等，这些可以预知或未知的突发流量，如果系统可以自动扩容，那将很是完美。其实很多当前 docker+k8s 的使用案例，还只是方便运维工作量，对弹性扩容这块实践感觉不是很好。
* 存储
  - 关系型数据库：传统的 mysql 数据需要掌握。如果做互联网业务，对分库分表肯定有需求，关注 newsql，如 tidb，可以避免分库分表的麻烦。
  - NoSql 存储：es、mongodb 至少掌握一个。笔者对 elasticsearch 还是比较看好，综合性 文档数据、列式存储、反向索引 都支持，社区生态也很不错。
  - 大数据数据库：强烈建议熟悉 hdfs+hbase+openTSDB。如果熟悉时序数据库 openTSDB 设计以后，对了解各个监控系统如 openfalcon 有很大的帮助。基本自研监控系统也难度不是特别大了。
  - 内存数据库：有些特殊应用使用内存数据会事半功倍。redis 提供丰富的数据结构及良好特性，并且有很多插件，巧妙使用可以降低业务代码复杂度。
  - 消息队列：消息队列也有存储机制，使用得当，也可以当成存储介质使用。例如：kappa 架构，rocketMq 事务消息支持等。
* 最佳实践：架构师研究商业化广告系统的架构，广告系统涵盖知识点很多
  - 高并发、高性能的广告引擎
  - 倒排索引的广告定向召回
  - 流计算计费系统
  - 批处理反作弊大数据处理系统
  - 大数据DMP用户设备画像系统
  - 点击率预测机器学习、深度学习方向
  - adx+ssp+dsp 之间跨公司、跨系统间通信调用
  - 频次控制等需要的缓存系统设计
  - 交易相关资金方面的处理等等
* 使用 DDD，将复杂问题转化为繁杂问题
  - 提炼问题域
  - 找到问题域中的第一个核心子域
  - 对第一个核心子域进行战略设计
  - 完善统一语言
  - 视情况重复 2 ~ 5
* 使用 TDD，将繁杂问题转化为简单问题
  - 拆解问题（Tasking）
  - 红-绿-重构代码
  - 重构模型以加深理解
* 在简单问题中，使用最佳实践

## 分层

* 特点
  - 方便后续代码进行维护扩展
  - 分层效果需要让整个团队都接受
  - 各层职责边界清晰
* MVC
  - VO（View Object） 通常是请求处理层传输的对象，它通过 Spring 框架的转换后，往往是一个 JSON 对象
  - controller:此层只负责功能的调度(更适合承担角色是负责对 HTTP 请求进行路由)，参数的控制，结果的输出
  - service，此层负责业务逻辑相关的开发BLL(业务逻辑层):类内聚，OOP的抽象
    + 属性
    + 业务逻辑
    + BO（Business Object），它是业务逻辑层封装业务逻辑的对象，一般情况下，它是聚合了多个数据源的复合对
  - DAO(数据接入层)，此层负责与数据的交互,ORM接入数据对象
    + DTO（Data Transfer Object）是远程调用对象，它是 RPC 服务提供的领域模型
  - entity, 此层定义为数据表的一个映射
    + DO（Data Object）与数据库表结构一一对应，通过 DAO 层向上传输数据源对象
* 三层架构设计 3-Tier Architecture
  - Presentation layer 表示层（也就是UI层）
  - Application layer 应用层（也就是服务层）
  - Business logic layer 业务逻辑层（也就是领域层）
  - Data access layer 数据访问层（也就是数据持久层）
  - 原本MVC中的Model被拆分为了BLL和DAL，即将业务逻辑与数据访问进行分离，将原本臃肿的Model进行了进一步的解耦，有利于项目的更好维护
* 升级
  - 流量入口LB层
    + 安全防护：防止各类安全攻击，破坏系统、盗取数据
    + 接入质量：需要考虑使用各类网络各个地域的用户的接入质量，否则很可能有部分用户因接入质量无法参与活动
    + LB配置维护：需要靠性能可靠性，负载均衡策略，RS更新维护与健康检查、日志监控告警等多个方面的问题
    + 拨测监控：监控系统是否正常提供服务
    + 网络带宽：网络带宽是否足够，带宽问题通常比较隐蔽不易发现
  - 业务核心层
    + 基础资源：涉及计算、网络、存储等资源的创建配置管理，涉及安全扫描、安全防护、监控告警、系统优化等多访问的问题
    + 业务部署：涉及服务的发布变更、频控限流、容错容灾、性能优化、日志采集等诸多方面的问题
    + 业务开发：业务逻辑设计实现，容错、容灾能力实现
  - 数据存储层
    + 数据安全：防止密码泄露数据被盗等问题
    + 业务设计：数据库分库分表设计，数据库索引设计
    + 性能优化：提升系统吞吐能力
  - 高性能高可用
    + 高性能：系统各层的处理能力及性能瓶颈，如何排除链路中的性能瓶颈及优化，排除链路中的性能瓶颈可能需要进行大量的工作才能发现
    + 高可用：全链路的容错、容灾设计，如何降低避免诸如网络抖动、可用区故障等故障对系统造成的影响
* CQRS Command Query Responsibility Segration
  - 把 CRUD 系统拆分为两部分,两边可以用不同的架构实现，以实现CQ两端（即Command Side，简称C端；Query Side，简称Q端）分别优化
    + 命令（Command）处理
    + 查询（Query）处理
  - 实现方式
    + CQ 两端数据库共享，只是在上层代码上分离:这样做的好处是可以让代码读写分离，更容易维护，而且不存在 CQ 两端的数据一致性问题， 因为是共享一个数据库的。这种架构是非常实用的
    + CQ 两端不仅代码分离，数据库也分离，然后Q端数据由C端同步过来:
      * 如果需要 CQ 两端的强一致性，则需要用同步
      * 如果能接受 CQ 两端数据的最终一致性，则可以使用异步。
      * C端可以采用Event Sourcing（简称ES）模式，所有C端的最新数据全部用 Domain Event 表达即可
      * 查询显示用的数据，则从Q端的 ReadDB（关系型数据库）查询即可
* 阿里分层
  - 开放接口层：可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。
  - 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。
  - Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。
    + 轻业务逻辑，参数校验，异常兜底。通常这种接口可以轻易更换接口类型，所以业务逻辑必须要轻，甚至不做具体逻辑。
  - Service 层：相对具体的业务逻辑服务层。
    + 业务层，复用性较低，这里推荐每一个controller方法都得对应一个service,不要把业务编排放在controller中去做，为什么呢？如果我们把业务编排放在controller层去做的话，如果以后我们要接入thrift,我们这里又需要把业务编排在做一次，这样会导致我们每接入一个入口层这个代码都得重新复制一份如下图所示
  - Manager 层：通用业务处理层，可以是单个服务的，比如cache,mq等等，当然也可以是复合的，当你需要调用多个Mannager的时候，这个可以合为一个Mannager它有如下特征:
    + 对第三方平台封装的层，预处理返回结果及转化异常信息
    + 对Service层通用能力的下沉，如缓存方案、中间件通用处理
    + 与DAO层交互，对多个DAO的组合复用
  - DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。
  - 原则
    + 允许Service/Manager可以操作数据领域模型，对于这个层级来说，本来自己做的工作也是做的是业务逻辑处理和数据组装。
    + Controller/TService层的领域模型不允许传入DAO层，这样就不符合职责划分了。
    + 同理，不允许DAO层的数据传入到Controller/TService。
* 领域模型转换：每一个层基本都自己对应的领域模型
  - DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。
  - DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。
  - BO（Business Object）：业务对象。由Service层输出的封装业务逻辑的对象。
  - AO（Application Object）：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
  - VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。
  - Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。
  - 边界条件
  - 输入复杂性与不可预测
* 方法
  - 垂直扩展(Scale Up)：提升单机处理能力。垂直扩展的方式又有两种：
    + 增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G；如果预算不是问题，强烈建议使用“增强单机硬件性能”的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最快的方法。
    + 提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；
    + 单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展。
  - 水平扩展（Scale Out）：只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，如何在架构各层进行可水平扩展的设计，以及互联网公司架构各层常见的水平扩展实践。

![Alt text](../_static/layer.png "Optional title")

## 能力

* 以工程思维全面理解业务
* 基于模型和基础模式抽象简
* 提出恰当可行整体解决方案
* 在限定资源范围完成明确目
* 满足业务需求且保证系统质
* 在可预见的周期内具备扩展
* 并在系统生命周期内持续演
* 逻辑思维能力很强，思路清晰，有洞察力，善于抓重点
* 善于抽象，形成自己的结构化认知框架，有大局观
* 解构，拆分业务、系统模块和代码
* 发现问题，思考解决，设计取舍，重构迭代，协作传道，响应支持，持续学习，积累提高
* 抽象能力:就是关注本质，忽略细节的能力。经常做架构评审，我的团队做项目架构的时候，让我去做评审，一个项目的架构设计我就关注两样东西，一个是数据模型 (或称领域模型)，另外一个是接口模型。通过数据库表、表结构、API 接口模型，就能看出来抽象能力如何
  - 对某种事物进行简化表示或描述的过程，抽象让关注要素，隐藏额外细节。帮助我们从大处着眼（get our mind about big picture），隐藏细节（temporarily hide details）。抽象能力的强弱，直接决定我们所能解决问题的复杂性和规模大小。模块化分解
  - 整体的抽象：自顶向下的分治设计；子模块分解：自底向上的组合过程
  - 写代码会保持抽象层次的一致性，代码读起来像讲故事，比较清晰易于理解；而没有经验的程序员会有明显的抽象层次跳跃问题，代码读起来就比较累，这个是抽象能力不足造成
* 递归能力:面试中一定会要求面试者写递归算法，有没有掌握递归，对解决问题的能力相差是很大的。比如编译器解析器、代码生成器、序列化算法都涉及到递归，没有递归思维的程序员，就搞不定这个层面的工作。
* 分治(分而治之):大问题先分解为小问题，依次解决小问题，再合并成解决大问题。是和数据结构算法相关的
  - 分治(divide and combine或者split and merge)：对于一个无法一次解决的大问题，我们会先把大问题分解成若干个子问题，如果子问题还无法直接解决，则继续分解成子子问题，直到可以直接解决的程度，这个是分解(divide)的过程；然后将子子问题的解组合拼装成子问题的解，再将子问题的解组合拼装成原问题的解，这个是组合(combine)的过程。
  - 面试题：给你一台8G内存/500G磁盘空间的普通电脑，如何对一个100G的大文件进行排序？假定文件中都是字符串记录，一行约100个字符。
    + 100G的大文件肯定无法一次加载到内存直接排序，所以需要先切分成若干小问题来解决。
    + 那么8G内存的计算机一次大概能排多大的数据量，可以在有限的时间内排完呢？也就是100G的大文件要怎么切法，切成多少份比较合适？这个是考察候选人的时间空间复杂度估算能力，需要一定的计算机组织和算法功底，也需要一定实战经验和sense。实际上8G内存的话，操作系统要用掉一部分，如果用Java开发排序程序，大致JVM可用2~4G内存，基于一般的经验值，一次排1G左右的数据应该没有问题
    + 所以100G的文件需要先切分成100份，每份1G，这样每个子文件可以直接加载到内存进行排序。对于1G数据量的字符串排序，采用Java里头提供的快速排序算法是比较合适的。
    + 把已经解决的子问题组合起来，合并成我们需要的最终结果文件。这个时候该采用什么算法呢？这里考察候选人对外排序和归并排序算法的掌握程度，我们可以将100个排好序的文件进行两两归并排序，这样不断重复，我们就会得到50个排好序的文件，每个大小是2G。然后再两两归并，不断重复，直到最后两个文件归并成目标文件，这个文件就是100G并且是排好序的。因为是外排序+归并排序，每次只需要读取当前索引指向的文件记录到内存，进行比较，小的那个输出到目标文件，内存占用极少。另外，上面的算法是两路归并，也可以采用多路归并，甚至是采用堆排序进行优化，但是总体分治思路没有变化。
    + 考察候选人的分治思维之外，还考察对各种排序算法（快排，外排序，归并排序，堆排序）的理解，计算的时间空间复杂度估算，计算机的内外存特性和组织，文件操作等等
  - 递归也是一种特殊的分治技术
* 分层：把整个系统划分成若干个层次，每一层专注解决某个领域的问题，并向上提供服务。有些层次是纵向的，它贯穿所有其它层次，称为共享层。比如下图操作系统与TCP/IP协议栈
* 演化:架构既是设计出来的，同时也是演化出来的，对于互联网系统，基本上可以说是三分设计，七分演化，而且是在设计中演化，在演化中设计，一个不断迭代的过程
  - 除了要利用自身的架构设计能力
  - 也要学会借助用户反馈和进化的力量，推动架构的持续演进
  - 能够不断应对环境变化的系统，才是有生命力的系统，架构的好坏，很大部分取决于它应对变化的灵活性。所以具有演化式思维的架构师，能够在一开始设计时就考虑到后续架构的演化特性，并且将灵活应
  - 设计式思维和演化式思维的差异
    + 一开始就直奔微服务架构，其实背后体现的是设计式架构的思维，认为架构师可以完全设计整个系统和它的演化方向。马丁认为这种做法风险非常高，一个是成本高昂，另外一个是刚开始架构师对业务域理解不深，无法清晰划分领域边界，开发出来的系统很可能无法满足用户需求。
    + 从单块架构开始，随着架构师对业务域理解的不断深入，也随着业务和团队规模的不断扩大，渐进式地把单块架构拆分成微服务架构的思路，这就是演化式架构的思维。如果你观察现实世界中一些互联网公司（例如eBay，阿里，Netflix等等）的系统架构，大部分走得都是演化式架构的路线。
* 能力培养
  - 良好的架构设计思维的培养，离不开工作中大量高质量项目的实战锻炼，然后是平时的学习、思考和提炼总结。
  - 基本的架构设计思维，其实在我们大学计算机课程（比如数据结构和算法）中可以找到影子。所以大学教育其实非常重要，基本的架构设计思维在那个时候就已经埋下种子，后面工程实践中进一步消化和应用，随着经验的积累，我们能够解决的问题域复杂性和规模逐渐变大
  - 架构师的成长高度和他大学期间的思维习惯的养成关系密切，推荐参考美国Berkeley大学的数据结构课程CS61B[附录8.1]进行学习，对建立抽象编程思维非常有帮助

* 技术和业务两边都要有一定熟悉
  - 软件过程、系统分析与设计、架构设计、设计模式、Java 语言等内容，并研读了敏捷开发、领域驱动设计、工作流分析
  - 补基础知识，更重要当然是实践，珍惜每一个设计任务，珍惜每一次与业务人员、技术人员的沟通机会，让他们来检验自己的理解和方法，逐渐形成自己的体系，把零散得来的知识最终融合成体系化的设计与表达。多写文章，提升思维逻辑性，让经验固化成为知识，当然，固化不要僵化，业务架构师应该是很善于应对变化的
* 核心是架构，形成业务的架构。架构的定义是根据企业战略，对企业能力进行整体规划并将其传导到技术实现端的结构化分析方法。这其中有三个关键词，整体规划、结构化分析和传导。业务架构师的核心能力是将复杂的业务体系进行整体性的结构化设计，无论对 IT 技术或者业务有多熟悉，没有这一项能力是做不好业务架构师的。此外，由于有“传导”这个职责，这种结构化设计需要跟 IT 设计有机结合，因此，学习系统分析与设计知识就变得很重要，熟悉技术的读者能够理解，这些知识虽然偏技术，却与语言能力无关，可以脱离语言去学习其设计思维。
* 要多了解软件过程。其实很多技术出身的读者对软件过程也只是了解个大概，日常工作中也不很注重软件过程管理，忽视了这一点，就无法了解、掌控整个开发过程。开发的目的是为了高质量的交付，而非仅是完成任务。如果不注重软件过程，连自己的专业领域都无法持续优化，那又如何跨出一步去做个好的业务架构师？对业务出身的读者来讲，学习软件过程知识就更为重要了，因为你必须了解你的下游是如何运作的，业务架构是桥梁，业务架构师的作用不是“铁路警察各管一段儿”，而是要将业务和技术衔接起来
* 要学习流程优化等流程管理知识。业务架构通常不是为了现状进行设计，会涉及到整合、优化现有流程，需要掌握一定的流程优化知识，这样业务架构师才能更好地为业务提供有价值的建议。但是笔者认为，流程优化虽然很重要，却不是专业书籍可以提供多少帮助的，还是比较依赖实操。学习下经典理论，再学习下 BPMN 之类的工具知识就可以，多注意实战，这部分切记不要“迷信”书籍，因为流程优化是没有标准可言的，倒是多总结自己的心得更重要。
* 学习建模技术。业务架构的结构化设计通常是通过模型方式来展现的，因此，多学习不同的建模方法，流程的、数据的，甚至 DDD 的，互相取长补短，提升自己的模型表达能力，使设计结果能够更好地展现出来。
* 关于跨界的注意点。从业务出发想做业务架构师的读者至少应该学习一门主流的计算机语言，不需要达到很精深的程度，主要是理解技术落地的实现方式和技术人员的思维习惯，学习一门计算机语言，才能帮助你完成跨界转型，哪怕后边你又把它忘了（不经常写代码自然容易忘）；从技术出发想做业务架构师的读者至少要先深入地学习一个业务领域，再去跨领域搞企业级业务架构，就像所谓的“T”人才，先有垂直的一竖，再做拓展的一横
* 日常多养成从整体出发看问题的习惯。说夸张点儿，前看十年、后看十年地去分析问题，包括看书也是，看历史书、军事书，乃至花鸟鱼虫，看什么书、学什么知识都养成全面分析的习惯，时刻注意整体和部分的关系，架构处理的就是结构和关系，日常生活、工作的方方面面都会用到架构分析能力，不是仅有系统设计会用，养成了这种习惯也会让你的设计由“实现”变成“涌现”

![操作系统](../_static/os.png "操作系统")
![操作系统](../_static/tcp_ip.gif "操作系统")
![大自然中递归结构](../_static/recursion1.png "大自然中递归结构")
![大自然中递归结构](../_static/recursion2.jpg "大自然中递归结构")

## 不同视角切入架构设计

* 使用目标驱动的行动框架。明确我们要去哪里？知道架构设计的目的、阶段性目标， 才能有针对性的少走弯路。
* 怎么才能知道现在在哪？明白评价架构、系统的常见评价体系，才能针对目标，一步一个台阶的走下去。评价指标通常是与数据相关的，但是容易评估的目的，往往是简单容易实现或案例很多的。
* 无论我们面对的需求或目标多么高大，路要一步一步走，饭要一口一口吃。零零散散各个目标指标，只能有侧重、有优先不断迭代、夯实、拔高的达到目标。
* 如何理解大厂、书籍、国外传播的最佳实践呢？ 我们需要明白，任何最佳都是迭代出来的，而不是一蹴而就的。
* 针对架构设计目的，常用的有哪些手段呢？我们如何建立自己的武器库，常见的解决问题的手段呢，通过 5W1H 来了解梳理。
* 架构师岗位是与其他岗位高度协同的岗位，了解业务、了解其它岗位、协同人职责视角很重要。多元视角不光可以让自己更深刻理解架构本身，还可以了解业务、了解场景，更有效的协同工作。

## [protobuf 为经络，gRPC为骨架](https://mp.weixin.qq.com/s/jMrkrLpPxzJA4GsHFHKs-Q)

* protobuf 强迫不得不先考虑好数据结构再写代码；而gRPC 强迫不得不先定义好接口再写代码。而这两部分都完成并且得到充分的代码审查后，后续的实现再差也不会偏离大方向。
* 以 protobuf 为主的数据结构定义方式，即在一个项目（或者一个子服务）开始时，先集中精力用 protobuf 定义项目中所有可以被 protobuf 支持的简单类型定义的数据结构
  - 出错码:一个系统，清晰可追踪的出错码是系统在演进过程中能够快速排错的关键之一（之二是日志）.列表不必全，随用随更新.之后可以为其实现 error::Error — 这就是见证奇迹的地方：通过一套定义实现了内部和外部出错码的统一
  - 枚举类型:可以用 enum 表述。也是随用随加.在 rust 下，为了方便 prost 编译出的 protobuf 的枚举类型的各种应用，会在 build.rs 里加一些小的 hack.
    + serde 和 strum 相关的宏都是 protobuf 在编译过程中被额外添上去的。通过这样的处理，同一套枚举可以被用在各种场景：数据库（整数），输入输出（字符串），grpc及内部逻辑
  - 配置文件：个人偏好 toml，兼具可读性和灵活性。对于配置文件的每个部分，会定义这样的 proto
    + 在生成的 rust 代码中加上 serde 相关的宏（其它语言处理 protobuf 写的配置思路也类似），那么，在 proto 里定义的类型和下面的文件就可以相互转换，非常方便
    + 项目一开始先定义好配置文件的样子是非常有必要的，尤其是对于单元测试
    + 配置文件的结构可以在开发功能的过程中逐渐完善
    + 很多数据结构的初始化可以直接从配置文件里拿
    + 测试不再需要很多乱七八糟的常量定义。而在 protobuf 里定义配置文件的结构还有一个额外的好处，就是配置可以通过网络直接以二进制的形式传递，省却了中间序列化和反序列化的过程
  - 业务相关数据结构：在 protobuf 里定义，好处有二：1) 集中 2) 便于演进
  - 一个项目大概有50%-70% 的数据结构都可以被集中在 proto 文件中定义；我们只需要合理地控制生成的代码的命名空间，就可以很方便地引用所有的结构。而那些不能用 protobuf 定义的数据结构多数是和外部依赖相关
* 用 gRPC 串联一切
  - protobuf 并不需要和 gRPC 联合使用。即便项目本身和 gRPC 无关，也可以用 protobuf 来定义上述所列的数据结构
  - 一个后端的服务和外界打交道，兑现服务的承诺，而这个打交道的过程， gRPC 是非常完美的，承上启下的选择
  - 优点：
    + 服务的主要数据结构集中管理了，而服务对外的接口也能通过 gRPC 被集中管理起来，并且在需要的时候可以无缝升级
    + 会强迫用一个更好的结构来处理所面临的问题
  - protobuf 和 gRPC 作为一门单独的可扩展的语言的价值就体现出来：可以通过一些 annotation，描述服务可以如何被编译成 REST ←→ gRPC 的 proxy，这样，只需要写一份代码，就可以同时支持 REST API 和 gRPC
  - 因为 protobuf 和 gRPC 的强类型，还很容易自动生成 swagger 文档，并在 swagger 里完成浏览器 → proxy → gRPC 的服务调用

```
enum ErrorCode {
  // unknown error
  UNKOWN = 0;
  // not found
  NOT_FOUND = 1;
  // already exists
  ALREADY_EXISTS = 2;
  ...
}

/// supported platforms
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    strum_macros::EnumIter,
    strum_macros::EnumString,
    strum_macros::Display,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum Platform {
    Ios = 0,
    Android = 1,
    Web = 2,
}


// doorman service config
message DoormanConfig {
  // gRPC port
  uint32 grpc_port = 1;
  // websocket port
  uint32 wss_port = 2;
}

// facebook auth configuration
message FacebookConfig {
  string base_url = 1;
  string auth_url = 2;
  string avatar_url = 3;
}

// guardian service config
message GuardianConfig {
  // auth token secret
  string token_secret = 1;
  // auth db conn str
  string conn_str = 2;
  // auth token expiration
  uint32 expiring_days = 3;
  // facebook configuration
  FacebookConfig facebook = 4;
}
[doorman]
grpc_port = 8443
wss_port = 8480

[guardian]
token_secret = "c3VwZXJzZWNyZXQK"
conn_str = "postgres://postgres:postgres@localhost/aurora_test"
expiring_days = 14

[guardian.facebook]
base_url = "http://localhost:1234"
auth_url = "me?fields=id,first_name,last_name,email,gender,birthday&access_token="
avatar_url = "picture?type=square"

service UserService {
  // user signin
  rpc Signin(RequestSigninOrRegister) returns (ResponseSigninOrRegister) {
    option (google.api.http) = {
      post : "/api/v1/users/signin"
      body : "*"
    };
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
      summary : "User signin"
      description : "Sign in a user by using an auth provider"
      tags : "Users"
    };
  }
  // user resets password
  rpc ResetPassword(RequestResetPassword) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post : "/api/v1/users/reset_password"
      body : "*"
    };
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
      summary : "User reset password"
      description : "Reset password for users. For first time setting "
                    "password, old password should be empty string"
      tags : "Users"
      security : {
        security_requirement : {
          key : "ApiKey";
          value : {}
        }
      }
    };
  }
}
```

## [性能优化](https://mp.weixin.qq.com/s/iEcgODdo3mkQPvCou5PBHg)

* 局部性原理
  - 冯诺依曼瓶颈:程序总是按照“批”来处理数据，这样效率最高；比如：CPU读取内存是按照批来处理如：一个cacheline=64/128byte,内存与硬盘按照4KB来读取。因为计算机结构的特点，各级设备（CPU到内存到硬盘与外设）之间的访问速度是有数量级的差别；所以就注定不能一个个字节来读取；这个现象决定计算机优化的方向e
  - 时间局部性:最近访问过的资源（内存位置），可能近期内还会被访问，对应解决方案是缓存
  - 空间局部性:当前位置内存被访问过，那么大概率旁边的内存也会被后续访问，对应解决方案是预加载
  - 正是因为现代计算机有冯诺依曼瓶颈所以需要用缓存与预加载来提高程序的性能，否则会因为IO过重，资源得不到利用而效率偏低
  - 实例
    + 一个进程刚写入磁盘的数据，又要被其他进程读取，那么一来一回CPU都在等待磁盘读取数据，十分浪费资源，
      * 如果将磁盘的数据放入磁盘写buffer，读的时候优先从buffer中读取，而buffer都是在内存中，这样就弥补了这个性能的gap，这就是“时间局部性”原理的使用，也就是我们常说的“缓存”，或者“空间换时间”；
    + Mysql数据库有个特点就是数据是存在磁盘上，读取记录时需要将数据从磁盘加载到内存然后进入CPU计算得出结果，所以会横跨三个IO边界——磁盘、内存与CPU，它们之间都有好几个数量级的延迟，所以IO性能的平衡就十分的重要。
      * 其中比较典型的就是B+树这种针对外部存储型的数据结构的引入，它十分贴合磁盘IO的“口味”。磁盘IO有个特点，就是读取写入都很慢，但是可以一次读取大量的数据。根据这个特点，B+树采用多叉树的结构进行设计，这样做相比二叉树来说可以减少树的高度，这样带来的好处是每一层数据都可以是在物理空间相邻的，从而可以通过最少的IO次数加载更多的数据到内存；而这些数据往往是业务相关的，所以一次IO读取的数据可以供后续很多计算工作使用而不用重复IO。比如，一个表有20列，那么每一行数据就有20个字段，这些字段往往在磁盘中是连续存放的，当我们通过id查询其中某个字段a的值时，Mysql其实会将整个记录都取出来，加载到内存，而程序访问完a字段，再访问记录中其他字段时就不需要磁盘IO了，直接读取内存中记录的缓存就行，这就是“空间局部性”的使用实例，也就是我们常说的“预加载”，系统预热。
* 基本算法设计与分析
  - 数据结构之所以重要是因为不同的数据结构表现出来的数学性质是构成特定算法的基础。大致分为两种，一种是数组，另一种是链表。两种性质截然相反的“物质”。
    + 数组——线性性能最好，支持随机访问，按照索引取数组中的元素时间复杂度是O(1)，而插入与删除元素时间复杂度是O(n)；
    + 链表——扩展性能最好，支持动态的增减元素，插入、删除元素的时间复杂度是O(1)，而检索元素的时间复杂度变成了O(n)；
    + 这样一对性质完全互斥的结构就是构成所有高等数据结构的基础
    + 堆｜做优先级队列｜二叉堆，就是以数组作为基础的。它在插入、删除、查询元素时的性能可以稳定在O(logn)量级；在互联网行业中，只有logn级别的算法可以适用，因为当数据规模急剧增加的时候，对数函数能够很好的平稳压力，所以，"logn"的算法对互联网行业贡献巨大，具有整流器的作用。
    + 在微服务流量控制，大数据流处理、topN、高性能定时器都有很多应用。而堆只有在数组实现的算法中才能保持这个特性，如果用链表就会退化为O(nlogn)，失去魔力。
    + 二叉树，这就是链表的一个使用场景。二叉树是一种树状结构，其中平衡二叉树在插入与删除的过程中只要移动logn次就能找到自己的新位置，而且代码简单易于维护（不容易写错也是工程中一个重要的考虑点，如果写得代码过于复杂就要反思下是否使用错了数据结构）。比如：红黑树就是一个综合性能很好的平衡二叉查找树；它是一个动态的数据结构，可以在动态添加与查找过程中稳定在O(logn)量级；在Linux内核中大量使用；而且在Java中的ConcurrentHashMap在冲突大的情况下，冲突元素大于8也会升级成红黑树存储冲突元素，来平衡工程与算法效率之间的矛盾。
    + 数据结构是可以融合的，比如Java中的LinkedHashMap就是融合了数组、哈希表与链表的优秀实践。普通的哈希表因为通过哈希函数将元素链接到数组的索引号上面，实现高速的查找性能，但是丢失了元素的插入顺序，而有时候我们需要这个顺序性来实现特殊的需求，比如缓存淘汰策略；而如果使用链表，形成一个插入的队列，先插入的在队列头，后插入在队列尾部；但是这样虽然保存了插入的顺序但是丢失了查找性能；为了平衡，我们可以在哈希表的基础上，每个元素再增加一个指针用来连接前后插入的元素，形成队列，这样没插入一个元素不仅在哈希表上挂载新的索引点，还要将新元素挂接到队列的尾部，而每一步都是O（1）的开销，是可以接受的，这就是LinkedHashMap的实现原理。
  - 算法设计技术
    + 对实际问题的建模，建模是对问题的模拟，越准确越能够解决好问题
      * 蛮力算法
      * 贪心算法
      * 分治算法
      * 动态规划
    + 蛮力算法是对问题建模的初期阶段，是对问题的程序再现，追求的是定性，性能不一定重要，但是问题描述没问题；分治与贪心是在蛮力基础上的一次降阶，往往可以将问题优化到O(nlogn)的规模以内；而动态规划可以进一步将问题的阶降到O(n)级别。降阶是设计算法的初衷，前提是问题本身计算的各个阶段是有冗余的，有重复计算的地方，而找到这个重复的点并不容易，就拿动态规划来说吧，虽然有极致的性能但是发现递推方程并不容易，当然这一切都要经过严格的数学证明才行，这就更加难能可贵。我们这里没有考虑空间的优化，往往降阶的过程中最好保证空间的复杂度不会激增，这样才会有效
* 多线程
  - 往往可以优化程序的运行效率，但是这里有个基础就是硬件的资源并没有被充分利用，也就是说，如果因为IO导致CPU利用率不足，当然就要想办法去构建可以充分利用硬件资源的方法，而多线程、多路复用这些技术都是为了提高硬件的利用“带宽”的技术

## C/S

* 二将军问题:失败结果有两种可能
  - 去向出问题
  - 操作成功，回路出问题
* 失败重复请求，接收方的幂等性

## 架构部操作手册

公司的部门分工、流程、机制由其文化、历史、人员背景等决定，无一定之规，仅供参考。

架构部属于技术部中的公共部门，面向技术部整体，在架构层面负责，包括三个小组：架构与规范、应用架构研发、性能测试，并组织技术委员会。

* 职责
  - 架构与规范：负责系统架构蓝图设计，系统设计的合规，架构的持续改善与治理，研发流程的规范制定与审查，提升整体技术架构水平。研发公共技术组件，推进技术体系规范化，架构合理化，实现平台化、功能通用化，提高技术能力，使系统具备更强的灵活性，满足公司业务战略发展需要，实现业务技术一体化。
  - 应用架构研发（基础平台）：负责技术基础应用平台体系的搭建，包括项目管理、自动化编译部署、应用监控告警、报单处理、数据库元数据管理等通用系统的设计开发。提升技术部的自动化、工具化水平，提高工作效率，强化运维能力和信息化管理能力。
  - 性能测试：负责对性能要求较高的核心系统、技术组件进行线下和线上性能测试，提前发现性能问题、验证系统性能指标达成情况，确保系统更为稳定。
  - 技术委员会：根据公司业务发展战略需要，关注电商业务场景需要的大流量、高并发、高可靠性、实时性、平台化、服务化的底层技术。针对不同领域组织专家小组、课题小组，实现跨团队技术共享与协作。定期组织技术沙龙，分享外部技术热点，挖掘内部技术成果，收集技术资料供技术部学习。与外部协作举办线下技术沙龙，邀请外部专家，与其他公司进行技术交流，向业界技术会议推荐专家讲师（进行报备及主题审核），进行主题分享，发表技术文章，活跃团队技术气氛，强化公司技术品牌。
* 产品线
  - 技术框架、组件
* 基础平台
       项目管理系统PDLC

* 自动化运维部署平台
  - 应用监控平台
  - 服务监控系统
  - 报单跟踪系统
  - 资源管理平台
  - 代码构建仓库
  - 代码检查工具

### 日常工作

#### 架构

    + 业务架构
    + 系统列表
收集整理系统列表：参见Twiki
因采用PDLC进行技术团队项目管理，PDLC中包含此功能，应以PDLC为准。

* 系统架构总图：最新版参见：架构部工作文档\01.规划\系统清单
* 系统分级：根据系统重要程度分级，参见文档：架构部工作文档\01.规划\系统分级
* 系统分层：复杂系统需要有清晰的层次划分，一般自上而下调用，避免逆向依赖而导致循环依赖。一般分为前台、中台、后台。
  - 前台包括面向用户的页面、我的订单、营销活动等系统。
  - 中台包括通用服务，搜索、推荐、数据、购物车、交易、客户信息、商品信息、价格、库存、促销、礼券、礼品卡、商家、积分、支付、全站配置等系统。
  - 后台包括订单、退换货、客服、TMS、WMS、财务、结算、ERP等系统。
* 架构规划：对未来系统架构进行规划，明确边界划分，指导产品线设计，避免重复建设、长期缺位等问题。
* 系统架构
  - 系统成熟度：根据不同的系统类型，定义成熟度标准，梳理各系统当前实际水平，指导系统演进。参见Twiki。
  - 项目支持：根据需要对具体项目进行支持，包括：
    + 前期调研，设计方案，如：O+O、拍卖、直播。
    + 根据项目需要，参与项目需求分析、技术方案设计、上线部署准备。
    + 主导项目架构设计、核心代码实现、技术难点公关，如：WMS、TMS
* 架构评审：技术设计方案评审，在PDLC上登记，每周三下午定期举行，特殊情况可临时评审。
  * 要求尽可能早、同一个项目各系统一起进行架构评审，这样可能根据建议进行调整。
  * 架构评审重点在于把关，提高研发设计能力，考虑全面，达到基本要求。
  * 有争议的设计方案可以打回，无法达成一致则升级决策。
  * 技术部自发的重点重构项目往往忽视架构设计评审，导致后续开发、测试、上线、运行出现问题。

* 技术架构
  - 技术调研：对互联网、电商领域新兴技术进行调研，跟踪趋势，分析优劣，根据公司实际情况提出实行建议。比如日志中心、Redis集群、容器化、微服务等。
  - 技术组件、框架、平台
    + 公司技术架构体系并不完整和统一，需要逐步完善，并重在解决实际痛点和获得技术部广泛认可。技术架构作为基础，逐步完善意味着整体技术水平提升，并以技术提升效率，降低成本和风险，创造价值。
    + 路线是组件到框架到平台，由易入难，由轻落重。
    + 重点： 稳定性、易用性、分布式场景可靠性、持续升级。
  - 技术支持：响应各技术团队技术咨询、协助解决技术问题，重点在于架构部推广的框架、组件、平台。
  - 技术债
    + 架构部应关注技术维度问题，立足当下、面向未来、对过去心中有数，知其然亦知其所以然。
    - 总结解决方案、建议

#### 规范

汇总技术规范并发布，规范可来自其他部门。

* 设计规范
  - 技术方案设计规范
  - 数据库设计规范
  - 项目架构设计文档规范
* 开发规范
  - CodeReview规范
  - 代码质量检测
  - SQLReview规范
  - Maven使用规范
  - PHP/JAVA开发规范
* 单元测试规范
* 流程规范
* PDLC流程
* 域名申请流程
* 开源申请流程

#### 应用架构研发

* 管理机制
  - 各系统有主要负责人，相当于内部PO。
  - 采用PDLC敏捷方式进行任务管理，跨职能，交叉测试。
  - 架构部自身管理也应结合在PDLC之中。

## 关注重点

    - 待完成任务登记列表：
    - 系统稳定性、易用性、监控全面性。

技术部各团队潜在需求。

通过PDLC、Pangu、监控系统数据统计分析使用情况及发现问题。

关注线上系统运行情况。

监控系统的监控方案。

Nagios年底下线。

跨机房部署方案。

Tracker告警短信接口超时问题。

告警是否可以扩展到钉钉、微信等通知。

* 发展方向
  - 完善基础平台，各系统打通，发挥协同作用。
  - 作为自研技术组件和新技术的试点应用平台。

2.3性能测试
2.3.1流程
测试任务由架构部内部发起，或其他部门通过项目经理提出，任务需登记在PDLC中。

性能测试的发起来源：

1.研发部门根据项目改动发起，包括页面性能测试。

2.架构部参与项目设计时明确。

3.架构部评审项目设计时提出。

2.3.2重点
测试项目文档、结果、报告、脚本做好备份。

尽可能了解业务场景，有针对性制定性能测试方案，最大程度发现问题。

对测试结果负责，了解问题原因，有问题务必通知到项目经理，避免影响上线决策。

测试环境尽可能与线上一致，模拟请求符合业务场景，线下测试主要目标发现性能瓶颈及隐患。

2.3.3发展方向
开发自动化测试工具，实现自动化、平台化、可复用，节省人力，提高效率。

对线上系统实现常态化、自动化性能测试，以性能指标、趋势衡量系统。

将性能测试工程师升级为测试开发工程师及性能测试专家。

2.4技术委员会
2.4.1内部沙龙
定期举行技术沙龙，邀请外出参会人员、内部有成果成员、新加入架构师进行分享。

2.4.2专家小组
根据实际需要，组成针对专门领域的跨部门技术专家小组，加强协作，以强化对专门技术的掌握，提高整体技术能力。

2.4.3外部交流
与其他公司进行技术交流。

邀请外部专家到公司分享交流，可从HR培训部申请经费。

2.4.4外部沙龙、大会
分享外部沙龙、大会信息，与HR培训部沟通，申请参加。

推荐技术骨干作为嘉宾，到外部技术沙龙、大会进行分享。

在业界技术社区、网站、公众号发表文章。

2.4.5开源社群运营
基于自研开源产品，通过GitHub、QQ群、微信群维系社群，响应问题，发掘贡献者，进行技术支持。

2.4.6内部社群运营
通过技术部组织跨部门技术QQ群、微信群，增加部门沟通，便于咨询交流。

三．部门长管理职责
3.1部门管理
3.1.1部门周会
每周五上午10点-11点，结合部门周报，总结工作成果及问题，明确后续工作，传达公司、技术部信息，记录会议纪要，安排内部分享。

注意：会议室预约可能会被定期清理。

3.1.2技术部周会
每周一下午2点12-2，会前会收集其他议题。

架构部周报经整理后写入sharepoint。

会上各部门汇报上周工作情况，架构部应了解各部门情况，并参与相关问题讨论。

3.1.3部门绩效
目前技术部实行季度考核，每季度各部门与HR指定KPI，季度结束后进行考核，其中一定比例为CTO打分。

每季度会发放绩效奖金，部门绩效会影响部门总奖金数及人员考核结果分布比例。

3.1.4月总结
每月会安排各部门反馈月总结及下月计划。

月总结通过周报汇总即可获得。

一般更关注各产品线情况。

3.1.5与CTO1V1
每两周周四下午3点-4点，汇报架构部各项工作进展及问题，反馈一些想法，与CTO进行深入讨论。

听取CTO的指导和建议，保持思路同步。

3.1.6招聘
与HR招聘组对口负责人协作，通过邮件筛选简历，安排面试时间及人员，架构师也需要笔试。

架构师需要CTO终面，终面时间可另行安排。

其他职位负责终面，介绍架构部情况，明确具体职责及加班要求，询问待遇要求及当前offer情况，将结果反馈给HR。

对新员工指定导师，确定试用期目标，结束前评估达成情况，打印签字后交给HR，以便转正。

发布招聘信息，尽快招聘到位，避免长期空缺造成人员浮动。

新入职架构师需安排在技术部范围内进行分享。

招聘JD参见：架构部工作文档\08.招聘\架构部JD.txt

3.1.7培训交流
负责对技术部新员工进行系统架构培训、技术方案设计培训，包括应届生，并针对应届生安排Java基础培训。

负责对有需要的业务部门和外部公司讲解公司系统架构。

3.1.8资产管理：管理部门成员使用的办公电脑、开发测试环境服务器、线上生产环境服务器。

* 开发敏捷管理：项目经理负责，迭代任务计划制定、任务分配（注意交叉测试）、站立会、迭代总结。
  * 代码备份、SQL备份
  * 代码规范、检查
  * 测试要求、报告
  * 登记待完成任务。

#### 团队管理

* 绩效考核
  * 每季度对部门成员进行绩效考核，根据HR要求分配考核结果。
  * 考核结果会影响未来的晋升和加薪资格。
  * 架构部因职责、能力差异较大，主要以集中答辩评分、部门长主观评价及参考工时确定。
  * 需关注、强调成员平均工时情况，进行提醒，此为公司要求，HR会进行统计。
* 晋升及加薪
  - 每半年技术部有一次晋升答辩，高级水平以上需要公开答辩，初中级各部门自行评审。
  - 晋升一般要连续两次考核B以上，以HR提供规则为准。
  - 晋升会获得较大加薪，每半年也会有普调，两者资金隔离。
  - 晋升加薪及普调加薪，需部门长根据情况分配。
* 1V1：定期（如每两周）与团队成员1V1，半小时，沟通近期工作、问题、后续工作方向，个人成长目标，对公司、团队的想法。
* 内部分享
  - 每周安排一名同事进行内部分享，分享内容尽量以技术为主，30分钟以内。
  - 强化内部交流氛围，提高分享技能。
* 资金管理：每季度每人150元左右活动经费，由部门福利专员管理。
* 团队建设：可根据需要定期举行团建活动，可安排部门福利专员组织。
* 申请奖项
  - 每月HR会征集总裁认同奖及技术部部门认同奖，包括个人奖及团队奖，可根据情况提报。
  - 申请到的认同奖，可留一部分作为团队经费，一部分聚餐，剩余大部分根据贡献分配发放到个人。

#### 记录

* 架构部Twiki主页：
* 架构部相关历史Twiki:
* 架构部Sharepoint主页：
* 外部技术大会资料（上传需在ITSupport申请开通权限）

## 图书

* [software-architecture-books](https://github.com/mhadidg/software-architecture-books)A comprehensive list of books on Software Architecture.
* 《恰如其分的软件架构：风险驱动的设计方法》
* 《面向模式的软件架构（卷 1）：模式系统》
* 《程序员必读之软件架构》
* 《架构实战：软件架构设计的过程》
* 软件架构设计
* 《前端架构：从入门到微前端》
* 《系统架构:复杂系统的产品设计与开发》
* 《大型网站技术架构：核心原理与案例分析》
* 架构设计方面
  - 《系统分析与设计》（Kenneth E.Kendall ，Julie E. Kendall 著）
  - 《设计原本》（Fredrick P.Brooks，Jr. 著）
  - 《软件系统架构 - 使用视点和视角与利益相关者合作》（Nick Rozanski，Eoin woods 著）
  - 《架构之美》（Diomidis Spenellis & Georgios Gousios 著）
  - 《实现领域驱动设计》（Vaughn Vemon 著）
  - 《微服务设计》（Sam Newman 著）
  - 《企业 IT 架构转型之道》（钟华 著）
* 软件过程方面
  - 《软件工程 - 实践者的研究方法》Roger S.Pressman
  - 《软件工程》Ian Sommerville 
  - 敏捷软件开发：原则
  - 《模式与实践》（Robert C.Martin）
  - 《Scrum 敏捷软件开发》（Mike Cohn 著）
* 流程优化:除了流程管理层面的技术知识外，更重要的可能来自于管理学，不妨多读读管理类书籍，拓宽思路，再考虑具体的流程优化
  - 《目标》Eliyahu M.Goidratt
  - 《凤凰项目 - 一个 IT 运维的传奇故事》Gene Kim, Kevin Behr & George Spafford 
* 《架构即未来》
* 《微服务设计》
* 《大数据日知录》
* 《企业应用架构模式 Patterns of Enterprise Application Architecture》 Martin Fowler
* 《Web性能权威指南》
* 《SRE：Google运维解密》
* 《发布！软件的设计与部署》
* 《高扩展性网站的 50 条原则》
* 《大型网站技术架构:核心原理与案例分析》
* 《恰如其分的软件架构：风险驱动的设计方法》
* 《软件系统架构：使用视点和视角与利益相关者合作（第2版》
* 《图解服务器端网络架构》
* 《大型分布式网站架构设计与实践》
* 《分析模式》
* The Performance of Open Source Applications
* The Architecture of Open Source Applications, Volume I
* The Architecture of Open Source Applications, Volume II
* 《程序设计语言 Programming Language Pragmatics》Michael L. Scott

### 《架构整洁之道》

* 依赖倒置（DIP）本质上是一种解耦，解耦的目的是实现组件化的独立部署和独立开发能力
* 所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。如果变量永远不会被更改，那就不可能产生竞争或并发更新问题。如果锁状态是不可变的，那就永远不会产生死锁问题。所以架构师要做好可变性的隔离，区分出可变组件和不可变组件，尽可能的将处理逻辑归于不可变组件
* 软件构建中层结构的主要目标是：第一、使软件可容忍被改动；第二、使软件更容易被理解；第三、构建可在多个系统中复用的组件
* SRP是康威定律的一个推论，即软件应与组织息息相关，每一个软件模块应该只对某一类行为者负责。单一职责原则放到组件层面就是共同闭包，即我们应该将会同时修改，会以同样目的而被修改的类整合成一个组件
* OCP是指当新增功能时可以通过增加新代码而非修改旧代码来实现
* 软件复用的最小粒度应该等同于软件发布的最小粒度。PS：有些研发组织以系统的形式发布软件，却期望各个系统去共享使用通用的功能，最后只能是一团糟
* 不要依赖不需要用到的东西，换言之，在设计组件时，应考虑这些类是被共同复用的吗？PS：难
* 不要出现依赖环，否则会影响开发效率。依赖环的消除可以使用依赖倒置来解决
* 组件是不可能从上到下被设计出来，因为组件体现的不仅是业务功能而是构建性、维护性、依赖关系的地图。PS:很反直觉，有待体验
* 不稳地的组件可以依赖稳定的组件，而不能让稳定的组件依赖不稳定的组件。一个组件的抽象化程度应该与其稳定性保持一致，就是说稳定的应该抽象，否则无法满足开闭原则。不稳定的应该包含实现代码，这样才方便修改
* 软件架构的终极目标是最大化程序员的生产力，同时最小化系统的总运营成本
  - 好的软件架构应该是团队的组织架构相适应，方便开发团队开发
  - 好的软件架构要考虑到方便部署
  - 好的软件架构应该使开发人员对软件运行过程一目了然
  - 好的软件架构应该便于维护
  - 好的软件架构应该保留更多的（有意义的）可选性
* 一个系统在水平分层上比较常见的方式是：UI界面、应用独有的业务逻辑、领域普适的业务逻辑、数据库
* 划分边界的目的是方便我们尽量将一些决策延后进行
* 计算机程序从本质上说就是一组仔细描述如何将输入转化为输出的策略语句的集合。软件架构设计的工作重点之一就是将这些策略彼此分里，然后将他们按照变更的方式进行重新分组。变更原因、时间和层次相同的策略应该被分到同一个组件中
* 一种策略距离系统的I/O越远，它所属的层次就越高。高层次的策略不应该依赖于低层次的策略。PS:有道理
* 业务逻辑是与技术无关的，是现实中某一项业务的一部分。业务实体就是业务逻辑与业务数据的组合
* 架构设计的核心目标：满足用例，并能将它们与周边的因素隔离
* 整洁架构：越内层层次越高。外层圆代表的是机制，内层圆代表的是策略。源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。PS:这就是整本书的核心了，也是罗伯特老爷子的核心主张。在这个框架中，业务实体应该是最不容易发生变动的
* 每个系统架构的边界处，都应该多使用谦卑对象模式，即只发挥自己的桥梁和通信作用，并不从中干预信息的传输

![Alt text](../_static/tidy_arthctect.png "Optional title")

## 实例

* [COLA](https://github.com/alibaba/COLA):Clean Object-oriented & Layered Architecture

## 参考

* [architect-awesome](https://github.com/xingshaocheng/architect-awesome)
* [awesome-architecture](https://github.com/toutiaoio/awesome-architecture):架构师技术图谱
* [system-design-primer](https://github.com/donnemartin/system-design-primer):Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.
* [architecture.of.internet-product](https://github.com/davideuler/architecture.of.internet-product):互联网公司技术架构，微信/淘宝/微博/腾讯/阿里/美团点评/百度/Google/Facebook/Amazon/eBay的架构
* [500lines](https://github.com/aosabook/500lines):source for the book 500 Lines or Less
* [awesome-design-systems](https://github.com/alexpate/awesome-design-systems):💅🏻 ⚒ A collection of awesome design systems
* [from_coder_to_expert](https://github.com/0voice/from_coder_to_expert):2019年最新总结，从程序员到CTO，从专业走向卓越，分享大牛企业内部pdf与PPT
* [awesome-scalability](https://github.com/binhnguyennus/awesome-scalability):An updated and curated list of selected readings to illustrate Scalability, Availability, and Stability Design Patterns in Back-end Development.
* [fast](https://github.com/microsoft/fast):The adaptive interface system for modern web experiences. <https://www.fast.design/>
* [A few thoughts on the role of software architects](http://joeduffyblog.com/2008/10/02/a-few-thoughts-on-the-role-of-software-architects/)

* [“构建”世界的能力-架构能力](https://mp.weixin.qq.com/s/Qw8TEIssMwrE9l2Y8BzjaA)
* [最小可用架构](https://mp.weixin.qq.com/s/rZWxtVyJjgiUBPeY5gPqOA)
* [百万年薪架构师是如何炼成的？](https://mp.weixin.qq.com/s/D8-fdrJzggAFH-UbsLmjew)
* [优秀架构师必须掌握的架构思维](http://www.infoq.com/cn/articles/architecture-thought)
* [Software Architecture is Overrated, Clear and Simple Design is Underrated](https://blog.pragmaticengineer.com/software-architecture-is-overrated/)
