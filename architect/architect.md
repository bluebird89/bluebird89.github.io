# Architect 架构

* 所解决问题的复杂度决定了技术实力高度。技术人不应仅仅满足于每天去实现业务逻辑细节，还要能从更高层面去设计和构建企业的技术架构
* 技术为业务服务，开发的更多的是应用系统或者称之为业务系统，业务的不同特点决定了应用（业务）架构也必然有不同的特点
* 不同特点单纯靠技术肯定解决不了，应用架构设计的一条重要原则是 **技术中立**，更多时候要从应用角度而不是技术角度去考虑问题
  - 容易的在于不需过多关注技术实现
  - 难的在于必须根据实际业务场景和业务需要及时间、成本、资源等给出当下最合适、一定不是最完美的架构方案
* 所有大型互联网系统初期一定不是设计成现在这个样子的，都是伴随着业务从小到大、从少到多、从简单到复杂的过程演进而来，架构的演进过程也见证了业务的发展历程
* 应用架构（业务系统）对技术追求要有所止境，当 DB 瓶颈解决不了时换个思路，来个排队系统和预约系统，技术难度就降低了很多；分布式事务解决不了，那就做好回滚、补偿、对账这些基础工作。多从应用架构的角度去思考解决方案
* 宏观系统架构中很多设计来源于微观东西
  - 云计算中的很多虚拟化技术的原理，和传统的虚拟内存不是很像么
  - Unix下的那些I/O模型，也放大到了架构里的同步异步的模型
  - Unix发明的管道不就是数据流式计算架构吗
  - TCP的好些设计也用在不同系统间的通讯中
  - 要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透

## 定义

* 软件架构（software architecture）是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。把架构当成一个技能、工种、职位、岗位，核心还是为了应对软件设计、构建中的复杂度，降低成本、提升效率
* 事中业务：常见业务系统。如：电商、交易系统等等大多属于这类。实际业务中，对业务反馈需要越实时，实现难度相对越高，比如：共享单车 app、股票交易等，需要实时的提示、预警、交互。除了传统型业务型架构外，对大数据流计算架构要求逐步提高
* 事后业务：事后肯定有数据沉淀，有数据肯定可以对未来决策做指导。自然而然查询统计、报表决策、数据挖掘、事后总结等数据应用类系统
* 事前业务：事前基本为业务预测、分类、推荐、决策辅助等业务。随着机器学习、深度学习的火热，这部分应用越来越广泛。例如：量化投资、广告点击率预测、短视频推荐、电商推荐等
* 目的
  - 业务复杂、数据量、用户数引起复杂度
* 需求
  - 高并发
  - 高性能
  - 高可用
  - 安全性
  - 规模扩展性
  - 规模成本

## [特质](https://insights.thoughtworks.cn/the-well-rounded-architect/)

* 技术领导者
  - 并不一定要告诉开发人员做什么。相反，好的架构师就像一个导师，能够带领开发团队向同一个技术愿景前进
  - 会借助于讲故事、影响力、引导冲突、构建信任等领导技能，将他们的架构愿景变成现实
  - 同时也是一个好的架构师。他/她会仔细听取每个参与者的意见，通过与团队的反馈互动调整他们的愿景
* 开发人员
  - 一个良好的架构选择需要权衡理想的架构状态与软件系统的当前状态,如果不考虑技术选型与问题域之间的匹配度，那么会很容易受到各种技术的诱惑——这也就是常见的“象牙塔式架构师”行为模式
  - 缓解这种情况的最佳方式是让架构师多与开发人员待在一起，花一些时间在代码上。了解系统的构建方式及系统的约束，这将帮助架构师在当下环境做出正确的选择
* 聚焦系统
* 具备企业家思维
* 具备权衡策略思维与战术思维
* 能够进行良好的沟通

## 演进之路

* 单机架构
* Tomcat与数据库分开部署
* 引入本地缓存(memcached)和分布式缓存(Redis)
* 引入反向代理实现负载均衡
* 数据库读写分离
* 数据库按业务分库
* 把大表拆分为小表(垂直分表)
* 使用LVS或F5来使多个Nginx负载均衡
* 通过DNS轮询实现机房间的负载均衡
* 引入NoSQL数据库和搜索引擎等技术
* 大应用拆分为小应用
* 复用的功能抽离成微服务
* 引入企业服务总线ESB屏蔽服务接口的访问差异
* 引入容器化技术实现运行环境隔离与动态服务管理
* 以云平台承载系统

## 原则

* 在时间、安全、稳定、性能等方面做权衡，同时注意控制复杂度
  - 权衡需要宽阔视野、良好沟通能力、多样化价值观，不能钻牛角尖，要能妥协而且懂得如何妥协
  - 控制复杂度的很大一部分工作则是合理划分责任：事情还是那些事情，切成多少个部分，每个部分放在哪里，怎么实现，怎么组合。这工作有时候看起来像拼图一样简单，其实需要之前修炼的经验和眼光才能决策，而架构设计的水平高下，往往就存在于那些拼图方案之中
* N+1设计｜冗余设计：系统中的每个组件都应做到没有单点故障，对服务、数据库的做结点冗余，保证服务的高可用。通过数据库主从模式、应用集群来实现
* 回滚设计：确保系统可以向前兼容，在系统升级时应能有办法回滚版本，对于任何业务尤其是关键业务，都具有恢复机制。可以使用基于日志的WAL、基于事件的Event sourcing等来实现可回滚
* 可禁用/自我保护：应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能。具有限流机制，当上游的流量超过自身的负载能力时，能够拒绝溢出的请求。可以通过手动开关或者自动开关（监测异常流量行为），在应用前端挡住流量
* 监控设计：在设计阶段就要考虑监控的手段，可监控是保障系统能够稳定运行的关键。包括对业务逻辑的监控、应用进程的监控以及应用依赖的CPU、硬盘等系统资源的监控。每一个系统都需要做好这几个层面的监控
  - 问题可追踪：当系统出现问题时，能够定位请求的轨迹、每一步的请求信息等。分布式链路追踪系统即解决的此方面的问题
* 多活数据中心设计：若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用，为了容灾，从根本上保障应用的高可用性。需要构建多活的数据中心，以防止一个数据中心由于不可控因素出现故障后，引起整个系统的不可用
* 采用成熟技术：刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难，使用市面上主流、成熟、文档、支持资源多的技术，选择合适的而非最火的技术实现系统
* 资源隔离设计：应避免单一业务占用全部资源
* 故障隔离：将系统依赖的资源(线程、CPU)和服务隔离开来能够使得某个服务的故障不会影响其他服务的调用。通过线程池或者分散部署结点可以对故障进行隔离
* 架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题
* 非核心则购买：非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品
* 使用商用硬件：商用硬件能有效降低硬件故障的机率
* 快速迭代：系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险
* 无状态设计：服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态，API、接口等的设计不能有前后依赖关系，一个资源不受其他资源改动的影响。无状态的系统才能更好地进行扩展。如果非得有状态，则要么客户端管理状态，要么服务端用分布式缓存管理状态
  - 尽量减少共享状态:在一个对象中，相对于成员变量，更应该优先选择静态的无状态变量
* 避免过度设计：最简单的方案最容易实现和维护，也可以避免浪费资源。但方案中需要包括扩展

* 梯级存储：内存->SSD硬盘->传统硬盘->磁带，可以根据数据的重要性和生命周期对数据进行分级存储
* 缓存设计：隔离请求与后端逻辑、存储，是就近原则的一种机制。包括客户端缓存（预先下发资源）、Nginx缓存、本地缓存以及分布式缓存
* 异步设计：对于调用方不关注结果或者允许结果延时返回的接口，采用队列进行异步响应能够很大程度提高系统性能；调用其他服务的时候不去等待服务方返回结果直接返回，同样能够提升系统响应性能。异步队列也是解决分布式事务的常用手段
* 前瞻性设计：根据行业经验和预判，提前把可扩展性、后向兼容性设计好
* 水平扩展：相比起垂直扩展，能够通过堆机器解决问题是最优先考虑的问题，系统的负载能力也才能接近无限扩展。此外，基于云计算技术根据系统的负载自动调整容量能够在节省成本的同时保证服务的可用性
* 小步构建和发布：快速迭代项目，快速试错。不能有跨度时间过长的项目规划
* 自动化：打包、测试的自动化称为持续集成，部署的自动化称为持续部署。自动化机制是快速迭代和试错的基础保证
* 将“副作用(例如：打印到控制台、日志记录、更改全局状态、文件系统操作等)”局部化
* 架构关注点
  - 内聚与耦合、功能性、可变性、性能、容量
  - 生态系统、模块化、可构建性、产品化、安全性
  - 架构原则：分而治之
* 架构演进
  - 项目需求扩张，旧的架构不适应新的需求
  - 开发团队人员增加，协作要求变高
  - 新技术引入
  - 更高的软件质量要求
* 基本原则
  - KISS(Keep it simple,sutpid) ：保持每件事情都尽可能的简单。用最简单的解决方案来解决问题。Guide：简单即是复杂！拿你的代码来说，你想要写的简单且容易理解的话，你就需要花更多的时间去思考
  - YAGNI(You aren’t gonna need it)：不要去搞一些不需要的东西，需要的时候再搞吧。之前的时候，总是臆想觉得某个功能以后可能会用到，然后就顺手把它实现了，实际到了后面并没用上，反而造成了代码冗余
  - 爬，走，跑。换句话说就是先保证跑通，然后再优化变得更好，然后继续优化让其变得伟大。迭代着去做事情，敏捷开发的思路。对于每个功能点，创建里程碑（最大两周），然后去迭代
  - 创建稳定、高质量的产品的唯一方法就是自动化测试。所有的都可以自动化，当你设计时，不妨想想这一点。Guide：单侧还是很有必要的，但是没有一个恒定的标准说你应该怎么去做
  - 时刻要想投入产出比（ROI）。就是划得来不
  - 单一职责原则
  - 了解用户，然后基于此来平衡你需要做哪些事情。不要花了几个月时间做了一个 devops 用户界面，最后你发现那些人只喜欢命令行。此原则是原则 5 的一个具体表现。Guide:是否有站在用户的角度思考问题呢？是否是为了用新技术而用新技术？
  - 设计和测试一个功能，尽可能独立。当做设计时，应该想想这一条。从长远来看这能给你解决很多问题，否则功能只能等待系统其他所有的功能都就绪了才能测试，这显然很不好。有了这个原则， 你的版本将会更加的顺畅
  - 不要搞花哨的。我们都喜欢高端炫酷的设计。最后搞了很多功能和解决方案到架构中，然后这些东西根本不会被用到。Guide:简单点！说话的方式简单点！
* 功能选择
  - 原则 9：不可能预测到用户将会如何使用我们的产品。所以要拥抱 MVP（Minimal Viable Product），最小可运行版本。这个观点主要思想就是你挑几个很少的使用场景，然后把它搞出来，然后发布上线让用户使用，然后基于体验和用户反馈再决定下一步要做什么
  - 原则10：尽可能的做较少的功能。当有疑问的时候，就不要去做，甚至干掉。很多功能从来不会被使用。最多留个扩展点就够了
  - 原则 11：等到有人提出再说（除非是影响核心流程，否则就等到需要的时候再去做）
  - 原则 12：有时候你要有勇气和客户说不。这时候你需要找到一个更好的解决方案来去解决。记住亨利福特曾经说过的 ：”如果我问人们他们需要什么，他们会说我需要一匹速度更快的马”。记住：你是那个专家，你要去引导和领导。要去做正确的事情，而不是流行的事情。最终用户会感谢你为他们提供了汽车
* 服务端设计和并发
  - 原则 13：要知道一个 server 是如何运行的，从硬件到操作系统，直到编程语言。优化 IO 调用的数量是你通往最好架构的首选之路
  - 原则 14：要了解 Amdhal 同步定律。在线程之间共享可变数据会让你的程序变慢。只在必要的时候才去使用并发的数据结构，只在必须使用同步（synchronization）的时候才去使用同步。如果要用锁，也要确保尽可能少的时间去 hold 住锁。如果要在加锁后做一些事情，要确保自己在锁内会做哪些事情
  - 原则 15：如果你的设计是一个无阻塞且事件驱动的架构，那么千万不要阻塞线程或者在这些线程中做一些 IO 操作，如果你做了，你的系统会慢的像骡子一样
* 分布式系统
  - 原则 16：无状态的系统的是可扩展的和直接的。任何时候都要考虑这一点，不要搞个不可扩展的，有状态的东东出来，这是起码的。
  - 原则 17：保证消息只被传递一次，不管失败，这很难，除非你要在客户端和服务端都做控制。试着让你的系统更轻便（使用原则 18）。你要知道大部分的承诺 exactly-once-delivery 的系统都是做了精简的
  - 原则 18：实现一个操作尽可能的幂等。这样的话就比较好恢复，而且你还处于至少一次传递（at least once delivery）的状态
  - 原则 19：知道 CAP 理论。可扩展的事务（分布式事务）是很难的。如果可能的的话，尽可能的使用补偿机制。RDBMS 事务是无法扩展的
  - 原则 20：分布式一致性无法扩展，也无法进行组通信，也无法进行集群范围内的可靠通信。理想情况下最大的节点限制为 8 个节点
  - 原则 21：在分布式系统中，你永远无法避免延迟和失败
* 用户体验
  - 原则 22：要了解你的用户和清楚他们的目标。他们是新手、专家还是偶然的用户？他们了解计算机科学的程度。极客喜欢扩展点，开发者喜欢示例和脚本，而普通人则喜欢 UI
  - 原则 23：最好的产品是不需要产品手册的。Guide：这个是说产品易用。很多人觉得敏捷开发下不需要文档，实际上，一个系统即是在敏捷开发的情况下，有些必要的文档比如重
  - 原则 24：无法在两个选择中做决定的时候，请不要直接把这个问题通过提供配置选项的方式传递给用户。这样只能让用户更加的发懵。如果连专家都无法选择的情况下，交给一个比你了解的还少的人这样合适吗？最好的做法的是每次都找到一个可行的选项；次好的做法是自动的给出选项，第三好的做法是增加一个配置参数，然后设置一个合理的默认值
  - 原则 25：总是要为配置设置一个合理的默认值
  - 原则 26：设计不良的配置会造成一些困扰。应该总是为配置提供一些示例值
  - 原则 27：配置值必须是用户能够理解和直接填写的。比如：不能让用户填写最大缓存条目的数量，而是应该让用户填写可被用于缓存的最大内存
  - 原则 28：如果输入了未知的配置要抛出错误。永远不要悄悄的忽略。悄悄的忽略配置错误往往是找 bug 花了数小时的罪魁祸首
* 艰难的问题
  - 原则 29：梦想着新的编程语言就会变得简单和明了，但往往要想真正掌握会很难。不要轻易的去换编程语言
  - 原则 30：复杂的拖拉拽的界面是艰难的，不要去尝试这样的效果，除非你准备好了 10 人年的团队

## 评测

* Service-Level Agreement SLA 服务等级协议:系统服务提供者（Provider）对客户（Customer）的一个服务承诺。这是衡量一个大型分布式系统是否“健康”的常见方法。SLA 设定一些指标，来考核、衡量系统
  - 系统可用性：也就是常说的 4 个 9、5 个 9 指标
  - 准确性或错误率：可以简单理解为 错误请求数/全部请求数=错误率
  - 系统容量/吞吐量/预期负载：也就是常说的 QPS/TPS 等， 每秒可处理的查询数或事务数
  - 延迟或 RT 等：系统响应时间
* 真正架构难度，不是业务架构，而是支撑核心业务稳定运行的点点滴滴，以微服务为例来看：
  - 冗余部署是提高系统可用性唯一法宝。服务的冗余部署，是为了提升系统可用性。另外使用微服务架构，有个很重要目标，就是要无感知升级系统模块。汽车的备用轮胎也可以提升汽车可用性，但汽车爆胎后，需要换轮胎的时间，这个可用级别上不去。 而微服务，把功能拆分成小服务，可以通过技术手段，无感知的升级
    -服务治理都会包含服务监测、预警功能。当服务错误率达到一定阈值，很可以报警或开启限流、服务降级、熔断等策略，把影响降低到最小
  - 微服务架构中，通常会在在 gateway 层，甚至 service,dao 层设置限流措施。当流量大于预期时，开启防御手段。也有一些弹性扩容的设定，当流量大于阈值时，自动扩展服务，应对突发流量，这个过程甚至不用人工参与
  - 系统延迟或相应时间，也会在服务监测平台设置相应指标，超过阈值时，启动相关服务降级、限流、熔断等策略
    注：个人理解，其实微服务、K8s 等，很大一部分功能都是为了应对 SLA 的智能化扩展

## 手段

* 单机：高性能、高并发手段相关
  - 单机高性能手段：可以上网查询 C10k 问题，获取相关文章。把进程、线程、池、IO 多路复用相关知识点弄清楚
  - 分清楚 IO 密集型和 CPU 密集型场景：一般互联网应用多为 IO 密集型。但是类似：滴滴出行、股市量化投资、在线游戏之类，属于 IO 密集型和 CPU 密集型并存的场景，甚至对响应时间要求也很高。 幸好大多数 CPU 密集型应用也是多租户、区域独立性架构，容易扩展拆分
  - 程序访问存储介质或链路快慢： 程序肯定要与存储进行消息交换。一定明白，CPU 高速存储器、内存、SSD 硬盘、机械硬盘、同交换机网络、同机房网络、同城网络、同运营商网络等。细节展开很多内容，包含缓存、cdn、多机房...从细节编程到部署架构的知识点
* 集群：高性能、高并发相关
  - 负载均衡反向代理：其实把 nginx 了解就可以了。如果是初创小公司，基本使用云上 SLB 负载均衡(ServerLoadBalancer)就可以，如果需要自建机房，有专门运维负责这些工作，到时候补补 LVS、F5 相关技术即可
  - 服务无状态：以微服务为例来说，服务无状态会带来太多的好处，扩展冗余部署服务会很方便。不谈微服务，就说前后端分离，鉴权这块 token 的实现，其实根本目的也是把用户状态剥离出来，实现服务的无状态化。 （提个小插曲，估计老人才了解 j2ee EJB 规范，当初居然专门设计了一个 sessionBean 有状态的服务规范）
  - 任务（服务）拆分：可以理解为服务拆解、功能拆解。其实拆分准则很多，可以按照实际需求来权衡。比如：按照人头分、按照功能划分、按照数据库表划分、按照功能重要性划分、按照功能访问频度划分,不过，水平按照 gateway、逻辑层、数据层、存储层算基本规范了
  - 常用的语言及框架：了解语言特性，如 node 语言的快速开发、前后端语言一致带来的便利、多路复用回调的原生支持等；go 语言“goroutines”特性带来的编程便利；java 优秀的生态及开源框架；c++性能优势等。当然技术选型，跟团队及业务成熟度很大关系。
  - 缓存：分布式缓存是提升系统性能利器。基本掌握 Redis 即可，需要知晓 codis 和 redis 官方集群部署方式。
  - 消息队列：消息队列也是常用提升系统性能利器，如业务逻辑异步化、削峰、解耦等。熟悉 kafka、rocketMq 即可。
* 高可用手段（集群）： 高可用手段核心解决思路是冗余部署，同样的服务冗余多份，会带来服务出错通知、服务自动切换、容错等一系列问题。高可用的实现更有技术含量，现在微服务框架服务治理组件，很多在高可用上做创新突破。（高性能冗余部署为了扩展节点，带来更高的处理性能）
  - 服务无状态：当某个服务故障时，自动切换到新的服务，不用产生状态丢失等问题。
  - 调用方支持超时、重试配置：由于网络抖动等原因，某个服务可能某次调用不可用，调用方需要重试重新调用。当然超时是调用方通用遇到的故障之一，也会有在其它故障发生，然后发起重试的配置。
  - 被调用方需要幂等支持：显而易见，无论是重试、还是调用方自动切换到的新的服务， 被调用方服务幂等支持的必备的。
  - 服务状态监测：所有服务都可用，那是理想情况。当某个服务发生故障时，整个体系必须知道这个服务有问题了，重试调用多少次也不会成功了。按照微服务框架来说，需要两方知道这个信息：1、服务注册组件。2、服务上游调用方。当然报警让运维技术恢复是常规。
  - 服务状态通知：按照微服务架构，服务的状态 在注册中心都会体现。但是注册中心跟服务之间一般是通过心跳来检测的，有时间延时。 另外，服务调用方会缓存注册中心数据，其中就包含服务状态。  所以说，从注册中心获取服务状态，是有延时，可能会造成很多无效的请求。  高效的服务状态机制，很难组件化框架化，  所以这块需要高性能、较实时的自研通信机制或高性能集中存储机制保证。具体可以留言讨论或后续文章探讨。
  - 调用方智能路由：除了负载均衡以外，当调用方 A1 知晓下游服务 C1 故障后，可以自动切换到 C2 等服务上。 另外，通过服务状态通知机制，最好可以告诉 A2、A3，C1 服务故障了，你们别去尝试了。
  - 服务故障恢复有，状态通知机制：这部分就比较简单了。注册中心状态变化后，调用方会慢慢更新注册中心元数据，来获取最新状态。 当时，如果有更实时的消息机制，时效性会更高。
* 系统可靠性（牺牲少部分可容忍体验，降低问题到最低）
  - 服务（功能）分类：不管是微服务框架也好，单体框架也好，架构师必须对功能、服务进行分类。分类维度很多，比如：重要程度、qps 量级、是否可以降级停止等等。
  - 应用限流：对于一般规模的应用，在 gateway 层做即可，从源头保护整个应用。对于超大应用（个人没经验），我觉得架构会更加复杂，可能 gateway 会分为很多层或多个，甚至有业务中台，层次会更复杂。
  - 服务降级：服务是在服务分类的基础上的。比如：百度贴吧的发帖功能，信息流广告功能，紧急情况下是可以降级处理的。可以人工或自动执行。其实 限流也是一种特殊的服务降级。（服务可以是个功能、也可以是接口，就看团队内如何达成一致）
  - 接口熔断：熔断一般在接口方法级别，因为调用链路很长，容易引起调用雪崩。让某个接口方法出现问题，我们可以按照预定配置处理业务，快速返回预设结果，防止整个链路的奔溃。
  - 弹性扩容：弹性扩容是理想的智能运维，但是具体操作也做大厂才会做相关工作。例如新年红包业务，双十一电商业务，秒杀业务，明星结婚对新浪微博的影响等，这些可以预知或未知的突发流量，如果系统可以自动扩容，那将很是完美。其实很多当前 docker+k8s 的使用案例，还只是方便运维工作量，对弹性扩容这块实践感觉不是很好。
* 存储
  - 关系型数据库：传统的 mysql 数据需要掌握。如果做互联网业务，对分库分表肯定有需求，关注 newsql，如 tidb，可以避免分库分表的麻烦。
  - NoSql 存储：es、mongodb 至少掌握一个。笔者对 elasticsearch 还是比较看好，综合性 文档数据、列式存储、反向索引 都支持，社区生态也很不错。
  - 大数据数据库：强烈建议熟悉 hdfs+hbase+openTSDB。如果熟悉时序数据库 openTSDB 设计以后，对了解各个监控系统如 openfalcon 有很大的帮助。基本自研监控系统也难度不是特别大了。
  - 内存数据库：有些特殊应用使用内存数据会事半功倍。redis 提供丰富的数据结构及良好特性，并且有很多插件，巧妙使用可以降低业务代码复杂度。
  - 消息队列：消息队列也有存储机制，使用得当，也可以当成存储介质使用。例如：kappa 架构，rocketMq 事务消息支持等。
* 最佳实践：架构师研究商业化广告系统的架构，广告系统涵盖知识点很多
  - 高并发、高性能的广告引擎
  - 倒排索引的广告定向召回
  - 流计算计费系统
  - 批处理反作弊大数据处理系统
  - 大数据DMP用户设备画像系统
  - 点击率预测机器学习、深度学习方向
  - adx+ssp+dsp 之间跨公司、跨系统间通信调用
  - 频次控制等需要的缓存系统设计
  - 交易相关资金方面的处理等等
* 使用 DDD，将复杂问题转化为繁杂问题
  - 提炼问题域
  - 找到问题域中的第一个核心子域
  - 对第一个核心子域进行战略设计
  - 完善统一语言
  - 视情况重复 2 ~ 5
* 使用 TDD，将繁杂问题转化为简单问题
  - 拆解问题（Tasking）
  - 红-绿-重构代码
  - 重构模型以加深理解
* 在简单问题中，使用最佳实践

## 分层

* 特点
  - 方便后续代码进行维护扩展
  - 分层效果需要让整个团队都接受
  - 各层职责边界清晰
* MVC
  - controller:此层只负责功能的调度(更适合承担角色是负责对 HTTP 请求进行路由)，参数的控制，结果的输出
  - service，此层负责业务逻辑相关的开发BLL(业务逻辑层):类内聚，OOP的抽象
    + 属性
    + 业务逻辑
  - DAO(数据接入层)，此层负责与数据的交互,ORM接入数据对象
  - entity, 此层定义为数据表的一个映射
* 一般分层
  - Presentation layer 表示层（也就是UI层）
  - Application layer 应用层（也就是服务层）
  - Business logic layer 业务逻辑层（也就是领域层）
  - Data access layer 数据访问层（也就是数据持久层）
* CQRS Command Query Responsibility Segration
  - 把 CRUD 系统拆分为两部分,两边可以用不同的架构实现，以实现CQ两端（即Command Side，简称C端；Query Side，简称Q端）分别优化
    + 命令（Command）处理
    + 查询（Query）处理
  - 实现方式
    + CQ 两端数据库共享，只是在上层代码上分离:这样做的好处是可以让代码读写分离，更容易维护，而且不存在 CQ 两端的数据一致性问题， 因为是共享一个数据库的。这种架构是非常实用的
    + CQ 两端不仅代码分离，数据库也分离，然后Q端数据由C端同步过来:
      * 如果需要 CQ 两端的强一致性，则需要用同步
      * 如果能接受 CQ 两端数据的最终一致性，则可以使用异步。
      * C端可以采用Event Sourcing（简称ES）模式，所有C端的最新数据全部用 Domain Event 表达即可
      * 查询显示用的数据，则从Q端的 ReadDB（关系型数据库）查询即可
* 阿里分层
  - 开放接口层：可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。
  - 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。
  - Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。
    + 轻业务逻辑，参数校验，异常兜底。通常这种接口可以轻易更换接口类型，所以业务逻辑必须要轻，甚至不做具体逻辑。
  - Service 层：相对具体的业务逻辑服务层。
    + 业务层，复用性较低，这里推荐每一个controller方法都得对应一个service,不要把业务编排放在controller中去做，为什么呢？如果我们把业务编排放在controller层去做的话，如果以后我们要接入thrift,我们这里又需要把业务编排在做一次，这样会导致我们每接入一个入口层这个代码都得重新复制一份如下图所示
  - Manager 层：通用业务处理层，可以是单个服务的，比如cache,mq等等，当然也可以是复合的，当你需要调用多个Mannager的时候，这个可以合为一个Mannager它有如下特征:
    + 对第三方平台封装的层，预处理返回结果及转化异常信息
    + 对Service层通用能力的下沉，如缓存方案、中间件通用处理
    + 与DAO层交互，对多个DAO的组合复用
  - DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。
  - 原则
    + 允许Service/Manager可以操作数据领域模型，对于这个层级来说，本来自己做的工作也是做的是业务逻辑处理和数据组装。
    + Controller/TService层的领域模型不允许传入DAO层，这样就不符合职责划分了。
    + 同理，不允许DAO层的数据传入到Controller/TService。
* 领域模型转换：每一个层基本都自己对应的领域模型
  - DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。
  - DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。
  - BO（Business Object）：业务对象。由Service层输出的封装业务逻辑的对象。
  - AO（Application Object）：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
  - VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。
  - Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。
  - 边界条件
  - 输入复杂性与不可预测
* 方法
  - 垂直扩展(Scale Up)：提升单机处理能力。垂直扩展的方式又有两种：
    + 增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G；如果预算不是问题，强烈建议使用“增强单机硬件性能”的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最快的方法。
    + 提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；
    + 单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展。
  - 水平扩展（Scale Out）：只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，如何在架构各层进行可水平扩展的设计，以及互联网公司架构各层常见的水平扩展实践。

![Alt text](../_static/layer.png "Optional title")

## 能力

* 以工程思维全面理解业务
* 基于模型和基础模式抽象简
* 提出恰当可行整体解决方案
* 在限定资源范围完成明确目
* 满足业务需求且保证系统质
* 在可预见的周期内具备扩展
* 并在系统生命周期内持续演
* 逻辑思维能力很强，思路清晰，有洞察力，善于抓重点
* 善于抽象，形成自己的结构化认知框架，有大局观
* 解构，拆分业务、系统模块和代码
* 发现问题，思考解决，设计取舍，重构迭代，协作传道，响应支持，持续学习，积累提高
* 抽象能力:就是关注本质，忽略细节的能力。经常做架构评审，我的团队做项目架构的时候，让我去做评审，一个项目的架构设计我就关注两样东西，一个是数据模型 (或称领域模型)，另外一个是接口模型。通过数据库表、表结构、API 接口模型，就能看出来抽象能力如何
  - 对某种事物进行简化表示或描述的过程，抽象让关注要素，隐藏额外细节。帮助我们从大处着眼（get our mind about big picture），隐藏细节（temporarily hide details）。抽象能力的强弱，直接决定我们所能解决问题的复杂性和规模大小。模块化分解
  - 整体的抽象：自顶向下的分治设计；子模块分解：自底向上的组合过程
  - 写代码会保持抽象层次的一致性，代码读起来像讲故事，比较清晰易于理解；而没有经验的程序员会有明显的抽象层次跳跃问题，代码读起来就比较累，这个是抽象能力不足造成
* 递归能力:面试中一定会要求面试者写递归算法，有没有掌握递归，对解决问题的能力相差是很大的。比如编译器解析器、代码生成器、序列化算法都涉及到递归，没有递归思维的程序员，就搞不定这个层面的工作。
* 分治(分而治之):大问题先分解为小问题，依次解决小问题，再合并成解决大问题。是和数据结构算法相关的
  - 分治(divide and combine或者split and merge)：对于一个无法一次解决的大问题，我们会先把大问题分解成若干个子问题，如果子问题还无法直接解决，则继续分解成子子问题，直到可以直接解决的程度，这个是分解(divide)的过程；然后将子子问题的解组合拼装成子问题的解，再将子问题的解组合拼装成原问题的解，这个是组合(combine)的过程。
  - 面试题：给你一台8G内存/500G磁盘空间的普通电脑，如何对一个100G的大文件进行排序？假定文件中都是字符串记录，一行约100个字符。
    + 100G的大文件肯定无法一次加载到内存直接排序，所以需要先切分成若干小问题来解决。
    + 那么8G内存的计算机一次大概能排多大的数据量，可以在有限的时间内排完呢？也就是100G的大文件要怎么切法，切成多少份比较合适？这个是考察候选人的时间空间复杂度估算能力，需要一定的计算机组织和算法功底，也需要一定实战经验和sense。实际上8G内存的话，操作系统要用掉一部分，如果用Java开发排序程序，大致JVM可用2~4G内存，基于一般的经验值，一次排1G左右的数据应该没有问题
    + 所以100G的文件需要先切分成100份，每份1G，这样每个子文件可以直接加载到内存进行排序。对于1G数据量的字符串排序，采用Java里头提供的快速排序算法是比较合适的。
    + 把已经解决的子问题组合起来，合并成我们需要的最终结果文件。这个时候该采用什么算法呢？这里考察候选人对外排序和归并排序算法的掌握程度，我们可以将100个排好序的文件进行两两归并排序，这样不断重复，我们就会得到50个排好序的文件，每个大小是2G。然后再两两归并，不断重复，直到最后两个文件归并成目标文件，这个文件就是100G并且是排好序的。因为是外排序+归并排序，每次只需要读取当前索引指向的文件记录到内存，进行比较，小的那个输出到目标文件，内存占用极少。另外，上面的算法是两路归并，也可以采用多路归并，甚至是采用堆排序进行优化，但是总体分治思路没有变化。
    + 考察候选人的分治思维之外，还考察对各种排序算法（快排，外排序，归并排序，堆排序）的理解，计算的时间空间复杂度估算，计算机的内外存特性和组织，文件操作等等
  - 递归也是一种特殊的分治技术
* 分层：把整个系统划分成若干个层次，每一层专注解决某个领域的问题，并向上提供服务。有些层次是纵向的，它贯穿所有其它层次，称为共享层。比如下图操作系统与TCP/IP协议栈
* 演化:架构既是设计出来的，同时也是演化出来的，对于互联网系统，基本上可以说是三分设计，七分演化，而且是在设计中演化，在演化中设计，一个不断迭代的过程。
  - 除了要利用自身的架构设计能力
  - 也要学会借助用户反馈和进化的力量，推动架构的持续演进
  - 能够不断应对环境变化的系统，才是有生命力的系统，架构的好坏，很大部分取决于它应对变化的灵活性。所以具有演化式思维的架构师，能够在一开始设计时就考虑到后续架构的演化特性，并且将灵活应
  - 设计式思维和演化式思维的差异
    + 一开始就直奔微服务架构，其实背后体现的是设计式架构的思维，认为架构师可以完全设计整个系统和它的演化方向。马丁认为这种做法风险非常高，一个是成本高昂，另外一个是刚开始架构师对业务域理解不深，无法清晰划分领域边界，开发出来的系统很可能无法满足用户需求。
    + 从单块架构开始，随着架构师对业务域理解的不断深入，也随着业务和团队规模的不断扩大，渐进式地把单块架构拆分成微服务架构的思路，这就是演化式架构的思维。如果你观察现实世界中一些互联网公司（例如eBay，阿里，Netflix等等）的系统架构，大部分走得都是演化式架构的路线。
* 能力培养
  - 良好的架构设计思维的培养，离不开工作中大量高质量项目的实战锻炼，然后是平时的学习、思考和提炼总结。
  - 基本的架构设计思维，其实在我们大学计算机课程（比如数据结构和算法）中可以找到影子。所以大学教育其实非常重要，基本的架构设计思维在那个时候就已经埋下种子，后面工程实践中进一步消化和应用，随着经验的积累，我们能够解决的问题域复杂性和规模逐渐变大
  - 架构师的成长高度和他大学期间的思维习惯的养成关系密切，推荐参考美国Berkeley大学的数据结构课程CS61B[附录8.1]进行学习，对建立抽象编程思维非常有帮助

* 技术和业务两边都要有一定熟悉
  - 软件过程、系统分析与设计、架构设计、设计模式、Java 语言等内容，并研读了敏捷开发、领域驱动设计、工作流分析
  - 补基础知识，更重要当然是实践，珍惜每一个设计任务，珍惜每一次与业务人员、技术人员的沟通机会，让他们来检验自己的理解和方法，逐渐形成自己的体系，把零散得来的知识最终融合成体系化的设计与表达。多写文章，提升思维逻辑性，让经验固化成为知识，当然，固化不要僵化，业务架构师应该是很善于应对变化的
* 核心是架构，形成业务的架构。架构的定义是根据企业战略，对企业能力进行整体规划并将其传导到技术实现端的结构化分析方法。这其中有三个关键词，整体规划、结构化分析和传导。业务架构师的核心能力是将复杂的业务体系进行整体性的结构化设计，无论对 IT 技术或者业务有多熟悉，没有这一项能力是做不好业务架构师的。此外，由于有“传导”这个职责，这种结构化设计需要跟 IT 设计有机结合，因此，学习系统分析与设计知识就变得很重要，熟悉技术的读者能够理解，这些知识虽然偏技术，却与语言能力无关，可以脱离语言去学习其设计思维。
* 要多了解软件过程。其实很多技术出身的读者对软件过程也只是了解个大概，日常工作中也不很注重软件过程管理，忽视了这一点，就无法了解、掌控整个开发过程。开发的目的是为了高质量的交付，而非仅是完成任务。如果不注重软件过程，连自己的专业领域都无法持续优化，那又如何跨出一步去做个好的业务架构师？对业务出身的读者来讲，学习软件过程知识就更为重要了，因为你必须了解你的下游是如何运作的，业务架构是桥梁，业务架构师的作用不是“铁路警察各管一段儿”，而是要将业务和技术衔接起来
* 要学习流程优化等流程管理知识。业务架构通常不是为了现状进行设计，会涉及到整合、优化现有流程，需要掌握一定的流程优化知识，这样业务架构师才能更好地为业务提供有价值的建议。但是笔者认为，流程优化虽然很重要，却不是专业书籍可以提供多少帮助的，还是比较依赖实操。学习下经典理论，再学习下 BPMN 之类的工具知识就可以，多注意实战，这部分切记不要“迷信”书籍，因为流程优化是没有标准可言的，倒是多总结自己的心得更重要。
* 学习建模技术。业务架构的结构化设计通常是通过模型方式来展现的，因此，多学习不同的建模方法，流程的、数据的，甚至 DDD 的，互相取长补短，提升自己的模型表达能力，使设计结果能够更好地展现出来。
* 关于跨界的注意点。从业务出发想做业务架构师的读者至少应该学习一门主流的计算机语言，不需要达到很精深的程度，主要是理解技术落地的实现方式和技术人员的思维习惯，学习一门计算机语言，才能帮助你完成跨界转型，哪怕后边你又把它忘了（不经常写代码自然容易忘）；从技术出发想做业务架构师的读者至少要先深入地学习一个业务领域，再去跨领域搞企业级业务架构，就像所谓的“T”人才，先有垂直的一竖，再做拓展的一横
* 日常多养成从整体出发看问题的习惯。说夸张点儿，前看十年、后看十年地去分析问题，包括看书也是，看历史书、军事书，乃至花鸟鱼虫，看什么书、学什么知识都养成全面分析的习惯，时刻注意整体和部分的关系，架构处理的就是结构和关系，日常生活、工作的方方面面都会用到架构分析能力，不是仅有系统设计会用，养成了这种习惯也会让你的设计由“实现”变成“涌现”

![操作系统](../_static/os.png "操作系统")
![操作系统](../_static/tcp_ip.gif "操作系统")
![大自然中递归结构](../_static/recursion1.png "大自然中递归结构")
![大自然中递归结构](../_static/recursion2.jpg "大自然中递归结构")

## 不同视角切入架构设计

* 使用目标驱动的行动框架。明确我们要去哪里？知道架构设计的目的、阶段性目标， 才能有针对性的少走弯路。
* 怎么才能知道现在在哪？明白评价架构、系统的常见评价体系，才能针对目标，一步一个台阶的走下去。评价指标通常是与数据相关的，但是容易评估的目的，往往是简单容易实现或案例很多的。
* 无论我们面对的需求或目标多么高大，路要一步一步走，饭要一口一口吃。零零散散各个目标指标，只能有侧重、有优先不断迭代、夯实、拔高的达到目标。
* 如何理解大厂、书籍、国外传播的最佳实践呢？ 我们需要明白，任何最佳都是迭代出来的，而不是一蹴而就的。
* 针对架构设计目的，常用的有哪些手段呢？我们如何建立自己的武器库，常见的解决问题的手段呢，通过 5W1H 来了解梳理。
* 架构师岗位是与其他岗位高度协同的岗位，了解业务、了解其它岗位、协同人职责视角很重要。多元视角不光可以让自己更深刻理解架构本身，还可以了解业务、了解场景，更有效的协同工作。

## [protobuf 为经络，gRPC为骨架](https://mp.weixin.qq.com/s/jMrkrLpPxzJA4GsHFHKs-Q)

* protobuf 强迫不得不先考虑好数据结构再写代码；而gRPC 强迫不得不先定义好接口再写代码。而这两部分都完成并且得到充分的代码审查后，后续的实现再差也不会偏离大方向。
* 以 protobuf 为主的数据结构定义方式，即在一个项目（或者一个子服务）开始时，先集中精力用 protobuf 定义项目中所有可以被 protobuf 支持的简单类型定义的数据结构
  - 出错码:一个系统，清晰可追踪的出错码是系统在演进过程中能够快速排错的关键之一（之二是日志）.列表不必全，随用随更新.之后可以为其实现 error::Error — 这就是见证奇迹的地方：通过一套定义实现了内部和外部出错码的统一
  - 枚举类型:可以用 enum 表述。也是随用随加.在 rust 下，为了方便 prost 编译出的 protobuf 的枚举类型的各种应用，会在 build.rs 里加一些小的 hack.
    + serde 和 strum 相关的宏都是 protobuf 在编译过程中被额外添上去的。通过这样的处理，同一套枚举可以被用在各种场景：数据库（整数），输入输出（字符串），grpc及内部逻辑
  - 配置文件：个人偏好 toml，兼具可读性和灵活性。对于配置文件的每个部分，会定义这样的 proto
    + 在生成的 rust 代码中加上 serde 相关的宏（其它语言处理 protobuf 写的配置思路也类似），那么，在 proto 里定义的类型和下面的文件就可以相互转换，非常方便
    + 项目一开始先定义好配置文件的样子是非常有必要的，尤其是对于单元测试
    + 配置文件的结构可以在开发功能的过程中逐渐完善
    + 很多数据结构的初始化可以直接从配置文件里拿
    + 测试不再需要很多乱七八糟的常量定义。而在 protobuf 里定义配置文件的结构还有一个额外的好处，就是配置可以通过网络直接以二进制的形式传递，省却了中间序列化和反序列化的过程
  - 业务相关数据结构：在 protobuf 里定义，好处有二：1) 集中 2) 便于演进
  - 一个项目大概有50%-70% 的数据结构都可以被集中在 proto 文件中定义；我们只需要合理地控制生成的代码的命名空间，就可以很方便地引用所有的结构。而那些不能用 protobuf 定义的数据结构多数是和外部依赖相关
* 用 gRPC 串联一切
  - protobuf 并不需要和 gRPC 联合使用。即便项目本身和 gRPC 无关，也可以用 protobuf 来定义上述所列的数据结构
  - 一个后端的服务和外界打交道，兑现服务的承诺，而这个打交道的过程， gRPC 是非常完美的，承上启下的选择
  - 优点：
    + 服务的主要数据结构集中管理了，而服务对外的接口也能通过 gRPC 被集中管理起来，并且在需要的时候可以无缝升级
    + 会强迫用一个更好的结构来处理所面临的问题
  - protobuf 和 gRPC 作为一门单独的可扩展的语言的价值就体现出来：可以通过一些 annotation，描述服务可以如何被编译成 REST ←→ gRPC 的 proxy，这样，只需要写一份代码，就可以同时支持 REST API 和 gRPC
  - 因为 protobuf 和 gRPC 的强类型，还很容易自动生成 swagger 文档，并在 swagger 里完成浏览器 → proxy → gRPC 的服务调用

```
enum ErrorCode {
  // unknown error
  UNKOWN = 0;
  // not found
  NOT_FOUND = 1;
  // already exists
  ALREADY_EXISTS = 2;
  ...
}

/// supported platforms
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    strum_macros::EnumIter,
    strum_macros::EnumString,
    strum_macros::Display,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum Platform {
    Ios = 0,
    Android = 1,
    Web = 2,
}


// doorman service config
message DoormanConfig {
  // gRPC port
  uint32 grpc_port = 1;
  // websocket port
  uint32 wss_port = 2;
}

// facebook auth configuration
message FacebookConfig {
  string base_url = 1;
  string auth_url = 2;
  string avatar_url = 3;
}

// guardian service config
message GuardianConfig {
  // auth token secret
  string token_secret = 1;
  // auth db conn str
  string conn_str = 2;
  // auth token expiration
  uint32 expiring_days = 3;
  // facebook configuration
  FacebookConfig facebook = 4;
}
[doorman]
grpc_port = 8443
wss_port = 8480

[guardian]
token_secret = "c3VwZXJzZWNyZXQK"
conn_str = "postgres://postgres:postgres@localhost/aurora_test"
expiring_days = 14

[guardian.facebook]
base_url = "http://localhost:1234"
auth_url = "me?fields=id,first_name,last_name,email,gender,birthday&access_token="
avatar_url = "picture?type=square"

service UserService {
  // user signin
  rpc Signin(RequestSigninOrRegister) returns (ResponseSigninOrRegister) {
    option (google.api.http) = {
      post : "/api/v1/users/signin"
      body : "*"
    };
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
      summary : "User signin"
      description : "Sign in a user by using an auth provider"
      tags : "Users"
    };
  }
  // user resets password
  rpc ResetPassword(RequestResetPassword) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post : "/api/v1/users/reset_password"
      body : "*"
    };
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
      summary : "User reset password"
      description : "Reset password for users. For first time setting "
                    "password, old password should be empty string"
      tags : "Users"
      security : {
        security_requirement : {
          key : "ApiKey";
          value : {}
        }
      }
    };
  }
}
```

## C/S

* 二将军问题:失败结果有两种可能
  - 去向出问题
  - 操作成功，回路出问题
* 失败重复请求，接收方的幂等性

## 《架构整洁之道》

* 依赖倒置（DIP）本质上是一种解耦，解耦的目的是实现组件化的独立部署和独立开发能力
* 所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。如果变量永远不会被更改，那就不可能产生竞争或并发更新问题。如果锁状态是不可变的，那就永远不会产生死锁问题。所以架构师要做好可变性的隔离，区分出可变组件和不可变组件，尽可能的将处理逻辑归于不可变组件
* 软件构建中层结构的主要目标是：第一、使软件可容忍被改动；第二、使软件更容易被理解；第三、构建可在多个系统中复用的组件
* SRP是康威定律的一个推论，即软件应与组织息息相关，每一个软件模块应该只对某一类行为者负责。单一职责原则放到组件层面就是共同闭包，即我们应该将会同时修改，会以同样目的而被修改的类整合成一个组件
* OCP是指当新增功能时可以通过增加新代码而非修改旧代码来实现
* 软件复用的最小粒度应该等同于软件发布的最小粒度。PS：有些研发组织以系统的形式发布软件，却期望各个系统去共享使用通用的功能，最后只能是一团糟
* 不要依赖不需要用到的东西，换言之，在设计组件时，应考虑这些类是被共同复用的吗？PS：难
* 不要出现依赖环，否则会影响开发效率。依赖环的消除可以使用依赖倒置来解决
* 组件是不可能从上到下被设计出来，因为组件体现的不仅是业务功能而是构建性、维护性、依赖关系的地图。PS:很反直觉，有待体验
* 不稳地的组件可以依赖稳定的组件，而不能让稳定的组件依赖不稳定的组件。一个组件的抽象化程度应该与其稳定性保持一致，就是说稳定的应该抽象，否则无法满足开闭原则。不稳定的应该包含实现代码，这样才方便修改
* 软件架构的终极目标是最大化程序员的生产力，同时最小化系统的总运营成本
  - 好的软件架构应该是团队的组织架构相适应，方便开发团队开发
  - 好的软件架构要考虑到方便部署
  - 好的软件架构应该使开发人员对软件运行过程一目了然
  - 好的软件架构应该便于维护
  - 好的软件架构应该保留更多的（有意义的）可选性
* 一个系统在水平分层上比较常见的方式是：UI界面、应用独有的业务逻辑、领域普适的业务逻辑、数据库
* 划分边界的目的是方便我们尽量将一些决策延后进行
* 计算机程序从本质上说就是一组仔细描述如何将输入转化为输出的策略语句的集合。软件架构设计的工作重点之一就是将这些策略彼此分里，然后将他们按照变更的方式进行重新分组。变更原因、时间和层次相同的策略应该被分到同一个组件中
* 一种策略距离系统的I/O越远，它所属的层次就越高。高层次的策略不应该依赖于低层次的策略。PS:有道理
* 业务逻辑是与技术无关的，是现实中某一项业务的一部分。业务实体就是业务逻辑与业务数据的组合
* 架构设计的核心目标：满足用例，并能将它们与周边的因素隔离
* 整洁架构：越内层层次越高。外层圆代表的是机制，内层圆代表的是策略。源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。PS:这就是整本书的核心了，也是罗伯特老爷子的核心主张。在这个框架中，业务实体应该是最不容易发生变动的
* 每个系统架构的边界处，都应该多使用谦卑对象模式，即只发挥自己的桥梁和通信作用，并不从中干预信息的传输

![Alt text](../_static/tidy_arthctect.png "Optional title")

## 图书

* 《恰如其分的软件架构：风险驱动的设计方法》
* 《面向模式的软件架构（卷 1）：模式系统》
* 《程序员必读之软件架构》
* 《架构实战：软件架构设计的过程》
* 软件架构设计
* 《前端架构：从入门到微前端》
* 《系统架构:复杂系统的产品设计与开发》
* 《[大型网站技术架构：核心原理与案例分析](https://book.douban.com/subject/25723064/)》
* 架构设计方面
  - 《系统分析与设计》（Kenneth E.Kendall ，Julie E. Kendall 著）
  - 《设计原本》（Fredrick P.Brooks，Jr. 著）
  - 《软件系统架构 - 使用视点和视角与利益相关者合作》（Nick Rozanski，Eoin woods 著）
  - 《架构之美》（Diomidis Spenellis & Georgios Gousios 著）
  - 《实现领域驱动设计》（Vaughn Vemon 著）
  - 《微服务设计》（Sam Newman 著）
  - 《企业 IT 架构转型之道》（钟华 著）
* 软件过程方面
  - 《软件工程 - 实践者的研究方法》（Roger S.Pressman 著）
  - 《软件工程》（Ian Sommerville 著）
  - 敏捷软件开发：原则
  - 《模式与实践》（Robert C.Martin）
  - 《Scrum 敏捷软件开发》（Mike Cohn 著）
* 流程优化:除了流程管理层面的技术知识外，更重要的可能来自于管理学，不妨多读读管理类书籍，拓宽思路，再考虑具体的流程优化
  - 《目标》（Eliyahu M.Goidratt 著）
  - 《凤凰项目 - 一个 IT 运维的传奇故事》（Gene Kim, Kevin Behr & George Spafford 著）
* 《架构即未来》
* 《[微服务设计](https://www.amazon.cn/gp/product/B01ER75V6O)》
* 《[大数据日知录](https://www.amazon.cn/gp/product/B00NGW4EAG)》
* 《[企业应用架构模式 Patterns of Enterprise Application Architecture](https://www.amazon.cn/gp/product/B003LBSRDM)》 Martin Fowler
* 《[Web性能权威指南](https://www.amazon.cn/gp/product/B00JMKWHFU)》
* 《[SRE：Google运维解密](https://www.amazon.cn/gp/product/B01M0EHQ43)》
* 《[发布！软件的设计与部署](https://www.amazon.cn/gp/product/B0153178XM)》
* 《[高扩展性网站的 50 条原则](https://www.amazon.cn/gp/product/B01HZFHQQI)》
* 《[大型网站技术架构:核心原理与案例分析](https://www.amazon.cn/gp/product/B00F3Z26G8)》
* 《[恰如其分的软件架构：风险驱动的设计方法](https://www.amazon.cn/gp/product/B00EP6TGAU)》
* 《[软件系统架构：使用视点和视角与利益相关者合作（第2版）](https://www.amazon.cn/gp/product/B00CMMUXC4)》
* 《图解服务器端网络架构》
* 《大型分布式网站架构设计与实践》
* 《分析模式》
* The Performance of Open Source Applications
* The Architecture of Open Source Applications, Volume I
* The Architecture of Open Source Applications, Volume II

## 实例

* [COLA](https://github.com/alibaba/COLA):Clean Object-oriented & Layered Architecture

## 参考

* [architect-awesome](https://github.com/xingshaocheng/architect-awesome)
* [awesome-architecture](https://github.com/toutiaoio/awesome-architecture):架构师技术图谱
* [system-design-primer](https://github.com/donnemartin/system-design-primer):Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.
* [architecture.of.internet-product](https://github.com/davideuler/architecture.of.internet-product):互联网公司技术架构，微信/淘宝/微博/腾讯/阿里/美团点评/百度/Google/Facebook/Amazon/eBay的架构
* [500lines](https://github.com/aosabook/500lines):source for the book 500 Lines or Less
* [awesome-design-systems](https://github.com/alexpate/awesome-design-systems):💅🏻 ⚒ A collection of awesome design systems
* [from_coder_to_expert](https://github.com/0voice/from_coder_to_expert):2019年最新总结，从程序员到CTO，从专业走向卓越，分享大牛企业内部pdf与PPT
* [awesome-scalability](https://github.com/binhnguyennus/awesome-scalability):An updated and curated list of selected readings to illustrate Scalability, Availability, and Stability Design Patterns in Back-end Development.
* [fast](https://github.com/microsoft/fast):The adaptive interface system for modern web experiences. <https://www.fast.design/>

* [“构建”世界的能力-架构能力](https://mp.weixin.qq.com/s/Qw8TEIssMwrE9l2Y8BzjaA)
* [最小可用架构](https://mp.weixin.qq.com/s/rZWxtVyJjgiUBPeY5gPqOA)
* [百万年薪架构师是如何炼成的？](https://mp.weixin.qq.com/s/D8-fdrJzggAFH-UbsLmjew)
* [优秀架构师必须掌握的架构思维](http://www.infoq.com/cn/articles/architecture-thought)
* [Software Architecture is Overrated, Clear and Simple Design is Underrated](https://blog.pragmaticengineer.com/software-architecture-is-overrated/)
