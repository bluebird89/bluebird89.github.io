# 设计模式

* 在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。四位作者合称 GOF（四人帮，全拼 Gang of Four）。所提出的设计模式主要是基于以下面向对象设计原则
  - 对接口而不对实现编程
  - 优先使用对象组合而不是继承
* 在特定上下文下对于普遍出现问题的可重用解决方案
* 模式是对某情景下，针对某种问题的某种解决方案,而一个设计模式是用来解决一个经常出现的设计问题的经验方法
* 每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个周围不断重复发生的问题，以及该问题的核心解决方案
* 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
* 缺点
  - 设计模式都是从很多项目中总结出的通用解决方案，从具体的实现中总结出抽象的模式相对比较简单，但是想要将抽象的模式套用到场景中却非常困难,如果没有足够的经验或者思考只会做出拙劣的设计。抽象的理论和模式能够起到指导的作用，但是真正让设计融入系统的还是工程师的丰富经验和深入思考
    + 多实例部署和异地多活都是能够避免单点故障的方法，然而实现这些方案需要考虑非常多的细节，这些细节都是在理论中缺失的，是需要通过经验和思考来补齐的，例如：部署多个实例之后，我们是不是还需要考虑服务注册、服务发现以及负载均衡的路由策略；异地多活是不是也要考虑机房之间的网络延迟、专用网络通道的搭建以及数据不一致的问题，这些实现细节在总结成规律抽象的理论时基本都消失了
  - 清楚地知道设计模式的局限性以及待解决问题的上下文，才能做出好的设计 If all you have is a hammer, everything looks like a nail! 6 - Charlie Munger
    + 今天熟悉的大多数编程语言都是在上世纪 80 ~ 90 年代诞生的，大多数的语言都是面向对象语言，而书中介绍的设计模式也都是在使用面向对象语言的项目中总结的
    + 今天的编程语言已经变得越来越复杂，多数语言都同时支持多种编程范式 — 面向对象、函数式编程等，在应用书中的设计模式时，我们需要充分考虑到其解决的关键问题以及我们手中的编程语言是否有更好的实现方式
  - 面向对象语言可能具有不同的特性，同一模式会有不同的实现方案：Objective-C 语言就使用键值观测机制（Key-Value Observing）实现观察者模式，它的实现与书中提供的观察者模式完全不同
    + 实现模式的方式不同会导致我们在运用时会遇到诸多问题，不同面向对象语言对封装、抽象和多态的支持也不同
  - 多种编程范式
    + 函数式编程范式
* 通过看书来学习软件设计几乎是一个不可能完成的任务，作者认为学习如何为程序编写单元测试对学习系统设计极其重要，提升项目单元测试覆盖率的过程会让我们思考如何写出更利于测试的代码，虽然软件工程中没有银弹，但是单元测试不是银弹可能也所差无几了。
* 学习软件设计就要去真正优秀的开源项目学习顶层设计和底层实现并在项目中不断实践，在最后我们会发现系统中到处都是设计和模式

## 原则

* 高内聚低耦合
  - 内聚：从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系
    + 一个模块（类、函数）应该专注于一件事情，提供单一功能，避免编写万用函数、巨类
  - 耦合：软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度
    + 模块之间应减少依赖、降低耦合度，这样在一个模块发生变化时，才不会引起广泛的连锁反应，从而提高系统的稳定性
  - 设计类的时候要最小化接口数量，把承担内部实现作用的成员函数私有化
  - 模块之间只通过接口通信，接口应尽量稳定，且数量要少，要符合最小知识原则，不要跟陌生人说话，这样做最终目的是为了隔离
* 复用
  - 类继承
    + 扩充基类的功能
    + 改写被复用的基类实现
    + 类继承是在编译时刻被静态确定的，父子类之间是如此紧密的依赖关系，以至于父类的任何变化常导致子类发生变化
  - 对象组合
    + 可以获得被组合对象的引用而在运行时刻动态变化
    + 可以要求对象之间遵守约定接口，而不破坏封装性
  - 组合优先于继承：继承和组合相辅相成，设计者往往过度使用继承，但依赖于对象组合的设计往往有更好的复用性
* 开闭原则：解决扩展性问题，对扩展开放，对修改封闭
* 针对接口编程，而不是针对实现编程
* 关键在于多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上
  - 接口可以理解为一个动作，而动作的具体实现则不用确定

* 单一职责原则(Single Responsibility Principle, SRP)： There should never be more than one reason for a class to change. 做到类只承担单一职责(最细粒度),尽可能地降低类变更的可能性，不同职责要分开单独定义。其实这一原则不仅仅适用于类，还适用于接口以及方法的设计
  - 类将来可能需要修改，且修改原因都能归属到一类
* 开闭原则(Open-Closed Principle, OCP)： Softeware entities like classes,modules and functions should be open for extension but closed for modifications. 一个软件实体如类、模块和函数，应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。比如参数类型、引用对象尽量使用接口或者抽象类，而不是具体实现类；
* 依赖倒转原则(Dependence Inversion Principle, DIP)： High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. 依赖多出现在方法参数中。高层模块不应该依赖低层模块(具体实现)，以防止一旦低层模块(具体实现)发生变化，将引起高层模块不必要的改变，同时高层模块之上可能有更高层的模块存在，因此两者都应该依赖于抽象。抽象不依赖具体实现细节，而让具体实现细节依赖抽象。抽象不变，具体实现细节改变可以使影响最小化，也就是要针对接口编程。这一条与里氏代换原则结合起来更容易理解，也可以看出这些原则并不应该被孤立地运用于系统设计中，而应该协同配合起来运用；
* 里氏代换原则(Liskov Substitution Principle, LSP)： Functions that use pointers or referrnces to base classes must be able to use objects of derived classes without knowing it. 任何基类可以出现的地方，透明地使用其子类的对象，且必须遵从基类所有规则定义，但反过来说，除了扩展基类，又为什么要违背基类规则定义呢？这一条与开关原则结合起来理解就是，基类遵循关原则，子类遵循开原则，子类必须满足LSP才允许继承，否则就断开这种继承关系
  - 为了尽可能地减少修改以及修改带来的安全隐患
* 接口隔离原则(Interface Segregation Principle, ISP)： Clients should not be forced to depend upon interfaces that they don't use.The dependcy of one class to another one should depend on the smallest possible interface. 使用多个隔离的接口，比使用单个接口要好，也有利于降低类之间的耦合度。类间的依赖关系要建立在最小的接口之上，要防止类必须实现接口中对于自己来说无用的方法情形的出现；
  - 一个接口中所有方法都是围绕一个职责，但是这个接口仍可能不符合接口隔离原则
* 迪米特法则(Law of Demeter, LoD)，也称最少知识原则(Least Knowledge Principle, LKP)： Only talk to your immedate friends. 一个模块或子系统应当尽量少地与其他模块或子系统之间发生直接相互作用，可以通过增加“即时朋友”这个中间人来中转通信，只与“朋友”保持联系，与“陌生人”概不谋面，当模块或子系统出现版本升级更新或环境移植之后，只要朋友不变就好
  - 只和自己直接的朋友交流：出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友
  - 不要将依赖类以局部变量的形式在类中使用
  - 依赖类尽可能少地公布公有方法
  - 如果一个方法放在本类中，既不增加类间关系，也不对本类产生负面影响，那就放置在本类中
* 合成/聚合复用原则(Composite/Aggregate ReusePrinciple ，CARP)：该原则要求在设计上尽量使用合成/聚合来达到复用的目的，而不是使用继承，也就是说前者优先于后者而被运用。继承会将基类的细节暴露给子类，也称白箱复用，如果基类发生改变，子类也必须相应做出变动，且多继承不易维护。CARP几乎可用于任何环境，依赖少，但是合成/聚合造成类中多对象需要管理

## 概念

* 控制反转（IoC）:不需要自己内容修改，改成由外部传递。由外部负责其依赖需求的行为
* 依赖注入（DI）:不是由自己内部 new 对象或者实例，通过构造函数，或者方法传入
* 反射:根据类名返回该类的方法，参数，变量

## 分类

* 创建型模式：对类的实例化过程的抽象。一些系统在创建对象时，需要动态地决定怎样创建对象，创建哪些对象，以及如何组合和表示这些对象。创建模式描述了怎样构造和封装这些动态的决定。包含类的创建模式和对象的创建模式。
  - Factory 工厂模式
  - Singleton 单例模式
  - Prototype 原型模式
* 结构型模式：描述如何将类或对象结合在一起形成更大的结构。分为类的结构模式和对象的结构模式
  - 类的结构模式使用继承把类，接口等组合在一起，以形成更大的结构。类的结构模式是静态的
  - 对象的结构模式描述怎样把各种不同类型的对象组合在一起，以实现新的功能的方法。对象的结构模式是动态的
  - Adapter 适配器模式
  - Decorator 装饰器模式
  - Proxy 代理模式
* 行为型模式：对在不同的对象之间划分责任和算法的抽象化。不仅仅是关于类和对象的，并是关于他们之间的相互作用
  - 类的行为模式使用继承关系在几个类之间分配行为
  - 对象的行为模式则使用对象的聚合来分配行为
  - Strategy 策略模式
  - Template 模板模式
  - Delegate 委派模式
  - Observer 观察者模式

## Architectural Patterns

* 分层模式
  - 表示层(也称为UI层)
  - 应用层(也称为服务层)
  - 业务逻辑层(也称为领域层)
  - 数据访问层(也称为持久化层)
* 客户端-服务器模式
* 主从设备模式：主设备组件在相同的从设备组件中分配工作，并计算最终结果，这些结果是由从设备返回的结果。
* 管道-过滤器模式：用于构造生成和处理数据流的系统。每个处理步骤都封装在一个过滤器组件内。要处理的数据是通过管道传递的。这些管道可以用于缓冲或用于同步。
* 代理模式：构造具有解耦组件的分布式系统。这些组件可以通过远程服务调用彼此交互。代理组件负责组件之间的通信协调。服务器将其功能(服务和特征)发布给代理。客户端从代理请求服务，然后代理将客户端重定向到其注册中心的适当服务。
  - 消息代理软件，如Apache ActiveMQ，Apache Kafka，RabbitMQ和JBoss Messaging
* 点对点模式：单个组件被称为对等点。对等点可以作为客户端，从其他对等点请求服务，作为服务器，为其他对等点提供服务。对等点可以充当客户端或服务器或两者的角色，并且可以随时间动态地更改其角色。
* 事件总线模式：包括4个主要组件：事件源、事件监听器、通道和事件总线。
  - 消息源将消息发布到事件总线上的特定通道上。
  - 侦听器订阅特定的通道。
  - 侦听器会被通知消息，这些消息被发布到它们之前订阅的一个通道上。
* 模型-视图-控制器模式：将信息的内部表示与信息的呈现方式分离开来
* 黑板模式：所有的组件都可以访问黑板。组件可以生成添加到黑板上的新数据对象。组件在黑板上查找特定类型的数据，并通过与现有知识源的模式匹配来查找这些数据。
  - 黑板——包含来自解决方案空间的对象的结构化全局内存
  - 知识源——专门的模块和它们自己的表示
  - 控制组件——选择、配置和执行模块
* 解释器模式

## 简单工厂

## 工厂 Factory

* 定义一个用于创建对象的接口，让接口子类通过工厂方法决定实例化哪一个类
* 工厂（Factory）负责生产（Create）产品，提供一个工厂抽象基类，该抽象基类提供生产的接口，为每一类图形，提供一个对应的工厂子类，生产对应的产品
  - 抽象工厂定义Create接口，返回Shape指针
  - 具象工厂（CircleFactory等）从抽象工厂派生，实现Create接口，并定义具象工厂的唯一变量，该全局变量的构造函数里，会将形状类型到对应工厂对象的对应关系注册到FactoryManager的map中。
* 一个工厂管理器（FactoryManager），在工厂管理器里维护这个对应关系（map很容易做映射），然后创建该工厂管理器的唯一实例（单例）
* 像内存池，线程池，连接池等池化技术都是这个模式
* factory创建出来的对象都有同样的接口可以被多态调用。这其实和Unix把所有的硬件都factory成文件一样，并提供了read/write等文件操作来让你操作任意设备的I/O

## 抽象工厂 Abstract Factory

* 创建一组有同一主题的不同的类
* 学校中的小学，初中，高中，大学差不多，都是一样的学习环境，一样的教学方式，一样的教室，都要期中考和期末考，都有班长和科代表，就是学的东西的难度不一样，但基本上都是语文，英语，数，理，化，还有永远都有的政治课。学校就是一个抽象工厂
* 在Unix下就像是/etc/rcX.d下的那些东西，1代表命令行单用户，2，代表命令行多用户，3代表命令行多用户完整模式启动，5代表图形界面启动，0代表关机，6代表重启，你要切换的话，init <X>就行了

## 原型 Prototype

* 复制一个类的实现。这个模式在现实中的例子也有很多：传真，复印，都是这个模式。Unix进程和Github项目的Fork就是一种。进程fork明显不是OO的模型
* 通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法
* 基于clone技术，为每个产品（形状）创建一个原型对象
* vs 工厂
  - 原型模式需要产品提供拷贝构造的能力
  - 原型模式不需要定义工厂类继承体现
  - 原型模式需要定义产品原型实例，而工厂模式需要定义各种工厂实例

## 单例 Singleton

* 一个类Class只有一个实例存在。并提供全局访问。Singleton限制了实例个数，有利于GC的回收。
* 需要解决限制该类型创建多个实例，一般通过私有化构造函数，禁拷贝构造的方式完成。
* 在多线程环境下，要解决并发创建的问题
  - 可以在进程启动，还没有创建其他线程的时候，把单例都创建出来
  - 可以通过多线程同步机制，确保只有一个实例被创建，这会引起一些额外的性能开销
* 在复杂的软件环境下，如果有大量不同类型的单件，要处理好，他们之间的构造顺序问题
* Unix下实现单例进程的一个最常用的实践是在进程启动的时候用“(S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)”模式打开一个“锁文件”

## Command

* 把一个对象的行为封装成一个一个的有相同接口的command，然后交给一个统一的命令执行器执行或管理这些命令。这个模式和我们的Unix/Linux机器启动时在/etc/init.d下的那些S和K开头的脚本很像，把各种daemon的启动和退出行为封装成一个脚本其支持reload/start/stop/status这样的命令，然后把他们按一定的规范做符号链接到/etc/init.d目录下，这样操作系统就会接管这些daemon的启动和退出

## Strategy 策略

针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。

* 这个模式和Bridge模式很像，只不过Bridge是结构模式，其主要是用于对象的构造；而Strategy是行为模式，主要是用于对象的行为。策略模式很像浏览器里的各种插件，只要你装了某个插件，你就有某个功能。你可以安装多个插件来让你的浏览器有更多的功能（书本上的这个模式是你只能选用一个算法，当然，我们不用那么教条）。就像《你可能不知道的Shell》中的那个设置设置$EDITOR变量后可以按ctrl+x e启动编译器，或是用set -o vi或set -o emacs 来让自己的shell像vi或 emacs 一样，或是像find -exec或xargs一样的拼装命令
* Bridge 和 Strategy是OO设计模式里的“Favor Composition Over Inheritance” 的典范，其实现了接口与实现分离的。Unix中的Shell就是一种，你可随意地更换不同的Shell。还有Emacs中的LISP驱动C，C实现了引擎，交给LISP实现逻辑。把程序分为前端和后端，通过socket专用应用协议进行通讯，前端实现策略，后端实现机制。再看看makefile把编译器和源代码的解耦，命令行输出这个接口可以把一个复杂的功能解耦并抽像成各种各样小而美的小功能命令，等等这样的例子，你会发现，还有大量的编程框架都会多少采用这样的思想，可以让你的软件像更换汽车零件一样方便。我在用Unix的设计思想来应对变更的需求中说过灯具厂，灯泡厂，和开关厂的例子

## 结构型

* 结构型（structural）：处理类或对象间的组合
  - 可以在不破坏类封装性的基础上，实现新的功能
  - 可以创建一组类的统一访问接口
  - 可以在不破坏类封装性的基础上，使得类可以同不曾估计到的系统进行交互

## 装饰 Decorator

* 以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能
* Unix/Linux命令的各种参数是对这个命令的修饰，等等。我觉得这个模式在Unix中最经常的体现就是通过管道把命令连接起来来完成一个功能

## 适配器 Adapter

* 把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端
* 将两个不兼容的类纠合在一起使用，属于结构型模式，需要Adaptee(被适配者)和Adaptor(适配器)两个身份
* 可以兼容欧洲美国中国的插头或插座，万能读卡器，可以播放各种格式多媒体文件的插放器，可以解析FTP/HTTP/HTTPS/等网络协议的浏览器，可以兼容各大银行的银联接口、支付宝、Paypal、VISA等银行接口，可以适配各种后端的解释器的Nginx或Apache
* 像Unix下的/dev下的那些文件，操作系统把系统设备适配成文件，于是你就可以使用read/write来进行读写

## Bridge

* 比如一个灯具可以接各种灯泡或灯管，一个电钻可以换上不同的钻头来适应不同的材料，一辆汽车可以随时更换不同的轮胎来适应不同的路面，你的桌面可以随时更换一个图片来适应你的心情，你的单反相机可以更换不同的镜头来拍不同的照片…… 桥接模式说白了就是组件化，模块化，可以自由拼装
* 通过让业务类组合一个标准接口来完成,在非OO的程序设计中用得实在是太多了，主要是通过回调函数或是标准接口来实现。这个也是Unix设计哲学中的主要思想。在Unix中，文件的权限使用的就是Bridge模式，标准接口是用户，用户组和其它，rwx三个模式，然后用 chmod/chown改一改，这文件就有不同的属主和属性了

## 代理 Proxy

* 给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。
* 某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入
* 去饭馆里吃饭也是一种代理模式，因为我们只管吃就好了，洗菜做饭洗碗的工作都被Proxy帮你干了，于是你就省事多了。操作系统就是硬件的代理，CDN就是网站的代理，……使用代理你可以让事情变理更简单，也可以在代理层加入一些权限检查，这样可以让业务模块更关注业务，而把一些非业务的事情剥离出来交给代理以完成解耦
* Unix下这个模式最佳体现就是Shell，它代理了系统调用并提供UI

## Observer

* 定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。发布订阅
* 也叫pub-sub模式，很像我们用手机订阅手机报，微博的follow的信息流也是这样的一个模式。MVC中的C会sub V中的事件，用非OO的方式其实也是一个回调函数的事。在很多异步系统中，你需要知道最终的调用有没有成功，比如说调用支付宝的支付接口，你需要向支付宝注册一个回调的接口，以便支付宝回调你。Linux下的一些系统调用如epoll/aio/inotify/signal都是这种思路

## Facade

* 把一大堆类拼装起来，并统一往外提供提口。在现实生活中这样的例子太多了，比如：旅行社把机票，酒店，景点，导游，司机，进店打了一个包叫旅行；IBM把主机，存储，OS，J2EE，DB，网络，流程打了个包叫企业级解决方案。Unix中最典型的一个例子就是用Shell脚本组合各种命令来创造一个新的功能，这是的Shell中的各种命令通过标准I/O这个接口进行组合交互。

## 模板（Template）

* 模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。

不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。

## Chain of Responsibility

* 劫匪来抢银行，保安搞不定，就交给110，110搞不定就交给武警。有什么事件发生时的响应的Escalation Path，办公中的逐级审批。这个模式用一个函数指针数组或是栈结构就可以实现了
* 这个思想很像编程中的异常处理机制，一层一层地往上传递异常直到异常被捕捉。在Unix下，一个最简单的例子就是用 && 或 || 来把命令拼起来，如：cmd1 && cmd2  或 cmd3 || cmd4 ， 如果cmd1失败了，cmd2就不会执行，如果cmd3失败了，cmd4才会执行。如： cd lib && rm -rf .o 或 ping -c1 coolshell.cn && ssh haoel@coolshell.cn

### 小技巧

* 在一个请求中重复读取数据库的数据是应该完全避免的，将请求缓存到静态属性中
* 将验证从控制器移动到请求类
* 一个控制器必须只有一个职责，因此应该将业务逻辑从控制器移到服务类
* 尽可能重用代码。 SRP（单一职责原则）正在帮助避免重复。倾向于使用 Eloquent 而不是 Query Builder 和原生的 SQL 查询
* 要优先于数组的集合批量赋值
* 不要在 Blade 模板中执行查询并使用关联加载
* 不要把 JS 和 CSS 放在 Blade 模板中，也不要将任何 HTML 放在 PHP 类中
* 在代码中使用配置和语言文件、常量，而不是写死它

## 图书

* [Head First Design Patterns](http://www.headfirstlabs.com/books/hfdp/): 解说软件设计模式的一本书
* [设计模式:可复用面向对象软件的基础 Design Patterns:Elements of Reusable Object-Oriented Software](https://book.douban.com/subject/1052241/)
* [设计模式解析](https://portal.netobjectives.com/pages/books/design-patterns-explained/)
* 《大话设计模式》
* 《设计模式之禅》
* 《深入浅出设计模式》

## 参考

* [DesignPattern](https://github.com/hoohack/DesignPattern):设计模式：PHP和Go语言实现
* [java-design-patterns](https://github.com/iluwatar/java-design-patterns)
* [DesignPatternsPHP](https://github.com/domnikl/DesignPatternsPHP)
* [design-patterns-for-humans](https://github.com/kamranahmedse/design-patterns-for-humans):Design Patterns for Humans™ - An ultra-simplified explanation
* [design-patterns-php](https://github.com/RefactoringGuru/design-patterns-php) <https://refactoringguru.cn/design-patterns>
* [从面向对象的设计模式看软件设计](https://coolshell.cn/articles/8961.html)

* <https://hulin.gitbook.io/design-patterns-by-php/zu-he-mo-shi>
