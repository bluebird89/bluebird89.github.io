# 面向对象程序设计语言(OOP)

* 开发者在设计软件的时候可以使用自定义的类型和关联操作。
* 代码和数据的集合体叫做"对象"。一个对象可以想象成绑定了很多"行为（代码）"和"状态（数据）"的物体。
对于数据结构的改变需要和代码进行通信然后操作，反之亦然。面向对象设计让大型软件工程的计划和设计变得更容易管理，能增强工程的健康度，减少失败工程的数量。

## 概念

* 所有的对象都是通过类来描绘
* 抽象：并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
    - 抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象
    - 因为抽象的概念在问题 领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的
    - 抽象类主要用来进行类型隐藏
        + 可以构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。
        + 模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的； 同时，通过从这个抽象体派生，也可扩展此模块的行为功能。
        + 熟悉OCP的读者一定知道，为了能够实现面向对象设计的一个最核心的原则OCP(Open-Closed Principle)，抽象类是其中的关键所在

### 多态

同一操作作用于不同的对象上时，可以产生不同的解释和不同的执行结果

* 思想: 将"做什么"和"谁去做以及怎么去做"分离开来，也就是将"不变的事"和"可变的事物"分离开来。
* 实现：归根到底是要消除类型之间的耦合关系，JS的变量类型在运行时是可变的，这意味着JS对象的多态性是与生俱来的。
* 作用：通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。

### 封装

* 目的:将信息隐藏,包括隐藏数据，隐藏实现细节，设计细节以及隐藏对象的类型等。
* 分为四类
    - 封装数据
    - 封装实现
    - 封装类型
    - 封装变化
* 实现：使得对象内部的变化对其他对象而言是不可见的，对象对其自己的行为负责，使得对象之间的耦合变得松散，对象之间只通过暴露API接口来通信，修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其它功能。
* 变化：把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易，这可以最大程度的保证程序的稳定性和可扩展性。

### 继承

JavaScript最重要的概念可能在于原型链。基于原型链的委托机制就是原型继承的本质。

* 所有的数据都是对象，JS的根对象是Object.prototype对象，它是一个空对象
* 要得到一个对象，不是通过实例化类而是找到一个对象作为原型来克隆它
* 对象会记住它的原型；就JS而言，对象的原型其实是其构造器的原型（new），包含在其隐藏属性_proto_中
* 如果对象无法响应某个请求，它会把这个请求委托给自己的原型
* JavaScript的原型最初都是由Object.prototype对象克隆而来；
* 对象构造器的原型并不限于Object.prototype,可以动态的指向其他对象； A.prototype=obj
* 原型链并非无限长，到顶（Object.prototype）以后，如果没有找到就会返回undefined；

## 分层

* 直接通过规定好的接口进行交互，每一层其实对它的上层或下层都是一个黑盒，其实它的上层和下层也不关心它内部的实现，只关心它们之间进行交互的接口，接口是规定的信息，要给到什么都是规定好的。
* 好处就是可以对任何一层进行独立升级、优化，只要保持接口不变那么这个模型整体就不会有问题，比如说物理层从以太网线到光纤，网络速度大大提高，但是整个技术革新的时候，其他层是没有做更多工作的，工作只在物理层完成

### 抽象类 vs 接口

* 结构
    - abstract class方式中，可以有自己的数据成员，也可以有非abstarct的成员方法
    - 在interface方式的实现中，只能够有静态的 不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的
    - 从某种意义上说，interface是一种特殊形式的abstract class
* 定义
    - 在abstract class的定义中，可以赋予方法的默认行为。
    - 在interface的定义中，方法却不能拥有默认行为，为了绕过这个限制，必须使用委托，但是这会增加一些复杂性，有时会造成很大的麻烦
    - interface中不能定义默认行为还存在另一个比较严重的问题，那就是可能会造成维护上的麻烦。因为如果后来想修改类的界面（一般通过abstract class或者interface来表示）以适应新的情况（比如，添加新的方法或者给已用的方法中添加新的参数）时，就会非常的麻烦，可能要花费很多的时间（对于派生类很多的情况，尤为如此）。但是如果界面是通过abstract class来实现的，那么可能就只需要修改定义在abstract class中的默认行为就可以了。
    - 如果不能在抽象类中定义默认行为，就会导致同样的方法实现出现在该抽象类的每一个派生类中，违反了"one rule，one place"原则，造成代码重复，同样不利于以后的维护
* 使用
    - abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系
    - 一个类却可以实现多个interface
* 设计理念
    - abstarct class在Java语言中体现了一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is a"关系，即父类和派生类在概念本质上应该是相同的
    - 对于interface 来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。
    - 有一个关于Door的抽象概念，该Door具有执行两个动作open和close，要求Door还要具有报警的功能
        - 实现类中实现具体方法：违反了面向对象设计中的一个核心原则ISP（Interface Segregation Priciple），在Door的定义中把Door概念本身固有的行为方法和另外一个概念"报警器"的行为方法混在了一起
        - open、close和alarm属于两个不同的概念，根据ISP原则应该把它们分别定义在代表这两个概念的抽象类中
            + 两个概念都使用abstract class方式定义；
            + 两个概念都使用interface方式定义；
            + 正确方法：一个概念使用abstract class方式定义，另一个概念使用interface方式定义
        - 设计意图：abstract class表示的是"is a"关系，interface表示的是"like a"关系
* 抽象方法实现规则不一样,从容器类的类关系图中可以看到
    - 接口主要是用来抽象类型的共性，例如说，容器的可迭代特性。
    - 抽象类主要是给具体实现类提供重用的代码，例如说，List 的一些默认方法。
* 使用时机
    - 弄清楚抽象类和接口之间的关系:类是对事物的抽象，抽象类是对类的抽象，接口是对抽象类的抽象
* 类对事物的抽象，定义了事物的属性和行为
    - 抽象类是不完全的类，具有抽象方法
    - 接口则比类的抽象层次更高
* 从这个角度来看 java 容器类，发现它的设计正体现了这种关系。不是吗？从 Iterable 接口，到 AbstractList 抽象类，再到 ArrayList 类。
* 在设计类的时候，首先考虑用接口抽象出类的特性，当你发现某些方法可以复用的时候，可以使用抽象类来复用代码。
* 接口用于抽象事物的特性，抽象类用于代码复用,不是所有类的设计都要从接口到抽象类，再到类

* 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。
* 抽象类要被子类继承，接口要被类实现。
* 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现
* 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
* 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类
* 抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。
* 抽象类里可以没有抽象方法
* 如果一个类里有抽象方法，那么这个类只能是抽象类
* 抽象方法要被实现，所以不能是静态的，也不能是私有的
* 接口可继承接口，并可多继承接口，但类只能单根继承。
* 抽象类能够保证实现的层次关系，避免代码重复。
    - 即使在使用抽象类的场合，也不要忽视通过接口定义行为模型的原则
    - 从实践的角度来看，如果依赖于抽象类来定义行为，往往导致过于复杂的继承关系，而通过接口定义行为能够更有效地分离行为与实现，为代码的维护和修改带来方便

功能          | 抽象类                                                   | 接口
----------- | ----------------------------------------------------- | -----------------------------------------
默认的方法实现     | 可以有默认的方法实现                                            | 接口完全是抽象的。它根本不存在方法的实现
实现          | 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现
构造器         | 抽象类可以有构造器                                             | 接口不能有构造器
与正常Java类的区别 | 除了你不能实例化抽象类之外，它和普通Java类没有任何区别                         | 接口是完全不同的类型
访问修饰符       | 抽象方法可以有public、protected和default这些修饰符                  | 接口方法默认修饰符是public。你不可以使用其它修饰符。
main方法      | 抽象方法可以有main方法并且我们可以运行它                                | 接口没有main方法，因此我们不能运行它。
多继承         | 抽象方法可以继承一个类和实现多个接口                                    | 接口只可以继承一个或多个其它接口
速度          | 它比接口速度要快                                              | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
添加新方法       | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。           | 如果你往接口中添加方法，那么你必须改变实现该接口的类。

实例： !()[../_static/ArrayList.png]

```
abstract class Door {
    abstract void open();
    abstract void close()；
}

interface Alarm {
    void alarm();
}

class AlarmDoor extends Door implements Alarm {
    void open() { … }
    void close() { … }
    void alarm() { … }
}
```

## 参考

<https://www.zhihu.com/topic/19599592/top-answers>
<https://www.zhihu.com/topic/19596218/top-answers>
