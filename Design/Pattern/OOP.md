# OOP

面向对象程序设计语言"的核心之一就是开发者在设计软件的时候可以使用自定义的类型和关联操作。代码和数据的实际集合体叫做"对象"。一个对象可以想象成绑定了很多"行为（代码）"和"状态（数据）"的物体。对于数据结构的改变需要和代码进行通信然后操作，反之亦然。面向对象设计让大型软件工程的计划和设计变得更容易管理，能增强工程的健康度，减少失败工程的数量。

## 概念

### 多态

多态：同一操作作用于不同的对象上时，可以产生不同的解释和不同的执行结果。多态背后的思想是将"做什么"和"谁去做以及怎么去做"分离开来，也就是将"不变的事"和"可变的事物"分离开来。

多态的实现：归根到底是要消除类型之间的耦合关系，JS的变量类型在运行时是可变的，这意味着JS对象的多态性是与生俱来的。

多态的作用：通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。

### 封装

封装的目的是将信息隐藏,包括隐藏数据，隐藏实现细节，设计细节以及隐藏对象的类型等。

封装分为四类：封装数据，封装实现，封装类型和封装变化

封装实现：使得对象内部的变化对其他对象而言是不可见的，对象对其自己的行为负责，使得对象之间的耦合变得松散，对象之间只通过暴露API接口来通信，修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其它功能。

封装变化： 把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易，这可以最大程度的保证程序的稳定性和可扩展性。

### 继承

说到继承，JavaScript最重要的概念可能在于原型链。基于原型链的委托机制就是原型继承的本质。

- 所有的数据都是对象，JS的根对象是Object.prototype对象，它是一个空对象；
- 要得到一个对象，不是通过实例化类而是找到一个对象作为原型来克隆它；
- 对象会记住它的原型；就JS而言，对象的原型其实是其构造器的原型（new），包含在其隐藏属性_proto_中；
- 如果对象无法响应某个请求，它会把这个请求委托给自己的原型。

  - JavaScript的原型最初都是由Object.prototype对象克隆而来；
  - 对象构造器的原型并不限于Object.prototype,可以动态的指向其他对象； A.prototype=obj
  - 原型链并非无限长，到顶（Object.prototype）以后，如果没有找到就会返回undefined；

## 分层设计

分层模型是我们计算机科学中常用的方法，分层直接通过规定好的接口进行交互，每一层其实对它的上层或下层都是一个黑盒，其实它的上层和下层也不关心它内部的实现，只关心它们之间进行交互的接口，接口是规定的信息，要给到什么都是规定好的。

分层模型的好处就是可以对任何一层进行独立升级、优化，只要保持接口不变那么这个模型整体就不会有问题，比如说物理层从以太网线到光纤，我们的网络速度大大提高，但是整个技术革新的时候，其他层是没有做更多工作的，工作只在物理层完成。这样做的好处也同时提高了我们技术的发展革新速度。

### 抽象类vs接口

抽象方法实现规则不一样

功能          | 抽象类                                                   | 接口
----------- | ----------------------------------------------------- | -----------------------------------------
默认的方法实现     | 可以有默认的方法实现                                            | 接口完全是抽象的。它根本不存在方法的实现
实现          | 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现
构造器         | 抽象类可以有构造器                                             | 接口不能有构造器
与正常Java类的区别 | 除了你不能实例化抽象类之外，它和普通Java类没有任何区别                         | 接口是完全不同的类型
访问修饰符       | 抽象方法可以有public、protected和default这些修饰符                  | 接口方法默认修饰符是public。你不可以使用其它修饰符。
main方法      | 抽象方法可以有main方法并且我们可以运行它                                | 接口没有main方法，因此我们不能运行它。
多继承         | 抽象方法可以继承一个类和实现多个接口                                    | 接口只可以继承一个或多个其它接口
速度          | 它比接口速度要快                                              | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
添加新方法       | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。           | 如果你往接口中添加方法，那么你必须改变实现该接口的类。

实例： !()[../_static/ArrayList.png]


从容器类的类关系图中可以看到，接口主要是用来抽象类型的共性，例如说，容器的可迭代特性。抽象类主要是给具体实现类提供重用的代码，例如说，List 的一些默认方法。
抽象类和接口的使用时机
那么，什么时候该用抽象类，什么时候该用接口呢？
要解决上面的问题，我们先从弄清楚抽象类和接口之间的关系。首先，我们都知道类对事物的抽象，定义了事物的属性和行为。而抽象类是不完全的类，具有抽象方法。接口则比类的抽象层次更高。所以，我们可以这样理解它们之间的关系：类是对事物的抽象，抽象类是对类的抽象，接口是对抽象类的抽象。
从这个角度来看 java 容器类，你会发现，它的设计正体现了这种关系。不是吗？从 Iterable 接口，到 AbstractList 抽象类，再到 ArrayList 类。
现在回答前面的问题：在设计类的时候，首先考虑用接口抽象出类的特性，当你发现某些方法可以复用的时候，可以使用抽象类来复用代码。简单说，接口用于抽象事物的特性，抽象类用于代码复用。
当然，不是所有类的设计都要从接口到抽象类，再到类。程序设计本就没有绝对的范式可以遵循。上面的说法只是提供一个角度来理解抽象类和接口的关系，每个人都会有自己的理解，有人认为两者一点关系都没有，这也有道理。总之，模式和语法是死的，人是活的。

## extend VS implements

* 继承实体方法
* implements:强制的约束

## 参考

<https://www.zhihu.com/topic/19599592/top-answers>
<https://www.zhihu.com/topic/19596218/top-answers>
