# 敏捷实施@ThoughtWorks

* 一种不停尝试、不停调整、不停优化的状态
* 产品和业务开发本来就是一个探索的过程，开始时一定是最无知的时刻。项目中的大部分决策也一定是在项目开始的时刻做出的，这将有一个重大的悖论，在最无知的时刻，做出了最重要而且是绝大部分的决策，并把它作为随后执行的依据。
  - 通过迭代应对这一问题，只做初始决策，定大致的方向
  - 通过市场反馈不断修正对产品的认知，增量的决策和调整
* 通过迭代将瀑布模型分隔成更小的周期，从而实现迭代.每一次迭代时间可能是2周。每个迭代都能都有交付的工件，如果交付物不能满足市场或客户需求。可以在下一个迭代再一次进行分析、调整和开发，从而响应变化
* 敏捷开发:60% Scrum + 40% XP
  - XP的一个Sprint的迭代长度大致为1~2周, 而Scrum的迭代长度一般为 2~ 4周
  - XP在一个迭代中，如果一个User Story(用户素材, 也就是一个需求)还没有实现，则可以考虑用另外的需求将其替换，替换的原则是需求实现的时间量是相等的。 而Scrum是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来，并有Scrum Master严格把关，不允许开发团队受到干扰
  - XP是务必要遵守优先级别的。 但Scrum在这点做得很灵活，可以不按照优先级别来做，Scrum这样处理的理由是：如果优先问题的解决者，由于其它事情耽搁，不能认领任务，那么整个进度就耽误了。 另外一个原因是，如果按优先级排序的User Story #6和#10，虽然#6优先级高，但是如果#6的实现要依赖于#10，则不得不优先做#10.
  - Scrum非常突出Self-Orgnization,XP注重强有力的工程实践约束。举个通俗理解Scrum的例子，Scrum:指的是英式橄榄球中一股脑争球这一战术或行为。scrum 即为这样一种方式，大家一拥而上，团队是球员，球是产品目标，人员环环相扣，围绕着产品目标进行工作。这里面多少有点“统筹法”的影子，人员深入协作以达到最优化效果。

## [开发模型演化](https://mp.weixin.qq.com/s/FtJFtGYu_jA2aBCD2aCUhA)

* 瀑布开发
  - 预先做大量的设计:所有的设计和规划都在初期完成
  - 基于文档开发 所有开发工作都基于需求文档和设计图
  - 测试滞后:等所有设计和开发工作完成才开始测试
  - 最后交付价值 只有在产品最后发布才能收到回报
  - 通过里程碑，将大的项目变成小的、可控的工作
  - 通过里程碑的环环相扣，顺序操作，让方案简单可以实施
  - 问题：
    + 需求文档经常描述不清楚，或者遗漏
    + 工作人员经常认为编码完了，工作就完了
    + 各种设计文档工作量很大，内容乏味，但编码完成后基本都对不上了
  - 本质问题并不是阶段，而是批量。需求批量地在一起进行设计，然后是批量地开发，批量地测试、交付等等
    + 批量让价值交付延迟，所有需求在最后的阶段才能交付，价值交付比较晚
* V模型:是瀑布模型的变种,凸显了测试和开发环节的对应关系
* 原形模型
  - 原形要解决的问题就是需求不准，避免需求经过长时间的开发，浪费了大量的金钱和人力，得到的软件还不是用户所期望的
  - 采用的方式是：开发团队在分析需求的时候，尽快开发出一个用户看得到的原形，让用户尽早感受到效果。其实原形模型更多的是一种沟通方式，只是有人不丢掉原形，在原形的基础上继续开发，才被定位为原形模型。不过原形的开发过程时间紧，任务重，结果非常粗糙，重用的成本一般很高，建议还是丢掉
  - 制作原形的时候，有时会做得很逼真，用户可以像真的系统一样操作，只是后台的逻辑都是假的；有时会做的很简洁，只是一些图片。据说iPad的开发过程使用了原形，那个时候的原形仅仅是一个木板，上面画了几个按钮，想要做什么就在上面假装点点，想象着它完成了想要的操作。只要有好的沟通效果，形式不重要
* 迭代模型:将大的需求变成小的需求，让问题的复杂度降低了很多
  - 当需求变小后，每个需求的开发过程就会变简单，每个阶段的工作也都可控了。每个迭代的需求都像瀑布模型一样有分析、设计、开发、测试，但是因为需求小，对文档的依赖减弱很多
  - 开发人员可以将前一个迭代学到的东西用在下一个迭代，开发越来越顺畅
  - 为开发不确定需求提供了可能。虽然整个需求没有完全想清楚，但是想清楚的部分可以先开发
* 敏捷模型
  - 初期定义产品愿景 Inception 在项目启动中，定义产品愿景，产品路 线图，发布计划等
  - 及时产生价值 每个迭代完成，交付可工作的软件以及功能
  - 需求，设计，开发同步 需求分析，设计，开发，测试同步在每 个迭代完成，缩减反馈时间
  - 迭代开发 每个迭代重复相同的流程，直到完成产品愿景
  - 快速交付，持续重构
    + 通过TDD过程，在开发需求之前就细化了需求的细节，对详细设计的结果有提升
    + TDD产出的测试用例，提升编码质量，避免反馈周期长。如果没有测试用例，一个Story很容易被当皮球踢
    + 项目中遗留的测试用例，能避免软件成为打地鼠软件。当增加一个A功能，发现B功能有问题，修复了B功能发现C功能故障了，修复了C功能，发现A功能又故障了
    + 通过Pipeline，让构建、测试更频繁，因为工具化了，成本更低，出错更少
    + 通过Pair、CodeReview，让知识流动起来
  - 演进的需求和方案
    + 用户的需求一般都只是一个大方向，具体的价值和实现方式都是不确定的，用户也在不断探索他们的业务。敏捷接纳了原型法的需求分析方法，还提出了Inception来分析更有价值的需求，通过MVP圈定最小开发范围，快速验证方案，这就是演进的需求和方案
    + 确定的需求设计好，不确定的需求就需要演进
  - 自组织(Self-Organizing)且跨功能的团队
    + 每个人都致力于项目的目标，团队成员互相尊重，每个人都专注于工作，开放，团队成员有勇气站出来参与该项目。这里最关键的就是每个人都致力于项目的目标

## 目的

* 更快交付价值
  - 更早交付:当向用户交付产品后，用户反馈,瞬间狂涨知识，并感叹道“你怎么不早说呢？”
  - 更多可能的是，用户这时才清楚或能够描述他们要的是啥，更有甚者，我们可能一开始连用户是谁也未必能准确地定义
  - 产品和业务开发本来就是一个探索的过程，开始时一定是最无知的时刻。项目中的大部分决策也一定是在项目开始的时刻做出的，这将有一个重大的悖论，在最无知的时刻，做出了最重要而且是绝大部分的决策，并把它作为随后执行的依据
  - 通过迭代应对这一问题，只做初始决策，定大致的方向。通过市场反馈不断修正对产品的认知，增量的决策和调整。
* 有效学习和灵活响应变化
* 缩短开发周期
* 提高质量
* 提升用户满意度
* 提升团队人员能力
* 增强协作
* 减少工作量，提高产能
* 产品创新
* 改变管理方式，增强成员参与感

## [Manifesto for Agile Software Development](https://agilemanifesto.org/)

* 个体和互动 高于流程和工具 Individuals and interactions over processes and tools
* 工作软件 高于详尽的文档 Working software over comprehensive documentation
* 客户合作 高于合同谈判 Customer collaboration over contract negotiation
* 响应变化 高于遵循计划 Responding to change over following a plan

## 阶段

* 愿景 VISION
* 产品路线图 ROADMAP
  - 一个可执行计划，它显示了产品可能如何发展。它通常包括几个主要的产品版本。Roman Pichler
  - 说明产品在几个主要版本中可能如何演进。与发布计划不同的是，它是一种超越单个项目或发布的产品计划:它描述了在接下来的12个月或者更长的时间里 你想要带你的产品走的路线——就像路线图帮助你计划旅行一样。 Janna Bastow
  - 创建
    + 识别产品需求：与干系人一起识别产品需求， 可以在便利贴上写下尽可能多的想法
    + 整理产品需求：将这些想法按照使用流程，技 术类似性，业务逻辑进行分组 ，比如:查询余额，支付账单
    + 产品需求的估算：团队开发对需求所需的工作量 进行评估，评估相对优先级
    + 确定大致时间线：根据需求的优先级，工作量,预估的开发速率评估大致的时间线
  - 需求复杂度估算
    + 所有故事的大小都是相对的
    + 整理用户故事，找到最小的
    + 与这个故事相关的所有其他故事的大小，两倍大，三倍大，等等
    + 斐波那契序列
  - 优先级评估框架：有各种各样的工具可以用来确定待办事项的优先级，并帮助创造出 MVP
    + 商业价值的大小
    + 开发复杂度
    + MoSCoW：Must have, Should have, Could have, Won’t have
    + 功能使用的频率
    + 外部依赖
  - 开发速率估算
    + 主持人安排故事的样本
    + 开发者会选择他们认为可以在迭代中“完成”的用户故事
    + 主持人统计总数
* 发布计划 RELEASE PLAN：了解有价值的产品/服务将如何交付以及团队需要如何支持的初步计划
  - 以两周为周期生成 Sprint
  - 为什么需要发布计划?
    + 让干系人和团队了解清晰的交付内容，时间点，优先级，发布时间
    + 和其他团队沟通以制定集成的时间点
  - 创建发布计划
    + 细化用户需求，用户故事分解
      - 主题(THEMES)：项目中要解决的主要概念。例如：客户｜安全
      - 史诗故事(EPICS)：深入主题可以揭示更多的功能领域。例如：客户的维护｜登陆
      - 特性(FEATURE)：功能区域可以分解为解决方案的特性。例如：新建/删除用户｜客户登录
      - 用户故事(STORIES)：特性被分解为应该在解决方案中可用的功能片段。例如：在线注册新用户/停用现有客户在线档案｜忘记密码
      - 任务(TASKS)：为了实现一个故事，团队需要完成许多技术任务。例如：确定客户不存在/验证客户余额为0｜连接到LDAP
    + 用户故事估算：当需求拆分到用户故事级别之后，和团队一起对用户故事进行估算
      * BA和团队讲述故事卡内容
      * 从一个最简单的故事开始，参与者对该故事做估算作为参考基准 - 1个故事点
      * 从高优先级的故事开始，和1个故事点故事对比， 参与者给出故事点数
      * 只有在有分歧时才讨论，如果大家都同意 ，那就没有必要讨论了，讨论分歧点——“为什么你认为它是一个......”
      * 将大家都同意的点数作为故事卡点数
    + 制定产品待办列表(Backlog)：产品待办列表是项目相关的所有用户故事的列表。产品负责人不断的添加用户故事，优先级排序来维护产品待办列表。
    + 创建发布计划：根据需求的优先级，工作量, 预估的开发速率评估大致的时间线
* 迭代计划 ITERATION PLAN
* 每日站会 DAILY STANDUP
* 产品演示 SHOWCASE
* 迭代回顾 RETRO
  - 一定要可视化出来
  - 年初时都做过展望与总结

## 措施

* 建立敏捷实施工作组
* 领导积极参与敏捷实施工作
* 培养企业内部敏捷教练
* 建立技术内部团队来落地持续集成、自动化测试等交付技术
* 雇佣外部敏捷教练
* 例行敏捷会议
* 组织敏捷相关工作
* 调整运作流程规范
* 新的敏捷角色，Scrum master
* 调整绩效管理制度
* 把敏捷改进设为团队目标
* 建立一系列实践社区
* 改造原有系统架构，更快速响应变化
* 敏捷开发
* 极限编程
* 快速迭代
* 持续集成
* 精益创业

## 实践

* 需要自适应的规划、演进式的开发和交付
* 精益方法Lean
* DevOps:基于其它两个领域的实践:精益和敏捷。不是一个公司内的岗位或角色；它是一个组织或团队对持续交付、持续部署和持续集成的坚持不懈的追求
  - Gene Kim（Phoenix 项目和 Unicorn 项目的作者）认为，有三种方式定义 DevOps 的理念：
    + 第一种: 流程原则
    + 第二种: 反馈原则
    + 第三种: 持续学习原则
  - 一种灵活的实践，它的本质是一种关于软件开发和 IT 或基础设施实施的共享文化和思维方式
    + 软件交付能力很重要，它极大地影响到组织的成果，例如利润、市场份额、质量、客户满意度以及组织战略目标的达成。
    + 优秀的团队能达到很高的交付量、稳定性和质量；他们并没有为了获得这些属性而进行取舍。
    + 可以通过实施精益、敏捷和 DevOps 中的实践来提升能力。
    + 实施这些实践和能力也会影响你的组织文化，并且会进一步对你的软件交付能力和组织能力产生有益的提升。
    + 懂得怎样改进能力需要做很多工作。

* 特性驱动开发Feature-Driven Development（FDD）
* 水晶方法Crystal
* 动态系统开发方法Dynamic Systems Development Method（DSDM）
* 自适应软件开发Adaptive Software Development（ASD）
* 看板Kanban（可视化工作流）:是一个敏捷框架，有时也叫工作流管理系统，它能帮助团队可视化他们的工作从而最大化效率（因而变得敏捷）。看板通常由数字或物理展示板来呈现。团队的工作在展示板上随着进度而移动，例如从未启动到进行中，一直到测试中、已完成。看板使得每个团队成员可以随时查看到所有工作的状态。
* 大规模敏捷（SAFs LeSS）
* 特性团队
* 领域建模，可变化设计（UML）
* 结对编程
  - 硬件设置
    + 需要一个大的外接显示器和有一个可以调节高度的桌子（当然也可以用纸箱子DIY一个低配版:直接决定结对能不能作为一个可持续的团队工程实践.
    + 纸和笔永远是你（们）的好朋友，在实际动手写代码之前，请拿出纸笔来将要做的事情划分成更细粒度，可以验证的任务列表，贴在显示器的下边缘。最后，另外记得将手机调成震动模式，利人利己。
  - 软件设置
    + 可以切换到自己熟悉的Keymap：在Intellij/WebStorm里 Ctrl+`来切换各种设置
    + 至少熟悉一个IDE/编辑器，比如通过纯键盘的操作完成
      * 按照名称查文件
      * 按照内容搜索
      * 定位到指定文件的指定行/指定函数
      * 选中变量，表达式，语句等
      * 可以快速执行测试（可以在命令行，也可以在IDE中）
    + 熟常基本Shell技能和常用命令行工具的使用，可以完成诸如
      * 文件搜索
      * 网络访问
      * 正则表达式的应用
      * 查找替换文件中的内容
  - 结对双方会有一个人比较有经验，而另一个人则在某方面需要catchup：需要双方有一个人来做主导，另一个人来观察，并在过程中交互，答疑解惑，共同完成任务。
    + 主导者
      * 千万不要太投入，而无视peer的感受
      * 主导者太热心的coach，而忽视了给新人实际锻炼的机会。这时候需要主导者给peer更多的实践机会：比如在带着新人编写了一个小的TDD循环（红绿重构）之后，可以抑制住自己接着写的冲动
      * 看到peer正在用一个不好的做法来完成任务时，你可以即使让他停下来，并通过问问题的方式来启发他： 还有更好的做法吗？  你觉得XXX会不会更好？
    + 观察者：抓住一切可能的机会来向你的peer学习
      * 快捷键的使用：通过快捷键删除了花括号（block）中的所有代码
      * 命令行工具参数的应用：将curl的返回值以prettify过的样式打印到控制台
      * 良好的编程习惯：通过命令行merge了一个PR
      * 保持你的专注力和好奇心
    + 实践的时候，可以采取Ping-Pong的方式来互换主导者和观察者的角色。比如，A写一个测试，B来写实现，A来重构，然后换B来写测试，A来实现，B来做重构等等
  - 保持专注
    + 需要一起完成任务划分。这样可以确保你们可以永远关注在单一任务上，避免任务切换带来的损耗。
    + 在做完一项任务后，用mark笔轻轻将其从纸上划掉（或者打钩）。
      + 既可以将你们的工作进度很好的表述出来，
      + 在任何时候帮助你们回到正在做的事情上
      + 另外这个微小的具有仪式感的动作是对大脑的一个正向反馈，促进多巴胺的分泌
  - 无法统一的意见
    + 所坚持的只是一个假的“真理”，先前的坚持和做技术选型时的理由就变得很可笑：那只不过是为了使用自己熟悉的技术而编造的理由而已。保持open mind是一件知易行难的事情，希望大家在争辩时能念及这个小例子，可能会少一些无谓的争辩。
    + 难以统一意见的场景，我建议可以将其搁置，先按照某一种提议进行，知道发现明显的，难以为继的缺陷为止。
    + 技术选型时我自然的选了更早项目中使用的scss module，而团队里的另一个同事则提议使用styled-component。我们谁也没有说服谁，最后写代码的时候就有两种风格。直到有一天，我在代码库里看到了用styled-component写的很漂亮的组件，我自己尝试着把相关的scss重写成styled-component，结果发现确实比单独的scss文件要更好维护一些，而且也不影响既有的测试。
  - 棘手的任务
    + 两人分头研究，并严格控制时间。比如Time box 30分钟。不过很可能在30分钟后，你们中至少有一个人已经对要怎么做有了头绪，如果30分钟还没有头绪，则可以求助团队其他成员。
  - 张弛有度
    + 普通人很难全神贯注在某件事情上超过30分钟。这时候一个短暂的break可以让大脑得到很好的休息。
      * 从Todo列表中找出下一个任务
      * 设置一个不可中断的25分钟，开始工作
      * 时间到了之后，休息5分钟
      * 重复2-3，4次之后休息15分钟
  - 结对轮换
    + 需要定期或者不定期的轮转，比如一周轮换一到两次，A和C来写订单，B和D来写门店管理，这样可以保证领域知识，工程实践，工具的使用等等知识都很好的在团队内部共享。
    + 发现让不同角色的团队成员轮换结对所带来的好处（伴随着短期阵痛的）远胜过知识的隔离带来的坏处。团队中的前端开发如果花费一些时间和DevOps一起结对，他会对系统的整个架构更加清楚；而后端开发和DevOps结对则可能让他意识到代码中的潜在缺陷和解决方法
  - 尊重
    + 如果你不愿意和某一特性的人结对，那么首先不要让自己成为那样的人。
    + 尊重还体现在很多其他细节中。当你不得不中断结对而去做其他事情时，务必让你的peer知道。当你的peer回来之后，你需要及时和他catchup，告诉他你正在做什么，已经做到了哪一步等等。快速的将他带入到上下文中。
  - 控制情绪：具有很强的传染性
    + 当你们的工作任务收到各种blocker，被各种其他事情干扰而导致进度难以推进时，一定要注意自己情绪的控制。如果你的peer一直在旁边唉声叹气，或者抱怨连连，你会变得非常沮丧，并且很难集中精力在积极解决问题上。
  - 需要总结一下自己记录的知识点，这是一个绝佳的提升自己能力的方法。通过实战，发现自己的缺点，并通过近距离观察别人如何解决该问题，最终会以很深刻的印象记录下来，这时候针对性的查漏补缺是可以取得非常好的效果。

* 验收驱动开发（ATDD）
* 自动化测试
* 持续发布
* 持续集成
* 设计思维
* 前端需求管理的敏捷（需求价值分析、电梯演讲、MVP）
* 敏捷管理工具（JIRA、TFS、RTC、Rally）
* 微服务框架
* 精益创业、黑客营销
* 项目组合的敏捷管理
* 预算与绩效管理的敏捷
* 物理墙：看到要做的事情、正在做的事情和已经搞定的事情，并且要有owner
* 以周为一个迭代，大概经过n个迭代就可以顺利release了
* 做记录量化统计
* 重构

## 敏捷开发

* 核心原则
  - 价值驱动
  - 技术卓越
* 实践
  - 基于统一迭代节奏的全功能团队:为了交付软件所需要的技能都应该在一个团队里
    + dev
    + BA：分析下一个迭代卡，验收当前完成的卡
    + QA：给下一个迭代卡片写AC，测试当前迭代卡
    + UX：
  - 基于Story的需求及范围实时管理
    + Story是开发团队的最小工作单元
    + 工具是燃起图（Burn-Up）和累积流量图（CFD来至于Kanban）
  - 基于持续集成和测试前置的质量内建
    + 持续集成纪律有两条核心，第一是必须每次提交触发构建；第二是每次提交必须基于上次的成功构建
  - 基于Velocity和Cycle Time的持续改进

## 工作量估算

* 用故事点为单位估工作量，是正确的做法
  - 纯粹对用户故事大小的相对度量，不应该跟任何的天数或者工作量等关联。
  - 用户故事本身的大小属性不会发生变化，基于故事点的估算不会过期，不会受到团队技术能力和业务领域熟悉度的影响而发生变化。比如，一个点数为3的用户故事，它的复杂度相对于那个点数为1的基准故事来说不会发生变化，不管谁、也不管用什么技术来开发这个用户故事。
  - 故事点的大小是指团队所有角色工作加一起的统一估算数值，需要多个角色一起合作讨论才能得出这个估算，因此，故事点的估算方法有利于帮助团队实现跨功能合作的行为
  - 特别注意，不应该按照开发的点数、测试的点数去估算用户故事的大小，需要结合一起给出一个唯一的数值。
* 用人天为单位估工作量，是错误的做法
  - 基于这样的假设：
    + 所估算的故事是唯一要做的工作
    + 所有需要的东西在故事开始前都会准备好
    + 故事开发过程中不会被打断。
  - 理想时间跟耗用时间是不同的。理想人天的估算是基于理想时间的，在软件开发过程中会有多个因素导致实际耗用时间跟理想时间会有很大的不同，比如开会、讨论等。
  - 很容易让人根据一个故事所需完成的任务多少去估算，而不是从这个故事跟其他故事的相对大小角度去考虑；不同人估算的理想人天也会有不同，导致估算可能会不太准确
* 因为「工作量」按照定义就是一个「量」的概念，而不是「时间」的概念。最多的一个例子：搬一千块砖，就是搬一千块砖的工作量。搬得快，它是一千块砖；搬得慢，它还是一千块砖。工作量的大小，是与时间无关的。 `工作量 ➗ 速率 = 时间`
* 如何知道速率
  - 知道谁来做这个故事吗？生手和熟手程序员，速率是不一样的吧。
  - 知道做的人每天花多少时间来做这个故事吗？外部干扰多的一周，和外部干扰少的一周，体现在每天上的速率是不一样的吧。
  - 知道在什么时候做这个故事吗？项目初始阶段，和项目临近尾声，开发一个故事的速率是不一样的吧。
* `项目总体工作量 ➗ 团队速率 = 预期交付时间`:昨天的天气。要跑两个迭代，就会知道这个团队的速率
* 用时间来估工作量:因为他们假设速率是常量。既然速率是常量，那么工作量与时间就始终成正比.背后的观念
  - 程序员都是可替换的「人力资源」，A程序员和B程序员是没区别的，生手程序员和熟手程序员是没区别的，这个程序员离职了马上去大街上招一个，对速率也是没有重大影响的。
  - 程序员是不会成长的，在项目启动阶段的速率是这样，做到项目结尾时，速率还是这样，程序员并不会在项目过程中收获经验和技能，程序员的速率不会因为知识和熟练度的增加而提高。
  - 团队的环境是无关紧要的，团队成员彼此协作的方式要么不可能有任何改变、要么这种改变不会对速率产生任何影响
  - 只有预设了程序员就是机器上无差别可替换的齿轮时，一个团队、一个公司才会认为：软件开发的速率是一个常量
* 什么情况需要重估
  - 没有在预定的天数内完成考虑给故事涨点，也就是重估，这种以进度来驱动重估的做法是不对的,不能是因为做不完赶不上进度而调整。没有在估算天数内做完可能有两个方面的原因
    + 估算不准确，低估了
    + 被其他工作所打断，或者团队技术原因导致进度较慢...
  - 不需要重估的情况
    + 假设一个团队有4个复杂度相当的用户故事，原本估算均为3，预计能够在一个迭代完成的。在第一个迭代结束后，只完成了其中的两个用户故事，也就是完成了6个点，团队感觉这两个用户故事比预估的要大，想调整为原来点数的两倍，由6变成12；由于四个用户故事的大小相当，剩下的两个用户故事也需要调整为原来的两倍，剩下的工作量也变成了12，同样的可能还需要一个迭代才能完成。这样的重估就没有意义。
    + 如果只是发现用户故事实际耗费时间比原来预测的要多，但是**故事的相对大小并没有问题的时候**，不需要重估，而是要去回顾和分析耗费时间长的原因，并采取相应的措施去改进。
  - 需要重估的情况
    + 假设团队由A、B、C、D四个用户故事，刚开始给每个故事的估点均为3。在开发故事A的过程中发现A比原来估算的值要大，需要调整为5才合适，另一个类似的故事B也是一样，需要调整为5；但是C和D跟它们不一样，估算值应该是准确的，还可以保持为3。这种情况下对A和B的重估是有价值的，因为**相对大小发生了变化**
* 速度（Velocity）
  - 对团队的进度生产率的度量，可以通过计算团队在一次迭代中完成的用户故事所分配的故事点数的总和来得到。比如，完成5个3个点的用户故事，速度是15；如果完成了2个5个点的用户故事，速度是10。关于“完成”的定义不能只是到“开发完成”，而应该是“交付完成”
  - 可以修正计划的误差。估算把对工作量的估算和对工作时长的估算完全隔离开来，将必须完成的所有用户故事的点数总和除以迭代的速度，可以推算出迭代的次数，也就是项目持续时间
  - 假设团队估算出项目中包含了200个故事点的工作，一开始认为可以在每次迭代中完成25点，也就是将用8次迭代来完成工作。但是，在项目开始以后，团队发现速度只能达到20点。这样，不用对任何工作进行重估，就可以正确的认识到项目需要10次迭代，而不是8次。
  - 速度不会是稳定不变的。根据团队对技术和业务领域知识的熟悉程度，速度可能会增加；而随着团队人员调整，有新人加入以后，速度可能会下降。在故事点估算准确的情况下，速度正好是反映团队状态的一个参数。不应该为了保持速度的不变去调整估算的结果，而应该根据速度的变化来观察和分析团队的健康程度。
* 效率度量
  - 指标
    + 交付速度(Velocity):每个迭代完成的总Story Points
      * 说明
        - 前提:拆分故事、每个故事估点，并且是基于团队的估算
        - 算应把各种工作考虑全面，比如:设计、开发、自测、Code Review/Code Diff，测试等
        - 如果没有严格的迭代时间概念(比如:看板方式)，每两周统计一次，第一列可以变成时间段
        - 能够利用燃尽图的数据
      * 策略
        - 通过几个迭代，找到团队适合的速率
        - 如果团队速率总是稳定不下来，仔细分析原因
        - 当稳定一段速率之后，看看是否还有可以提高的空间
    + 交付(前置)时间(Lead Time):当前迭代完成的Story中，从需求进入IPM至需求交付的耗时。一个新任务出现在工作流程中 到它最终离开系统之间的时间
      * Lead Time越长，吞吐率将基本不增长，必须要减少Lead Time，减少等待、快速流动起来
      * 等待时间超过3天以上，需要仔细分析
      * 流程周期效率% = Cycle Time/Lead Time，理想情况大于50%
      * 带来的added value:
        - 更短的cycle time
        - 更高的throughput
    + 周期时间(Cycle Time):完成Story实际花费的时间，开始于当新 产品进入“进展中”阶段 ，并且有人正在对其 进行工作的那一刻
    + 吞吐率(Throughput): 某个给定时间段交付的Story工作项数量
  - 据以上指标，绘制燃起图(burnup chart)，以及累计流图(cfd)，在迭代回顾会议上，团队一起分析讨论，识别瓶颈、评估交付速度及风险、分析交付改进方向及方法，并给出具体行动计划。并在下一次迭代会议中进行回顾
  - Story也包括技术卡;
  - 如果没有严格的迭代概念(比如:看板方式)，每两周统计一次;
  - 吞吐率用累计流图去看;
* 估算与计划
  - 估算是为了更好的做计划，通过估算推算出的持续时间是一种可能性，而不是对交付时限的一种承诺。估算的是用户故事固有的属性，其大小不应该受到交付时长的干扰。
  - 客户都会希望更短的时间交付更多的功能，但是不要让客户只把目光关注到进度上，要引导客户更多的关注交付的业务价值。因此，在考虑任务的优先级的时候，需要以价值为导向，而不是进度为导向。比如，重构等技术改进、性能调优、生产环境的支持，这些可能比新的特性开发带来的价值更大、有着更高的优先级。
* 如何提升开发效率
  - 调整沟通协作的方式
  - 提升质量和基础设施
  - 提升团队能力
  - 定期梳理技术风险和债务
  - 定期梳理业务风险和依赖
  - 消除干扰
  - 迭代回顾-Retro
* 成本管理
  - 创建初始成本预算
    + 硬件成本
    + 软件，软件许可成本
    + 托管服务的成本
    + 培训成本
    + 差旅费，团队建设，办公用品等
  - 根据发布计划确定长期成本
  - 如何降低成本
    + 提升开发效率
    + 放弃优先级低的需求，从而减少开发时间
    + 根据项目进程，合理安排团队结构
    + 合理安排团队梯队，培养新人
    + 合理安排出差
    + 托管服务资源回收

## DevOps vs 敏捷

* 相似之处
  - 毫无疑问，两者都是软件开发技术。
  - 敏捷已经存在了 20 多年，DevOps 是最近才出现的。
  - 两者都追求软件的快速开发，它们的理念都基于怎样在不伤害客户或运维利益的情况下快速开发出软件。
* 不同之处
  - 两者的差异在于软件开发完成后发生的事情。
    + 在 DevOps 和敏捷中，都有软件开发、测试和部署的阶段。然而，敏捷流程在这三个阶段之后会终止。相反，DevOps 包括后续持续的运维。因此，DevOps 会持续的监控软件运行情况和进行持续的开发。
  - 敏捷中，不同的人负责软件的开发、测试和部署。而 DevOps 工程角色负责所有活动，开发即运维，运维即开发。
  - DevOps 更关注于削减成本，而敏捷则是精益和减少浪费的代名词，侧重于像敏捷项目会计和最小可行产品的概念。
  - 敏捷专注于并体现了经验主义（适应、透明和检查），而不是预测性措施。
  - 敏捷    DevOps
  - 从客户得到反馈 从自己得到反馈
  - 较小的发布周期 较小的发布周期，立即反馈
  - 聚焦于速度   聚焦于速度和自动化
  - 对业务不是最好 对业务最好

## [敏捷度量](https://mp.weixin.qq.com/s/khJRYAPhK5QP-2Bqi8YzwA)

* 为什么要做度量（Why）：敏捷项目通过度量来拉通目标和行动、指导团队制定工作计划和任务，并协助团队持续改进。
  - 拉通目标和行动：可工作的软件长什么样子，它具备什么功能，它为谁提供价值，采取什么样的行动能获得这些价值，这些都是敏捷团队需要回答的问题，敏捷团队不仅仅要知道问题的答案，为了快速实现目标，敏捷团队还需要定期评估行动的效果，为了拉通目标和行动，度量的引入能帮助团队及时纠偏，少走弯路，减少浪费。
  - 定位当下的位置，计划下阶段的任务：实际工作中，经常会有客户邀请我们的顾问评估一下他们的现状，他们基于现状做下一个阶段或者下一年度的计划，这样的诉求在接近季度末或者年底的时候尤其多。正如人需要定期做体检一样，体检结果让我们对自己的身体状况有更好的了解，敏捷项目也需要定期的健康度评估，这些评估和度量的结果，除了揭示项目存在的问题，还能够帮助团队总结经验反思教训，从而更好的指导下一阶段的计划。
  - 改进，改进，改进：敏捷项目推崇持续改进，以更好的方式、更快的速度交付更优的价值，这是很多团队追求的目标，这个目标不是一蹴而就的，有的时候团队需要引入更好的工具，有的时候团队需要借鉴更丰富的经验，有的时候则依赖团队持续的成长。敏捷项目引入工具和他人经验的过程也是不断试错的过程，在试错的过程中团队需要知道哪些改变是成功的，哪些是失败的，这个评估通常是通过度量来完成的，所以引入度量也是为了更好的改进。
* 度量什么（What）：如果敏捷项目是一个长方体的话，长方体的体积代表团队所要交付的目标，长方体的长、宽、高决定了长方体的体积。敏捷项目度量的是交付效能、团队能力和产品的价值，以及保证这这些目标能够达成的团队健康度。
  - 长度代表交付的速度，也叫交付的效能，长度越长，交付的效率越高，团队也就能更快的接近目标，实际工作中，我们经常听到的研发效能、测试效能、管理效能，cycle time（需求提出到上线所用的时间）等等，都和速度有关，这些指标决定了团队以多快的速度实现目标，这是度量中非常关键的指标。
  - 宽度代表团队的能力，实际工作中，我们提到的测试质量，代码覆盖率，敏捷实践实施，持续集成和交付，统一配置管理，灰度发布，债务管理，松耦合架构，等等，和团队实践以及工具相关的指标都和能力有关，这些指标决定了团队能不能应对不确定性带来的挑战，能不能解决各种复杂、繁杂甚至混沌的问题，能不能做到持续优化和改进。
  - 高度又叫深度，代表产品（软件）价值，实际工作中，我们做的需求价值分析、MVP拆分、产品愿景、优先级排序、价值验证等等，都是团队基于自己的经验展现出的对业务的理解，并在此基础之上准确无误的给出方案，交付客户期望的价值，这些指标决定了团队能不能基于自己深度的积累，精准的帮助客户实现目标，并且能在极少浪费的情况下实现目标。
  - 健康：这个维度就如同我们给这个长方体上的颜色，是沮丧的灰色，焦虑的红色，抑郁的蓝色，还是生机勃勃的绿色？团队是什么成熟度，项目整体是否健康，这些也需要度量，常见的指标，比如，项目满足的财务指标，干系人管理，团队协作，团队成长，管理的透明化，成员的稳定性等等，敏捷团队健康度这个维度决定了团队能否长期稳定的以此种方式工作，团队能不能自我优化。
* 谁来做度量（Who）：由团队共同承诺、共同行动和共同负责来完成。
  - 角色之间交叉度量。团队负责不代表不能有分工，如果团队自行组织度量的话，建议角色互换来度量，比如开发人员做价值交付维度的发起者，需求人员提供信息；测试人员做开发相关指标度量的发起者，开发人员输入信息，这样做能更好的保证度量的客观性，对团队来讲，也是一次不错的知识和经验分享的过程。
  - 引入外部的顾问来做度量。外部的顾问可以是其他团队的人员，也可以是独立的第三方顾问，这样做的好处除了保证度量的客观性，外部顾问还能带来更多的经验，甚至会把跨行业和领域的经验带给团队，帮助团队改进和优化，建设能力。这个方法实施的注意事项是，一定要保证两次度量的评价标准一致，否则会失去度量的价值。
  - 无论是团队自组织做还是引入外部顾问，都需要全员参与。因为度量不仅是团队拉（XI）通（NAO）目标、明确任务、统一行动的机会，度量还能够帮助团队提高凝聚力。
* 什么时候做度量（When）除了例行的度量之外，在经历了大的危机、重大的里程碑事件之后也是执行度量、总结经验和教训来优化和改进的好时机。
  - 项目在经历重大的事件之后，这里专指风险事件或者危机事件，团队需要集体反思、总结教训，这个时候项目需要做一次度量，找到那些把风险带给团队的指标，以此来寻找优化和解决问题的方法。
  - 里程碑事件之后，或者一个关键的MVP 发布之后，团队积累了大量的经验，当然也有教训，这个时候也应该引入度量，评估一下和目标的差距，制定下个阶段的计划，带着经验继续优化和改进。
  - 周期性的度量，建议3-6个月，之所以选择这样一个周期，是因为少于3个月，很多持续性的行动还很难产出效果，长于6个月的话，某些行为具备了惯性，掉头的难度比较大，综合考虑，3-6个月是比较合适的周期，具体选择多长时间，由团队来决定。

## 会议

* 每日例会：每日5分钟左右的一个简单例会，尽可能多的开发人员参与进来对紧要问题的讨论。目的是更新进度和暴露开发中遇到的问题，不应该讨论具体的问题。 15min
* 评审会：需要在迭代周期的最后一天召开，1个小时左右就可以了，需要客户出席，如果客户不能出席，则需要产品经理出席.在开迭代计划会议之前应该准备好所有的需求分析，如果遇到需求不合理应该及时跳过，不应该在会议中寻求解决方案。 2h
* 回顾会（Retro）：在每个迭代结束时进行，总结工作中的经验和教训，时间维持在30-60分钟内，整个团队都需要参加（Scrum Master、Product Owner、开发团队以及客户）。把重点放到上一次行动是否明确执行以及需要改进点上。可以通过投票讨论优先级高的改进点
  - 定量分析:包含团队是否完成了迭代目标，收集并评审迭代度量指标（包括速率、迭代燃尽图、迭代计划故事和实际完成故事、计划发布日期与实际发布日期、客户满意度、团队满意度、生产环境Bug数、生产Bug解决时间、用户故事等）
  - 定性分析:包含哪些工作良好（应该继续保持），哪些做的不好（应该停止）？哪些可以改进（团队选出１－２条在下一个迭代实现）
* 产品展示会议 30min
* 每个会议必须有主持人、会议目标、会议准备，否则会议是冗长而无效的
* 参会人员应该准时到达:对迟到的容忍就是对准时到的人惩罚

## 时间，成本管理

* 时间成本的估算:
  - 如何做好时间管理，如何理顺千头万绪的工作，
  - 时间怎么合理分配
  - 基于敏捷开发下成本和时间怎么规划 996氛围下如何做好时间管理 实践做法都有什么
  - 时间和成本该如何估算，如何在项目前期充分识别 并在后期减 少偏差 时间与成本之间的关系是从开始就要做好预估的吗 大多数项目的时间和成本都并不富裕，估算工作量时的需求也 并不明确，如何控制成本或合理预估成本?
  - 外部第三方实际没法控制的如何时间管理?对于小的延续功能 优化如何预测成本? 如何准确的评估时间和成本并按时执行? 时间和成本管理有时候在创业公司有诸多不完善之处，如何进行符合事情时间和成本管理?
* 时间和成本的平衡:
  - 时间和成本的合理性， 成本与进度的平衡， 时间和成本之间的关系，时间决定成本?
  - 时间和成本发生冲突时，如何处理? 团队既有开发任务又有生产问题调查和修复 如何平 衡时间和成本
  - 如何平衡二者? 时间和成本如何做选择? 投入产出比? 时间长了，成本如何控制?
* 项目延期如何处理:
  - 延期控制，延迟如何处理? 项目总是delay，如何合理规划时间?
  - 面临即将超出的工期和成本该怎么办? 时间拖延如何调整? 延期后如何调整?
* 时间固定的项目如何管理成本:
  - 时间不变，成本不变，加班? 迭代需求变化，但是时间和人力固定，怎么管理
  - 如何在时间固定，项目周期倒排的情况下，保证项目进度和成本?
* 如何提升效率降低成本:
  - 如何做到高效低成本?如何有提升团队速率? 时间急，资源优先，如何能够尽快出活?
  - 如何管理时间与成本做到少付出 高回报? 如何通过时间和成本控制提升效能? 有没有因成本太过而调整周期的可能?
* 敏捷项目的时间和成本管理与瀑布式有何不同
  - 传统项目时间管理
    + 固定的范围直接决定项目的进度,PM根据项目初期收集的需 求确定项目时间
    + 在设计，开发，测试，部署等多个阶段，团队同时处理所有 需求
    + 传统项目时间更容易变化
    + 项目启动阶段，PM在对产品了解不足的情况下，就试图预 测进度
  - 敏捷项目时间管理
    + 范围是可变的，团队可以处理在时间范围内优先级比较高的 需求
    + 团队以迭代的方式开展工作，优先完成高优先级，高价值需 求
    + 在项目进行中，团队不断评估给定时间内能完成的任务
    + 团队基于迭代的实际开发速率来决定长期时间估算，在项目 过程中会根据迭代速率调整时间估算

## 问题

* 项目定位不稳定，缺乏明确目标
* 需求变化过于频繁
* 需求不合理
* 用户、客户等涉众意见不合
* 需求和工作拆分不详细
* 工作量过载
* 团队成员不想学习新东西
* 流程或运作模式笨重
* 团队之间协作不良、能力不足、异地分布
* 需求实现技术复杂
* 代码或架构不良
* 开发、测试、运维协作不良

## 坏习惯

* 不会划分优先级：如果认为所有任务都很重要，也就意味着所有任务都不重要
  - 每次仅完成一件事，并将其做到最好
* 祥林嫂式的抱怨：一方面他们往往散发着浓郁的负能量，看着什么都充满怨念，另一方面，不愿意或者不能够提出任何有效的改进方法。
* 眼高手低：缺少的不是用简笔画画出几个圆圈，而正是那些被轻视的细节。用相同的方法和原则把复杂的业务逻辑抽象并归类.技巧是：
  - Code kata
  - 用脚本来自动化一些常见任务
  - 重构复杂的业务代码
  - 通过刻意训练保持动手能力
* 致命的舒适区
  - 大多数情况下，是他们没有勇气走出“舒适区”。他们误以为目前已经熟练掌握的技术永不过期，且是解决手头问题的最佳方案
  - 追逐一切新奇的事物:会浪费你大量的时间和精力在那些可能永远不会涉及的技术上。
  - 对新技术保持好奇和新鲜的态度，同时与其保持一定的距离.花一些时间来保证自己了解其与同类产品的优劣对比，以及主要的应用场景等可以使你不至于在做技术决策时过于盲目和偏颇。
* 后端返回的数据不对
  - 不应该作为一个问题的结论，恰恰相反，它应该是进一步探索的开端：一个更系统的，更端到端的解决问题的方案的开端
  - 这个描述可以指导物理上分离的两组同事一起面对问题，并找出适合当前架构的方案。
* 历史遗留问题
  - 尝试将自己置身事外，并将问题归因到另一些人
  - 当你决定要写点代码出来的那个时刻起，代码和架构就已经在准备腐坏了，除非你花费足够多的时间和精力去将其不断完善和修葺。而这正是事物的本性，并不随着人的客观意志为转移。
  - 压根不存在历史遗留问题这回事儿，它们只是普通问题。解决问题的第一步，永远是直面问题，认识到所谓的历史遗留问题是和我们将要开发的新需求，或者要修复的线上defect，以及刚刚sign off的卡上的一个微小的需求变更并无二致
  - 可以像故事墙那样维护一个技术债务板，并定期维护，按照工作量和价值来划分优先级，然后按部就班的将其消除。
  - **建立测试以形成安全网，做适度的重构（小到重命名一个变量，大到删除一个模块），并让代码比之前变好一点点。**

## Desk Check

* Dev 在开发完用户故事之后，流到下一个环节之前对于价值、方案和 AC（验收条件）等的一个快速确认
  - 一般都是在开发人员的座位上利用开发机器来完成
  - 参与人员有 BA（业务分析师）、Dev（开发）和 QA，有时候也会有 UX（用户体验设计师）
  - 内容包括功能、性能、安全、UI 布局等，QA 还会查看底层的单元测试和 API 集成测试，有的团队还会对日志记录进行验收。
* 高效验收清单
  - 提前告知 QA 和 BA:QA 和 BA 往往同时工作在多个用户故事上，可能不会对将要验收的用户故事记得那么清楚，提前熟悉一下用户故事，对于要重点关注的地方有所把握，是可以帮助更有效的进行用户故事验收的。
  - 环境准备就绪:因为是在开发机器上做验收，开发环境变化频繁，保持一个能正常验收的环境非常重要，需要开发人员在召集大家来验收之前确保环境是正常工作的。曾经经历过多次的情况是大家准备就绪，结果一开始发现程序启动不起来了，原来是有代码更新需要重新编译，这样就会浪费大家的时间。
  - 检查点准备好根据用户故事卡上的验收条件（AC）和 QA 提供的测试用例，提前把功能和跨功能的检查点都列好，可以让整个验收过程更加顺畅和高效，尽可能减少关键点的遗漏。同时，对于底层测试和日志信息，也要提前打开相应的 IDE 准备好，理清楚要验收的测试和日志有哪些。
  - 开发自测一遍：开发人员提前根据检查点自测一遍，确保都是通过的，如果有问题就修复好再做验收。
  - 验收流程：根据优先级和依赖关系来进行验收，可以做到有条不紊，尽可能减少对参与人员时间的浪费。一般推荐的流程是：功能->跨功能->UI->测试或日志等。功能和跨功能需求的验证需要 BA 参加，UI 的验证需要 UX 参与，其他的就是 Dev 和 QA 一起就行了。这样的流程能够尽量的节省 BA 和 UX 的时间。
  - 验收形式：推荐开发人员操作演示给其他参与人员的形式，当然也可以是 BA 或者 QA 去操作，没有严格的规范。功能的验收要基于业务来进行演示，不要只是简单的页面操作流程。演示完成后，QA 和 BA 可以对于某些关键点再进行对应的检查，但不要抠过多的细节。

## 经验

1、清晰的变量名和方法名
2、能提取成公共组件/方法/类的的绝不复制粘贴
3、拥抱函数式编程，使用声明式编程（因为可读性强）
4、写好方法/函数注释，写出每一个参数的描述和数据类型，对可选参数赋默认值
5、优先使用组合而不是继承
6、使用智能的编辑器，规避语法错误（因为高效）
7、不搞特殊化，坚持规范，不偷懒
8、使用更高层次的抽象，维护更少的状态，尽量提高代码的复用性

1.善于使用逻辑反转，简化代码
2.多使用接口，可以减少工作量，以及开发粗心的后果
3.使用代码format工具
4.写代码多使用注释，以及抱着给别人写代码看的态度
5.要打log,判断运行时间，多做优化

1:注释。如果你能靠变量名说明原由的，你可以不写，不然请写上注释。
2:变量方法命名。一个清晰的命名可以让后面的人知道这是来干什么的。
3:方法行数尽量少，清晰的结构，尽量用获取的方式来赋值变量，那么就不必把获取的代码全揉在一个方法中。
4:六大原则和设计模式：工厂、策略、代理等用起来会让人感觉很爽，再次来修改代码的时候会比较得心应手。
5:适当运动。在努力的同时，请保持一个好身体。

1.凝聚人的力量，紧密协（合）作。包括业务负责人、开发团队、客户、管理者之间的关系，所有这些关系在以前都是造成项目危机的原因之一，那么，在敏捷时代，我们需要这些角色 紧密合作，最大限度的发挥各个角色的力量.
2.聚焦客户价值，消除浪费（如何聚焦用户价值，即频繁的交付用户可工作的软件，快速收到用户反馈）

* Upgrade early and upgrade often. The closer you are to a new version of Rails, the easier upgrades will be. This encourages your team to fix bugs in Rails instead of monkey-patching the application or reinventing features that exist upstream.
* Keep upgrade infrastructure in place. There will always be a new version to upgrade to, so once you’re on a modern version of Rails add a build to run against the master branch. This will catch bugs in Rails and your application early, make upgrades easier, and increase your upstream contributions.
* Upstream your tooling instead of rolling your own. The more you push upstream to gems or Rails, the less logic you need in your application. Save your application code for what truly makes your company special (i.e. Pull Requests), instead of tools to make your application run smoothly (i.e. concurrent testing libraries)
* Avoid using private API’s in your frameworks. Rails has a lot of code that’s not private but isn’t documented on purpose. That code is subject to change without notice, so writing code that relies on private code can easily break in an upgrade.
* Address technical debt often. It’s easy to think “this is working, why mess with it”, but if no one knows how that code works, it can quickly become a bottleneck for upgrades. Try to prevent coupling your application logic too closely to your framework. Ensure that the line where your application ends and your framework begins is clear. You can do this by addressing technical debt before it becomes difficult to remove.
* Do incremental upgrades. Each minor version of Rails provides the deprecation warnings for the next version. By upgrading from 3.2 to 4.0, 4.0 to 4.1, etc we were able to identify problems in the next version early and define clear milestones.
* Keep up the momentum. Rails upgrades can seem daunting. Create ways in which your team can have quick wins to keep momentum going. Share the responsibility across teams so that everyone is familiar with the new version of the framework and prevent burnout. Once you’re on the newest version add a build to your app that periodically runs your suite against edge Rails so you can catch bugs in your code or your framework early.
* Expect things to break. Upgrades are hard and in an application as large as GitHub things are bound to break. While we didn’t take the site down during the upgrade we had issues with CI, local development, slow queries, and other problems that didn’t show up in our CI builds or click testing.

## 敏捷开发十二原则

* Our highest priority is to satisfy the customer through early and continuous delivery of valuable software. 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意
* Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage. 欣然面对需求变化，即使在开发后期也一样
* Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale. 经常交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期
* Business people and developers must work together daily throughout the project. 业务人员和开发人员必须相互合作，项目中的每一天都不例外
* Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done. 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标
* The most efficient and effective method of conveying information to and within a development team is face-to-face conversation. 面对面沟通是传递信息的最佳的也是效率最高的方法
* Working software is the primary measure of progress. 可工作的软件是进度的首要度量标准
* Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.敏捷流程倡导可持续的开发，责任人、开发人员和用户要能够共同维持其步调稳定延续
* Continuous attention to technical excellence and good design enhances agility.坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强
* Simplicity--the art of maximizing the amount of work not done--is essential. 以简洁为本，它是极力减少不必要工作量的艺术
* The best architectures, requirements, and designs emerge from self-organizing teams. 最好的架构，需求和设计出自自组织团队
* At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly. 团队定期地反思如何能提高成效，并依此调整自身的举止表现

## 缺点

* 敏捷软件开发的特征是增量的，因此每个迭代都会有新的业务分析，新的开发工作在进行。这带来的一个问题是，不会有一个统一的 PRD 文档出现，最后在项目结束时候，交付物中没有好的文档。所以敏捷往往强调可交付的软件更为重要，在代码质量上下功夫，做到代码即文档
* 参与人员都是根据团队划分的，例如独立的 PM、BA、DEV，不再存在管理部分、研发部门。带来的矛盾是对个体的要求变高了，有时候往往一个团队中只有一个 BA 或者 UI，对新人挑战较大

## 敏捷测试

* 宣言
  - 全程测试介入
    + 敏捷测试提倡测试左移和右移，从软件生命周期的早期（左侧）一直到产品发布上线后的生产环境，都需要有测试的介入和测试活动的开展。
    + 左移是为了更好的理解和澄清需求，以减少需求理解不一致导致的浪费；而右移是充分利用生产环境的数据来优化开发和测试流程，以增强软件系统应对各种不可预测性的能力。
    + 左移和右移并不仅仅是将测试活动移到两侧端点，更强调的是每个环节的参与，也就是全程测试介入，这是从流程上保障高质量软件交付的关键。
  - 团队整体对质量负责
    + 敏捷提倡全功能团队，团队的角色之间分工不再那么明确，不同角色间的协作更加密切，团队一起为质量负责，是敏捷测试需要遵循的指导性原则。
    + 团队需要对质量目标有统一认识，在敏捷软件生命周期的每个环节有不同角色的共同参与，实现质量目标是每个角色的职责。
  - 持续性的精准自动化测试
    + 自动化测试是敏捷测试的基础，是快速反馈的必要手段。自动化测试不能一味的追求覆盖率，而是要追求有目的的精准覆盖。也就是说，自动化测试首先必须是有效的，是基于业务风险考虑的，才能真正实现快速反馈。
    + 自动化测试需要能够在持续集成流水线上持续的运行，为每次代码提交提供反馈，以确保系统功能不会因为新代码的提交而被破坏；同时，随着功能的不断迭代，自动化测试需要相应的更新、增加，确保新功能是有有效自动化测试覆盖的。
  - 质量内建
    + 质量内建是敏捷测试的核心，需要将测试全程介入、团队为质量负责和持续精准的自动化测试结合起来，在敏捷软件生命周期的每个环节做好缺陷的预防，把质量融入到产品的开发构建中
* 原则
  - 目标在于和团队一起尽快地交付高质量软件
  - 测试人员尽早参与软件早期阶段，与所有团队角色合作，通过实例化需求，确保对业务价值理解的一致性。
    + 测试左移
  - 测试人员关注生产环境状态，收集数据，指导和优化前期的分析、开发和测试。
    + 测试右移:由于生产环境的特殊性，并不能将测试活动简单右移到生产环境，只能通过收集和分析生产环境的数据，利用这些数据来优化开发、测试和业务价值，让生产环境和开发过程形成良性环路
  - 测试人员和开发人员同处一个产品项目团队，而不是独立的测试团队或部门。
  - 测试人员负责探索性测试，和开发人员结对，设计、实现和维护自动化测试。
    + 单元测试和接口测试主要由开发人员负责
    + 界面层自动化测试同样需要开发人员一起参与设计、实现和维护，这样才更高效
    + 可以让测试人员抽离出来去做更有价值的事情——探索性测试。
  - 自动化测试在流水线中持续精准执行，快速发现每次代码提交对于已有功能的影响。
  - 测试数据对于自动化测试是充分的，并能按需获得。
    + 包括正常和异常情况的覆盖、满足不同环境或不同平台的执行要求等
    + 需要有完善的数据创建和管理方案，确保不同需求下的自动化测试能够获得相应的测试数据。
  - 测试活文档化，和代码一起，作为知识资产进行版本化管理。
  - 自动化测试需要有效的分层。
    + 根据不同的测试对象进行有效分层。
    + 越往底层的测试实现成本更低、执行更高效、定位更准确，但覆盖范围有限，不能跟业务很好的关联；
    + 越往顶层的测试越接近业务、更能体现业务价值，但是执行速度、稳定性较差、定位问题较难。
    + 需要根据系统要求、技术架构等项目具体情况规划每层测试的合理占比，不能盲目的追求多而全的覆盖
  - 预防缺陷，而不是关注缺陷的数量。
    + 质量内建是敏捷测试追求的核心价值观，而质量内建本质上就是缺陷预防。
    + 敏捷测试需要团队把重心放在预防缺陷上，提高软件的内建质量，而只关注缺陷数量、甚至把缺陷数量当做考核指标的情况是违背这一核心价值观的
    + 对缺陷数量趋势的正确跟踪和对缺陷根因的深入分析，是帮助预防缺陷的有效手段，是值得推荐的。

* 敏捷阶梯模型，表示团队在互信的基础上，以消除“价值最大、质量最差”这个最大瓶颈为愿景，“尽早、频繁、小批”地进行PDCA（Plan/Do/Check/Adjust）迭代，一个迭代进步一点地进行改进

## 风险管理 risk management

* why:Software developmentprocess involves many factors,so analyze and plan is necessary beforeyou start developing, otherwise, seriouserrorsmay occur
* what 构成
  - 风险事件
  - 风险概率 probability
  - 风险影响 impact
* when 风险管理越早越好
  - Yesterday's problemsare today's risks
* where
  - 商业风险
  - 外部风险
  - 技术，质量和性能风险
  - 管理风险
* who
  - 在敏捷团队中，整个团队都需要参与到风险管理中
  - 客户
  - 销售和售前
  - 所有利益相关者
  - 专家
  - Probability & Impact–概率影响矩阵
  - Sensible–敏感性分析
  - DecisionTree–决策树分析
  - Monte CarloSimulation -蒙特卡洛分析（模拟工具，获取概率分布曲线）
* how Risk Management Cycle
  - 风险识别 RBS
    + 针对风险事件进行识别
    + 谁参与识别
    + 关注风险类别而不是结果
    + 产出风险列表，触发和制约条件
    + 工具
      * Delphi–德尔菲技术
      * Brainstorming–头脑风暴
      * Cause/effect–根因分析
      * SWOT–态势分析
      * Assumption&Constraints–假设和制约分析
  - 风险评估和分析
    + 定性分析,输出**概率影响矩阵**
    + 定量分析:目标-寻求不确定条件或者结果下的最佳项目管理决策
      * 基于数据进行分析
      * 定量分析结果趋势
      * 工具
        - Sensible–敏感性分析（龙卷风图）
        - Monte Carlo–蒙特卡洛
        - Decision tree–决策树
    + 更新风险列表并排优先级
  - 风险应对
    + 负面风险应对策略
    + 正面风险应对策略
    + 触发条件
    + 应急应对策略和备用策略
    + 更新项目规划
  - 风险监控
    + 识别，分析和规划新识别的风险
    + 持续跟踪并重新评估风险列表（尚未发生）
    + 解决已发生风险的行动举措
    + 更新风险管理计划
    + 由于项目变更或风险发生而导致的现有项目风险变更（二次风险和残余风险）
    + 新发现的风险（风险跟踪和控制）
    + 已发生并已解决或不再可能发生时,关闭风险
    + 评估风险管理计划的有效性与应对效力
    + 应急储备评估
    + 汲取的经验教训可用于将来的项目

## 工具

![Likelihood Matrix](../_static/likelihood Matrix.jpg "Optional title")
![Important & Difficult Plan Matrix](../_static/important_difficult_plan_matrix.jpg "Optional title")  get this priority data as part of your backlog

![Ishikawa Diagram(Cause/Effect)](../_static/ishikawa_diagram.jpg "Optional title")

* 1943 Created by chemical engineer Kaoru Ishikawa
* Every problem has a specific cause, thereby eliminating the root cause
* From generic to specific problem

## 图书

* 解析极限编程
* 精益思想
* 《持续交付》Jez Humble
* 持续交付2.0：业务引领的DevOps精要 乔梁
* Agile IT organization design
* [Google工作法](https://www.yuque.com/heqingbao/msfy2c/zg56gm)
* 《Clean Agile》
* The Unicorn Project
* 软件需求与可视化模型
* 精益创业
  - MVP：优先最小化可行产品
* 大教堂与集市
* 《深入核心的敏捷开发》

## 软件

* OpenUP
* MyCollab
* Odoo
* OpenProject
* OrangeScrum
* Taiga
* Tuleap
* Jira Software from Atlassian
* conflurence : document
* VivifyScrum
* Binfire
* VersionOne
* Wrike
* Zoho Sprints
* PivotalTracker
* Assembla
* Planbox
* Axosoft
* [TAPD](https://www.tapd.cn/official/index):腾讯敏捷研发体系十余年的发展成果，为产品研发全生命周期提供解决方案，支持敏捷需求规划、迭代计划跟踪、测试与质量保证、持续构建交付等全过程研发实践
* [snipper](https://snipper.io):you collaborate with your friends on the same code in real time and keep track of versions.

## 参考

* [](https://www.atlassian.com/agile)
* [AGILE FLUENCY PROJECT](https://www.agilefluency.org/)
