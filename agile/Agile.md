# 敏捷实施@ThoughtWorks

* 一种不停尝试、不停调整、不停优化的状态
* 产品和业务开发本来就是一个探索的过程，开始时一定是最无知的时刻。项目中的大部分决策也一定是在项目开始的时刻做出的，这将有一个重大的悖论，在最无知的时刻，做出了最重要而且是绝大部分的决策，并把它作为随后执行的依据。
    - 通过迭代应对这一问题，只做初始决策，定大致的方向
    - 通过市场反馈不断修正对产品的认知，增量的决策和调整
* 通过迭代将瀑布模型分隔成更小的周期，从而实现迭代.每一次迭代时间可能是2周。每个迭代都能都有交付的工件，如果交付物不能满足市场或客户需求。可以在下一个迭代再一次进行分析、调整和开发，从而响应变化
* 敏捷开发:“60% Scrum + 40% XP

## [开发模型演化](https://mp.weixin.qq.com/s/FtJFtGYu_jA2aBCD2aCUhA)

* 瀑布开发
    - 通过里程碑，将大的项目变成小的、可控的工作；
    - 通过里程碑的环环相扣，顺序操作，让方案简单可以实施
    - 问题：
        + 需求文档经常描述不清楚，或者遗漏。
        + 工作人员经常认为编码完了，工作就完了。
        + 各种设计文档工作量很大，内容乏味，但编码完成后基本都对不上了。
    - 本质问题并不是阶段，而是批量。需求批量地在一起进行设计，然后是批量地开发，批量地测试、交付等等
        + 批量让价值交付延迟，所有需求在最后的阶段才能交付，价值交付比较晚
* V模型:是瀑布模型的变种,凸显了测试和开发环节的对应关系
* 原形模型
    - 原形要解决的问题就是需求不准，避免需求经过长时间的开发，浪费了大量的金钱和人力，得到的软件还不是用户所期望的。
    - 采用的方式是：开发团队在分析需求的时候，尽快开发出一个用户看得到的原形，让用户尽早感受到效果。其实原形模型更多的是一种沟通方式，只是有人不丢掉原形，在原形的基础上继续开发，才被定位为原形模型。不过原形的开发过程时间紧，任务重，结果非常粗糙，重用的成本一般很高，建议还是丢掉。
    - 制作原形的时候，有时会做得很逼真，用户可以像真的系统一样操作，只是后台的逻辑都是假的；有时会做的很简洁，只是一些图片。据说iPad的开发过程使用了原形，那个时候的原形仅仅是一个木板，上面画了几个按钮，想要做什么就在上面假装点点，想象着它完成了想要的操作。只要有好的沟通效果，形式不重要
* 迭代模型:将大的需求变成小的需求，让问题的复杂度降低了很多
    - 当需求变小后，每个需求的开发过程就会变简单，每个阶段的工作也都可控了。每个迭代的需求都像瀑布模型一样有分析、设计、开发、测试，但是因为需求小，对文档的依赖减弱很多。
    - 开发人员可以将前一个迭代学到的东西用在下一个迭代，开发越来越顺畅。
    - 为开发不确定需求提供了可能。虽然整个需求没有完全想清楚，但是想清楚的部分可以先开发。
* 敏捷核
    - 快速交付，持续重构
        + 通过TDD过程，在开发需求之前就细化了需求的细节，对详细设计的结果有提升。
        + TDD产出的测试用例，提升编码质量，避免反馈周期长。如果没有测试用例，一个Story很容易被当皮球踢。
        + 项目中遗留的测试用例，能避免软件成为打地鼠软件。当增加一个A功能，发现B功能有问题，修复了B功能发现C功能故障了，修复了C功能，发现A功能又故障了。
        + 通过Pipeline，让构建、测试更频繁，因为工具化了，成本更低，出错更少。
        + 通过Pair、CodeReview，让知识流动起来。
    - 演进的需求和方案
        + 用户的需求一般都只是一个大方向，具体的价值和实现方式都是不确定的，用户也在不断探索他们的业务。敏捷接纳了原型法的需求分析方法，还提出了Inception来分析更有价值的需求，通过MVP圈定最小开发范围，快速验证方案，这就是演进的需求和方案
        + 确定的需求设计好，不确定的需求就需要演进
    - 自组织(Self-Organizing)且跨功能的团队
        + 每个人都致力于项目的目标，团队成员互相尊重，每个人都专注于工作，开放，团队成员有勇气站出来参与该项目。这里最关键的就是每个人都致力于项目的目标

## 目的

* 更快的交付价值
    - 更早的交付:当向用户交付产品后，用户反馈,瞬间狂涨知识，并感叹道“你怎么不早说呢？”
    - 更多可能的是，用户这时才清楚或能够描述他们要的是啥，更有甚者，我们可能一开始连用户是谁也未必能准确地定义
    - 产品和业务开发本来就是一个探索的过程，开始时一定是最无知的时刻。 项目中的大部分决策也一定是在项目开始的时刻做出的，这将有一个重大的悖论，在最无知的时刻，做出了最重要而且是绝大部分的决策，并把它作为随后执行的依据
    - 通过迭代应对这一问题，只做初始决策，定大致的方向。通过市场反馈不断修正对产品的认知，增量的决策和调整。
* 有效学习和灵活响应变化
* 缩短开发周期
* 提高质量
* 提升用户满意度
* 提升团队人员能力
* 增强协作
* 减少工作量，提高产能
* 产品创新
* 改变管理方式，增强成员参与感

## 核心价值观

* 个体和互动 高于流程和工具
* 工作的软件 高于详尽的文档
* 客户合作 高于合同谈判
* 响应变化 高于遵循计划

## 措施

* 建立敏捷实施工作组
* 领导积极参与敏捷实施工作
* 培养企业内部敏捷教练
* 建立技术内部团队来落地持续集成、自动化测试等交付技术
* 雇佣外部敏捷教练
* 例行敏捷会议
* 组织敏捷相关工作
* 调整运作流程规范
* 新的敏捷角色，Scrum master
* 调整绩效管理制度
* 把敏捷改进设为团队目标
* 建立一系列实践社区
* 改造原有系统架构，更快速响应变化
* 敏捷开发
* 极限编程
* 快速迭代
* 持续集成
* 精益创业

## 实践

* 需要自适应的规划、演进式的开发和交付
* 极限编程Xtreme Programming（XP）
* 精益方法Lean
* DevOps:基于其它两个领域的实践:精益和敏捷。不是一个公司内的岗位或角色；它是一个组织或团队对持续交付、持续部署和持续集成的坚持不懈的追求
    - Gene Kim（Phoenix 项目和 Unicorn 项目的作者）认为，有三种方式定义 DevOps 的理念：
        + 第一种: 流程原则
        + 第二种: 反馈原则
        + 第三种: 持续学习原则
    - 一种灵活的实践，它的本质是一种关于软件开发和 IT 或基础设施实施的共享文化和思维方式
        + 软件交付能力很重要，它极大地影响到组织的成果，例如利润、市场份额、质量、客户满意度以及组织战略目标的达成。
        + 优秀的团队能达到很高的交付量、稳定性和质量；他们并没有为了获得这些属性而进行取舍。
        + 可以通过实施精益、敏捷和 DevOps 中的实践来提升能力。
        + 实施这些实践和能力也会影响你的组织文化，并且会进一步对你的软件交付能力和组织能力产生有益的提升。
        + 懂得怎样改进能力需要做很多工作。
* 特性驱动开发Feature-Driven Development（FDD）
* 测试驱动开发Test-Driven Development（TDD）
* 水晶方法Crystal
* 动态系统开发方法Dynamic Systems Development Method（DSDM）
* 自适应软件开发Adaptive Software Development（ASD）
* [Scrum](https://www.scrum.org/):一个框架，采用该框架的团队通常由一个 Scrum 教练、产品经理和开发人员组成，该团队以跨职能、自主的工作方式运作，能够加快软件交付速度从而给客户带来巨大的商业价值。其关注点是较小增量的快速迭代
    - 一个团队有自己的代办事项，对代办事项进行拆小。
    - 按客户价值进行优先级排序，产品经理负责价值排序。
    - 小而稳定，跨职能团队。
    - 多个团队松耦合（依赖性比较低），对齐迭代时间和战略目标。
* 看板Kanban（可视化工作流）:是一个敏捷框架，有时也叫工作流管理系统，它能帮助团队可视化他们的工作从而最大化效率（因而变得敏捷）。看板通常由数字或物理展示板来呈现。团队的工作在展示板上随着进度而移动，例如从未启动到进行中，一直到测试中、已完成。看板使得每个团队成员可以随时查看到所有工作的状态。
* 大规模敏捷（SAFs LeSS）
* 特性团队
* 领域建模，可变化设计（UML）
* 结对编程
    - 硬件设置
        + 需要一个大的外接显示器和有一个可以调节高度的桌子（当然也可以用纸箱子DIY一个低配版:直接决定结对能不能作为一个可持续的团队工程实践.
        + 纸和笔永远是你（们）的好朋友，在实际动手写代码之前，请拿出纸笔来将要做的事情划分成更细粒度，可以验证的任务列表，贴在显示器的下边缘。最后，另外记得将手机调成震动模式，利人利己。
    - 软件设置
        + 可以切换到自己熟悉的Keymap：在Intellij/WebStorm里 Ctrl+`来切换各种设置
        + 至少熟悉一个IDE/编辑器，比如通过纯键盘的操作完成
            * 按照名称查文件
            * 按照内容搜索
            * 定位到指定文件的指定行/指定函数
            * 选中变量，表达式，语句等
            * 可以快速执行测试（可以在命令行，也可以在IDE中）
        + 熟常基本Shell技能和常用命令行工具的使用，可以完成诸如
            * 文件搜索
            * 网络访问
            * 正则表达式的应用
            * 查找替换文件中的内容
    - 结对双方会有一个人比较有经验，而另一个人则在某方面需要catchup：需要双方有一个人来做主导，另一个人来观察，并在过程中交互，答疑解惑，共同完成任务。
        + 主导者
            * 千万不要太投入，而无视peer的感受
            * 主导者太热心的coach，而忽视了给新人实际锻炼的机会。这时候需要主导者给peer更多的实践机会：比如在带着新人编写了一个小的TDD循环（红绿重构）之后，可以抑制住自己接着写的冲动
            * 看到peer正在用一个不好的做法来完成任务时，你可以即使让他停下来，并通过问问题的方式来启发他： 还有更好的做法吗？  你觉得XXX会不会更好？
        + 观察者：抓住一切可能的机会来向你的peer学习
            * 快捷键的使用：通过快捷键删除了花括号（block）中的所有代码
            * 命令行工具参数的应用：将curl的返回值以prettify过的样式打印到控制台
            * 良好的编程习惯：通过命令行merge了一个PR
            * 保持你的专注力和好奇心
        + 实践的时候，可以采取Ping-Pong的方式来互换主导者和观察者的角色。比如，A写一个测试，B来写实现，A来重构，然后换B来写测试，A来实现，B来做重构等等
    - 保持专注
        + 需要一起完成任务划分。这样可以确保你们可以永远关注在单一任务上，避免任务切换带来的损耗。
        + 在做完一项任务后，用mark笔轻轻将其从纸上划掉（或者打钩）。
            + 既可以将你们的工作进度很好的表述出来，
            + 在任何时候帮助你们回到正在做的事情上
            + 另外这个微小的具有仪式感的动作是对大脑的一个正向反馈，促进多巴胺的分泌
    - 无法统一的意见
        + 所坚持的只是一个假的“真理”，先前的坚持和做技术选型时的理由就变得很可笑：那只不过是为了使用自己熟悉的技术而编造的理由而已。保持open mind是一件知易行难的事情，希望大家在争辩时能念及这个小例子，可能会少一些无谓的争辩。
        + 难以统一意见的场景，我建议可以将其搁置，先按照某一种提议进行，知道发现明显的，难以为继的缺陷为止。
        + 技术选型时我自然的选了更早项目中使用的scss module，而团队里的另一个同事则提议使用styled-component。我们谁也没有说服谁，最后写代码的时候就有两种风格。直到有一天，我在代码库里看到了用styled-component写的很漂亮的组件，我自己尝试着把相关的scss重写成styled-component，结果发现确实比单独的scss文件要更好维护一些，而且也不影响既有的测试。
    - 棘手的任务
        + 两人分头研究，并严格控制时间。比如Time box 30分钟。不过很可能在30分钟后，你们中至少有一个人已经对要怎么做有了头绪，如果30分钟还没有头绪，则可以求助团队其他成员。
    - 张弛有度
        + 普通人很难全神贯注在某件事情上超过30分钟。这时候一个短暂的break可以让大脑得到很好的休息。
            * 从Todo列表中找出下一个任务
            * 设置一个不可中断的25分钟，开始工作
            * 时间到了之后，休息5分钟
            * 重复2-3，4次之后休息15分钟
    - 结对轮换
        + 需要定期或者不定期的轮转，比如一周轮换一到两次，A和C来写订单，B和D来写门店管理，这样可以保证领域知识，工程实践，工具的使用等等知识都很好的在团队内部共享。
        + 发现让不同角色的团队成员轮换结对所带来的好处（伴随着短期阵痛的）远胜过知识的隔离带来的坏处。团队中的前端开发如果花费一些时间和DevOps一起结对，他会对系统的整个架构更加清楚；而后端开发和DevOps结对则可能让他意识到代码中的潜在缺陷和解决方法
    - 尊重
        + 如果你不愿意和某一特性的人结对，那么首先不要让自己成为那样的人。
        + 尊重还体现在很多其他细节中。当你不得不中断结对而去做其他事情时，务必让你的peer知道。当你的peer回来之后，你需要及时和他catchup，告诉他你正在做什么，已经做到了哪一步等等。快速的将他带入到上下文中。
    - 控制情绪：具有很强的传染性
        + 当你们的工作任务收到各种blocker，被各种其他事情干扰而导致进度难以推进时，一定要注意自己情绪的控制。如果你的peer一直在旁边唉声叹气，或者抱怨连连，你会变得非常沮丧，并且很难集中精力在积极解决问题上。
    - 需要总结一下自己记录的知识点，这是一个绝佳的提升自己能力的方法。通过实战，发现自己的缺点，并通过近距离观察别人如何解决该问题，最终会以很深刻的印象记录下来，这时候针对性的查漏补缺是可以取得非常好的效果。
* 验收驱动开发（ATDD）
* 自动化测试
* 持续发布
* 持续集成
* 设计思维
* 前端需求管理的敏捷（需求价值分析、电梯演讲、MVP）
* 敏捷管理工具（JIRA、TFS、RTC、Rally）
* 微服务框架
* 精益创业、黑客营销
* 项目组合的敏捷管理
* 预算与绩效管理的敏捷

* 物理墙：看到要做的事情、正在做的事情和已经搞定的事情，并且要有owner
* 以周为一个迭代，大概经过n个迭代就可以顺利release了
* 做记录量化统计
* 重构
* Retro
    - 一定要可视化出来
    - 年初时都做过展望与总结

## 敏捷开发

* 核心原则
    - 价值驱动
    - 技术卓越
* 实践
    - 基于统一迭代节奏的全功能团队:为了交付软件所需要的技能都应该在一个团队里
        + dev
        + BA：分析下一个迭代卡，验收当前完成的卡
        + QA：给下一个迭代卡片写AC，测试当前迭代卡
        + UX：
    - 基于Story的需求及范围实时管理
        + Story是开发团队的最小工作单元
        + 工具是燃起图（Burn-Up）和累积流量图（CFD来至于Kanban）
    - 基于持续集成和测试前置的质量内建
        + 持续集成纪律有两条核心，第一是必须每次提交触发构建；第二是每次提交必须基于上次的成功构建
    - 基于Velocity和Cycle Time的持续改进

## 工作量估算

* 用故事点为单位估工作量，是正确的做法
    - 纯粹对用户故事大小的相对度量，不应该跟任何的天数或者工作量等关联。
    - 用户故事本身的大小属性不会发生变化，基于故事点的估算不会过期，不会受到团队技术能力和业务领域熟悉度的影响而发生变化。比如，一个点数为3的用户故事，它的复杂度相对于那个点数为1的基准故事来说不会发生变化，不管谁、也不管用什么技术来开发这个用户故事。
    - 故事点的大小是指团队所有角色工作加一起的统一估算数值，需要多个角色一起合作讨论才能得出这个估算，因此，故事点的估算方法有利于帮助团队实现跨功能合作的行为
    - 特别注意，不应该按照开发的点数、测试的点数去估算用户故事的大小，需要结合一起给出一个唯一的数值。
* 用人天为单位估工作量，是错误的做法
    - 基于这样的假设：
        + 所估算的故事是唯一要做的工作
        + 所有需要的东西在故事开始前都会准备好
        + 故事开发过程中不会被打断。
    - 理想时间跟耗用时间是不同的。理想人天的估算是基于理想时间的，在软件开发过程中会有多个因素导致实际耗用时间跟理想时间会有很大的不同，比如开会、讨论等。
    - 很容易让人根据一个故事所需完成的任务多少去估算，而不是从这个故事跟其他故事的相对大小角度去考虑；不同人估算的理想人天也会有不同，导致估算可能会不太准确
* 因为「工作量」按照定义就是一个「量」的概念，而不是「时间」的概念。最多的一个例子：搬一千块砖，就是搬一千块砖的工作量。搬得快，它是一千块砖；搬得慢，它还是一千块砖。工作量的大小，是与时间无关的。 `工作量 ➗ 速率 = 时间`
* 如何知道速率
    - 知道谁来做这个故事吗？生手和熟手程序员，速率是不一样的吧。
    - 知道做的人每天花多少时间来做这个故事吗？外部干扰多的一周，和外部干扰少的一周，体现在每天上的速率是不一样的吧。
    - 知道在什么时候做这个故事吗？项目初始阶段，和项目临近尾声，开发一个故事的速率是不一样的吧。
* `项目总体工作量 ➗ 团队速率 = 预期交付时间`:昨天的天气。要跑两个迭代，就会知道这个团队的速率
* 用时间来估工作量:因为他们假设速率是常量。既然速率是常量，那么工作量与时间就始终成正比.背后的观念
    - 程序员都是可替换的「人力资源」，A程序员和B程序员是没区别的，生手程序员和熟手程序员是没区别的，这个程序员离职了马上去大街上招一个，对速率也是没有重大影响的。
    - 程序员是不会成长的，在项目启动阶段的速率是这样，做到项目结尾时，速率还是这样，程序员并不会在项目过程中收获经验和技能，程序员的速率不会因为知识和熟练度的增加而提高。
    - 团队的环境是无关紧要的，团队成员彼此协作的方式要么不可能有任何改变、要么这种改变不会对速率产生任何影响
    - 只有预设了程序员就是机器上无差别可替换的齿轮时，一个团队、一个公司才会认为：软件开发的速率是一个常量
* 什么情况需要重估
    - 没有在预定的天数内完成考虑给故事涨点，也就是重估，这种以进度来驱动重估的做法是不对的,不能是因为做不完赶不上进度而调整。没有在估算天数内做完可能有两个方面的原因
        +  估算不准确，低估了
        +  被其他工作所打断，或者团队技术原因导致进度较慢...
    -  不需要重估的情况
        + 假设一个团队有4个复杂度相当的用户故事，原本估算均为3，预计能够在一个迭代完成的。在第一个迭代结束后，只完成了其中的两个用户故事，也就是完成了6个点，团队感觉这两个用户故事比预估的要大，想调整为原来点数的两倍，由6变成12；由于四个用户故事的大小相当，剩下的两个用户故事也需要调整为原来的两倍，剩下的工作量也变成了12，同样的可能还需要一个迭代才能完成。这样的重估就没有意义。
        + 如果只是发现用户故事实际耗费时间比原来预测的要多，但是**故事的相对大小并没有问题的时候**，不需要重估，而是要去回顾和分析耗费时间长的原因，并采取相应的措施去改进。
    -  需要重估的情况
        +  假设团队由A、B、C、D四个用户故事，刚开始给每个故事的估点均为3。在开发故事A的过程中发现A比原来估算的值要大，需要调整为5才合适，另一个类似的故事B也是一样，需要调整为5；但是C和D跟它们不一样，估算值应该是准确的，还可以保持为3。这种情况下对A和B的重估是有价值的，因为**相对大小发生了变化**。
* 速度（Velocity）
    - 对团队的进度生产率的度量，可以通过计算团队在一次迭代中完成的用户故事所分配的故事点数的总和来得到。比如，完成5个3个点的用户故事，速度是15；如果完成了2个5个点的用户故事，速度是10。关于“完成”的定义不能只是到“开发完成”，而应该是“交付完成”
    - 可以修正计划的误差。估算把对工作量的估算和对工作时长的估算完全隔离开来，将必须完成的所有用户故事的点数总和除以迭代的速度，可以推算出迭代的次数，也就是项目持续时间
    - 假设团队估算出项目中包含了200个故事点的工作，一开始认为可以在每次迭代中完成25点，也就是将用8次迭代来完成工作。但是，在项目开始以后，团队发现速度只能达到20点。这样，不用对任何工作进行重估，就可以正确的认识到项目需要10次迭代，而不是8次。
    - 速度不会是稳定不变的。根据团队对技术和业务领域知识的熟悉程度，速度可能会增加；而随着团队人员调整，有新人加入以后，速度可能会下降。在故事点估算准确的情况下，速度正好是反映团队状态的一个参数。不应该为了保持速度的不变去调整估算的结果，而应该根据速度的变化来观察和分析团队的健康程度。
* 估算与计划
    - 估算是为了更好的做计划，通过估算推算出的持续时间是一种可能性，而不是对交付时限的一种承诺。估算的是用户故事固有的属性，其大小不应该受到交付时长的干扰。
    - 客户都会希望更短的时间交付更多的功能，但是不要让客户只把目光关注到进度上，要引导客户更多的关注交付的业务价值。因此，在考虑任务的优先级的时候，需要以价值为导向，而不是进度为导向。比如，重构等技术改进、性能调优、生产环境的支持，这些可能比新的特性开发带来的价值更大、有着更高的优先级。

## DevOps vs 敏捷

* 相似之处
    - 毫无疑问，两者都是软件开发技术。
    - 敏捷已经存在了 20 多年，DevOps 是最近才出现的。
    - 两者都追求软件的快速开发，它们的理念都基于怎样在不伤害客户或运维利益的情况下快速开发出软件。
* 不同之处
    - 两者的差异在于软件开发完成后发生的事情。
        + 在 DevOps 和敏捷中，都有软件开发、测试和部署的阶段。然而，敏捷流程在这三个阶段之后会终止。相反，DevOps 包括后续持续的运维。因此，DevOps 会持续的监控软件运行情况和进行持续的开发。
    - 敏捷中，不同的人负责软件的开发、测试和部署。而 DevOps 工程角色负责所有活动，开发即运维，运维即开发。
    - DevOps 更关注于削减成本，而敏捷则是精益和减少浪费的代名词，侧重于像敏捷项目会计和最小可行产品的概念。
    - 敏捷专注于并体现了经验主义（适应、透明和检查），而不是预测性措施。
    - 敏捷    DevOps
    - 从客户得到反馈 从自己得到反馈
    - 较小的发布周期 较小的发布周期，立即反馈
    - 聚焦于速度   聚焦于速度和自动化
    - 对业务不是最好 对业务最好

## [敏捷度量](https://mp.weixin.qq.com/s/khJRYAPhK5QP-2Bqi8YzwA)

* 为什么要做度量（Why）：敏捷项目通过度量来拉通目标和行动、指导团队制定工作计划和任务，并协助团队持续改进。
    - 拉通目标和行动：可工作的软件长什么样子，它具备什么功能，它为谁提供价值，采取什么样的行动能获得这些价值，这些都是敏捷团队需要回答的问题，敏捷团队不仅仅要知道问题的答案，为了快速实现目标，敏捷团队还需要定期评估行动的效果，为了拉通目标和行动，度量的引入能帮助团队及时纠偏，少走弯路，减少浪费。
    - 定位当下的位置，计划下阶段的任务：实际工作中，经常会有客户邀请我们的顾问评估一下他们的现状，他们基于现状做下一个阶段或者下一年度的计划，这样的诉求在接近季度末或者年底的时候尤其多。正如人需要定期做体检一样，体检结果让我们对自己的身体状况有更好的了解，敏捷项目也需要定期的健康度评估，这些评估和度量的结果，除了揭示项目存在的问题，还能够帮助团队总结经验反思教训，从而更好的指导下一阶段的计划。
    - 改进，改进，改进：敏捷项目推崇持续改进，以更好的方式、更快的速度交付更优的价值，这是很多团队追求的目标，这个目标不是一蹴而就的，有的时候团队需要引入更好的工具，有的时候团队需要借鉴更丰富的经验，有的时候则依赖团队持续的成长。敏捷项目引入工具和他人经验的过程也是不断试错的过程，在试错的过程中团队需要知道哪些改变是成功的，哪些是失败的，这个评估通常是通过度量来完成的，所以引入度量也是为了更好的改进。
* 度量什么（What）：如果敏捷项目是一个长方体的话，长方体的体积代表团队所要交付的目标，长方体的长、宽、高决定了长方体的体积。敏捷项目度量的是交付效能、团队能力和产品的价值，以及保证这这些目标能够达成的团队健康度。
    - 长度代表交付的速度，也叫交付的效能，长度越长，交付的效率越高，团队也就能更快的接近目标，实际工作中，我们经常听到的研发效能、测试效能、管理效能，cycle time（需求提出到上线所用的时间）等等，都和速度有关，这些指标决定了团队以多快的速度实现目标，这是度量中非常关键的指标。
    - 宽度代表团队的能力，实际工作中，我们提到的测试质量，代码覆盖率，敏捷实践实施，持续集成和交付，统一配置管理，灰度发布，债务管理，松耦合架构，等等，和团队实践以及工具相关的指标都和能力有关，这些指标决定了团队能不能应对不确定性带来的挑战，能不能解决各种复杂、繁杂甚至混沌的问题，能不能做到持续优化和改进。
    - 高度又叫深度，代表产品（软件）价值，实际工作中，我们做的需求价值分析、MVP拆分、产品愿景、优先级排序、价值验证等等，都是团队基于自己的经验展现出的对业务的理解，并在此基础之上准确无误的给出方案，交付客户期望的价值，这些指标决定了团队能不能基于自己深度的积累，精准的帮助客户实现目标，并且能在极少浪费的情况下实现目标。
    - 健康：这个维度就如同我们给这个长方体上的颜色，是沮丧的灰色，焦虑的红色，抑郁的蓝色，还是生机勃勃的绿色？团队是什么成熟度，项目整体是否健康，这些也需要度量，常见的指标，比如，项目满足的财务指标，干系人管理，团队协作，团队成长，管理的透明化，成员的稳定性等等，敏捷团队健康度这个维度决定了团队能否长期稳定的以此种方式工作，团队能不能自我优化。
* 谁来做度量（Who）：由团队共同承诺、共同行动和共同负责来完成。
    - 角色之间交叉度量。团队负责不代表不能有分工，如果团队自行组织度量的话，建议角色互换来度量，比如开发人员做价值交付维度的发起者，需求人员提供信息；测试人员做开发相关指标度量的发起者，开发人员输入信息，这样做能更好的保证度量的客观性，对团队来讲，也是一次不错的知识和经验分享的过程。
    - 引入外部的顾问来做度量。外部的顾问可以是其他团队的人员，也可以是独立的第三方顾问，这样做的好处除了保证度量的客观性，外部顾问还能带来更多的经验，甚至会把跨行业和领域的经验带给团队，帮助团队改进和优化，建设能力。这个方法实施的注意事项是，一定要保证两次度量的评价标准一致，否则会失去度量的价值。
    - 无论是团队自组织做还是引入外部顾问，都需要全员参与。因为度量不仅是团队拉（XI）通（NAO）目标、明确任务、统一行动的机会，度量还能够帮助团队提高凝聚力。
* 什么时候做度量（When）除了例行的度量之外，在经历了大的危机、重大的里程碑事件之后也是执行度量、总结经验和教训来优化和改进的好时机。
    - 项目在经历重大的事件之后，这里专指风险事件或者危机事件，团队需要集体反思、总结教训，这个时候项目需要做一次度量，找到那些把风险带给团队的指标，以此来寻找优化和解决问题的方法。
    - 里程碑事件之后，或者一个关键的MVP 发布之后，团队积累了大量的经验，当然也有教训，这个时候也应该引入度量，评估一下和目标的差距，制定下个阶段的计划，带着经验继续优化和改进。
    - 周期性的度量，建议3-6个月，之所以选择这样一个周期，是因为少于3个月，很多持续性的行动还很难产出效果，长于6个月的话，某些行为具备了惯性，掉头的难度比较大，综合考虑，3-6个月是比较合适的周期，具体选择多长时间，由团队来决定。

## 会议

* 每日例会：每日5分钟左右的一个简单例会，尽可能多的开发人员参与进来对紧要问题的讨论。目的是更新进度和暴露开发中遇到的问题，不应该讨论具体的问题。 15min
* 评审会：需要在迭代周期的最后一天召开，1个小时左右就可以了，需要客户出席，如果客户不能出席，则需要产品经理出席.在开迭代计划会议之前应该准备好所有的需求分析，如果遇到需求不合理应该及时跳过，不应该在会议中寻求解决方案。 2h
* 回顾会（Retro）：在每个迭代结束时进行，总结工作中的经验和教训，时间维持在30-60分钟内，整个团队都需要参加（Scrum Master、Product Owner、开发团队以及客户）。把重点放到上一次行动是否明确执行以及需要改进点上。可以通过投票讨论优先级高的改进点
    - 定量分析:包含团队是否完成了迭代目标，收集并评审迭代度量指标（包括速率、迭代燃尽图、迭代计划故事和实际完成故事、计划发布日期与实际发布日期、客户满意度、团队满意度、生产环境Bug数、生产Bug解决时间、用户故事等）
    - 定性分析:包含哪些工作良好（应该继续保持），哪些做的不好（应该停止）？哪些可以改进（团队选出１－２条在下一个迭代实现）
* 产品展示会议 30min
* 每个会议必须有主持人、会议目标、会议准备，否则会议是冗长而无效的
* 参会人员应该准时到达:对迟到的容忍就是对准时到的人惩罚

## 问题

* 项目定位不稳定，缺乏明确目标
* 需求变化过于频繁
* 需求不合理
* 用户、客户等涉众意见不合
* 需求和工作拆分不详细
* 工作量过载
* 团队成员不想学习新东西
* 流程或运作模式笨重
* 团队之间协作不良、能力不足、异地分布
* 需求实现技术复杂
* 代码或架构不良
* 开发、测试、运维协作不良

## 坏习惯

* 不会划分优先级：如果认为所有任务都很重要，也就意味着所有任务都不重要
    - 每次仅完成一件事，并将其做到最好
* 祥林嫂式的抱怨：一方面他们往往散发着浓郁的负能量，看着什么都充满怨念，另一方面，不愿意或者不能够提出任何有效的改进方法。
* 眼高手低：缺少的不是用简笔画画出几个圆圈，而正是那些被轻视的细节。用相同的方法和原则把复杂的业务逻辑抽象并归类.技巧是：
    - Code kata
    - 用脚本来自动化一些常见任务
    - 重构复杂的业务代码
    - 通过刻意训练保持动手能力
* 致命的舒适区
    - 大多数情况下，是他们没有勇气走出“舒适区”。他们误以为目前已经熟练掌握的技术永不过期，且是解决手头问题的最佳方案
    - 追逐一切新奇的事物:会浪费你大量的时间和精力在那些可能永远不会涉及的技术上。
    - 对新技术保持好奇和新鲜的态度，同时与其保持一定的距离.花一些时间来保证自己了解其与同类产品的优劣对比，以及主要的应用场景等可以使你不至于在做技术决策时过于盲目和偏颇。
* 后端返回的数据不对
    - 不应该作为一个问题的结论，恰恰相反，它应该是进一步探索的开端：一个更系统的，更端到端的解决问题的方案的开端
    - 这个描述可以指导物理上分离的两组同事一起面对问题，并找出适合当前架构的方案。
* 历史遗留问题
    - 尝试将自己置身事外，并将问题归因到另一些人
    - 当你决定要写点代码出来的那个时刻起，代码和架构就已经在准备腐坏了，除非你花费足够多的时间和精力去将其不断完善和修葺。而这正是事物的本性，并不随着人的客观意志为转移。
    - 压根不存在历史遗留问题这回事儿，它们只是普通问题。解决问题的第一步，永远是直面问题，认识到所谓的历史遗留问题是和我们将要开发的新需求，或者要修复的线上defect，以及刚刚sign off的卡上的一个微小的需求变更并无二致
    - 可以像故事墙那样维护一个技术债务板，并定期维护，按照工作量和价值来划分优先级，然后按部就班的将其消除。
    - **建立测试以形成安全网，做适度的重构（小到重命名一个变量，大到删除一个模块），并让代码比之前变好一点点。**

## Desk Check

* Dev 在开发完用户故事之后，流到下一个环节之前对于价值、方案和 AC（验收条件）等的一个快速确认
    - 一般都是在开发人员的座位上利用开发机器来完成
    - 参与人员有 BA（业务分析师）、Dev（开发）和 QA，有时候也会有 UX（用户体验设计师）
    - 内容包括功能、性能、安全、UI 布局等，QA 还会查看底层的单元测试和 API 集成测试，有的团队还会对日志记录进行验收。
* 高效验收清单
    - 提前告知 QA 和 BA:QA 和 BA 往往同时工作在多个用户故事上，可能不会对将要验收的用户故事记得那么清楚，提前熟悉一下用户故事，对于要重点关注的地方有所把握，是可以帮助更有效的进行用户故事验收的。
    - 环境准备就绪:因为是在开发机器上做验收，开发环境变化频繁，保持一个能正常验收的环境非常重要，需要开发人员在召集大家来验收之前确保环境是正常工作的。曾经经历过多次的情况是大家准备就绪，结果一开始发现程序启动不起来了，原来是有代码更新需要重新编译，这样就会浪费大家的时间。
    - 检查点准备好根据用户故事卡上的验收条件（AC）和 QA 提供的测试用例，提前把功能和跨功能的检查点都列好，可以让整个验收过程更加顺畅和高效，尽可能减少关键点的遗漏。同时，对于底层测试和日志信息，也要提前打开相应的 IDE 准备好，理清楚要验收的测试和日志有哪些。
    - 开发自测一遍：开发人员提前根据检查点自测一遍，确保都是通过的，如果有问题就修复好再做验收。
    - 验收流程：根据优先级和依赖关系来进行验收，可以做到有条不紊，尽可能减少对参与人员时间的浪费。一般推荐的流程是：功能->跨功能->UI->测试或日志等。功能和跨功能需求的验证需要 BA 参加，UI 的验证需要 UX 参与，其他的就是 Dev 和 QA 一起就行了。这样的流程能够尽量的节省 BA 和 UX 的时间。
    - 验收形式：推荐开发人员操作演示给其他参与人员的形式，当然也可以是 BA 或者 QA 去操作，没有严格的规范。功能的验收要基于业务来进行演示，不要只是简单的页面操作流程。演示完成后，QA 和 BA 可以对于某些关键点再进行对应的检查，但不要抠过多的细节。

## 经验

1、清晰的变量名和方法名
2、能提取成公共组件/方法/类的的绝不复制粘贴
3、拥抱函数式编程，使用声明式编程（因为可读性强）
4、写好方法/函数注释，写出每一个参数的描述和数据类型，对可选参数赋默认值
5、优先使用组合而不是继承
6、使用智能的编辑器，规避语法错误（因为高效）
7、不搞特殊化，坚持规范，不偷懒
8、使用更高层次的抽象，维护更少的状态，尽量提高代码的复用性

1.善于使用逻辑反转，简化代码
2.多使用接口，可以减少工作量，以及开发粗心的后果
3.使用代码format工具
4.写代码多使用注释，以及抱着给别人写代码看的态度
5.要打log,判断运行时间，多做优化

1:注释。如果你能靠变量名说明原由的，你可以不写，不然请写上注释。
2:变量方法命名。一个清晰的命名可以让后面的人知道这是来干什么的。
3:方法行数尽量少，清晰的结构，尽量用获取的方式来赋值变量，那么就不必把获取的代码全揉在一个方法中。
4:六大原则和设计模式：工厂、策略、代理等用起来会让人感觉很爽，再次来修改代码的时候会比较得心应手。
5:适当运动。在努力的同时，请保持一个好身体。


1.凝聚人的力量，紧密协（合）作。包括业务负责人、开发团队、客户、管理者之间的关系，所有这些关系在以前都是造成项目危机的原因之一，那么，在敏捷时代，我们需要这些角色 紧密合作，最大限度的发挥各个角色的力量.
2.聚焦客户价值，消除浪费（如何聚焦用户价值，即频繁的交付用户可工作的软件，快速收到用户反馈）
* Upgrade early and upgrade often. The closer you are to a new version of Rails, the easier upgrades will be. This encourages your team to fix bugs in Rails instead of monkey-patching the application or reinventing features that exist upstream.
* Keep upgrade infrastructure in place. There will always be a new version to upgrade to, so once you’re on a modern version of Rails add a build to run against the master branch. This will catch bugs in Rails and your application early, make upgrades easier, and increase your upstream contributions.
* Upstream your tooling instead of rolling your own. The more you push upstream to gems or Rails, the less logic you need in your application. Save your application code for what truly makes your company special (i.e. Pull Requests), instead of tools to make your application run smoothly (i.e. concurrent testing libraries)
* Avoid using private API’s in your frameworks. Rails has a lot of code that’s not private but isn’t documented on purpose. That code is subject to change without notice, so writing code that relies on private code can easily break in an upgrade.
* Address technical debt often. It’s easy to think “this is working, why mess with it”, but if no one knows how that code works, it can quickly become a bottleneck for upgrades. Try to prevent coupling your application logic too closely to your framework. Ensure that the line where your application ends and your framework begins is clear. You can do this by addressing technical debt before it becomes difficult to remove.
* Do incremental upgrades. Each minor version of Rails provides the deprecation warnings for the next version. By upgrading from 3.2 to 4.0, 4.0 to 4.1, etc we were able to identify problems in the next version early and define clear milestones.
* Keep up the momentum. Rails upgrades can seem daunting. Create ways in which your team can have quick wins to keep momentum going. Share the responsibility across teams so that everyone is familiar with the new version of the framework and prevent burnout. Once you’re on the newest version add a build to your app that periodically runs your suite against edge Rails so you can catch bugs in your code or your framework early.
* Expect things to break. Upgrades are hard and in an application as large as GitHub things are bound to break. While we didn’t take the site down during the upgrade we had issues with CI, local development, slow queries, and other problems that didn’t show up in our CI builds or click testing.

## 敏捷开发十二原则

* Our highest priority is to satisfy the customer through early and continuous delivery of valuable software. 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意
* Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage. 欣然面对需求变化，即使在开发后期也一样
* Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale. 经常交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期
* Business people and developers must work together daily throughout the project. 业务人员和开发人员必须相互合作，项目中的每一天都不例外
* Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done. 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标
* The most efficient and effective method of conveying information to and within a development team is face-to-face conversation. 面对面沟通是传递信息的最佳的也是效率最高的方法
* Working software is the primary measure of progress. 可工作的软件是进度的首要度量标准
* Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.敏捷流程倡导可持续的开发，责任人、开发人员和用户要能够共同维持其步调稳定延续
* Continuous attention to technical excellence and good design enhances agility.坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强
* Simplicity--the art of maximizing the amount of work not done--is essential. 以简洁为本，它是极力减少不必要工作量的艺术
* The best architectures, requirements, and designs emerge from self-organizing teams. 最好的架构，需求和设计出自自组织团队
* At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly. 团队定期地反思如何能提高成效，并依此调整自身的举止表现

## 缺点

* 敏捷软件开发的特征是增量的，因此每个迭代都会有新的业务分析，新的开发工作在进行。这带来的一个问题是，不会有一个统一的 PRD 文档出现，最后在项目结束时候，交付物中没有好的文档。所以敏捷往往强调可交付的软件更为重要，在代码质量上下功夫，做到代码即文档
* 参与人员都是根据团队划分的，例如独立的 PM、BA、DEV，不再存在管理部分、研发部门。带来的矛盾是对个体的要求变高了，有时候往往一个团队中只有一个 BA 或者 UI，对新人挑战较大

## 敏捷测试

* 宣言
    - 全程的测试介入
        + 敏捷测试提倡测试左移和右移，从软件生命周期的早期（左侧）一直到产品发布上线后的生产环境，都需要有测试的介入和测试活动的开展。
        + 左移是为了更好的理解和澄清需求，以减少需求理解不一致导致的浪费；而右移是充分利用生产环境的数据来优化开发和测试流程，以增强软件系统应对各种不可预测性的能力。
        + 左移和右移并不仅仅是将测试活动移到两侧端点，更强调的是每个环节的参与，也就是全程测试介入，这是从流程上保障高质量软件交付的关键。
    - 团队整体对质量负责
        + 敏捷提倡全功能团队，团队的角色之间分工不再那么明确，不同角色间的协作更加密切，团队一起为质量负责，是敏捷测试需要遵循的指导性原则。
        + 团队需要对质量目标有统一认识，在敏捷软件生命周期的每个环节有不同角色的共同参与，实现质量目标是每个角色的职责。
    - 持续性的精准自动化测试
        + 自动化测试是敏捷测试的基础，是快速反馈的必要手段。自动化测试不能一味的追求覆盖率，而是要追求有目的的精准覆盖。也就是说，自动化测试首先必须是有效的，是基于业务风险考虑的，才能真正实现快速反馈。
        + 自动化测试需要能够在持续集成流水线上持续的运行，为每次代码提交提供反馈，以确保系统功能不会因为新代码的提交而被破坏；同时，随着功能的不断迭代，自动化测试需要相应的更新、增加，确保新功能是有有效自动化测试覆盖的。
    - 质量内建
        + 质量内建是敏捷测试的核心，需要将测试全程介入、团队为质量负责和持续精准的自动化测试结合起来，在敏捷软件生命周期的每个环节做好缺陷的预防，把质量融入到产品的开发构建中。
* 原则
    - 目标在于和团队一起尽快地交付高质量软件。
    - 测试人员尽早参与软件早期阶段，与所有团队角色合作，通过实例化需求，确保对业务价值理解的一致性。
        + 测试左移
    - 测试人员关注生产环境状态，收集数据，指导和优化前期的分析、开发和测试。
        + 测试右移:由于生产环境的特殊性，并不能将测试活动简单右移到生产环境，只能通过收集和分析生产环境的数据，利用这些数据来优化开发、测试和业务价值，让生产环境和开发过程形成良性环路
    - 测试人员和开发人员同处一个产品项目团队，而不是独立的测试团队或部门。
    - 测试人员负责探索性测试，和开发人员结对，设计、实现和维护自动化测试。
        + 单元测试和接口测试主要由开发人员负责
        + 界面层自动化测试同样需要开发人员一起参与设计、实现和维护，这样才更高效
        + 可以让测试人员抽离出来去做更有价值的事情——探索性测试。
    - 自动化测试在流水线中持续精准执行，快速发现每次代码提交对于已有功能的影响。
    - 测试数据对于自动化测试是充分的，并能按需获得。
        + 包括正常和异常情况的覆盖、满足不同环境或不同平台的执行要求等
        + 需要有完善的数据创建和管理方案，确保不同需求下的自动化测试能够获得相应的测试数据。
    - 测试活文档化，和代码一起，作为知识资产进行版本化管理。
    - 自动化测试需要有效的分层。
        + 根据不同的测试对象进行有效分层。
        + 越往底层的测试实现成本更低、执行更高效、定位更准确，但覆盖范围有限，不能跟业务很好的关联；
        + 越往顶层的测试越接近业务、更能体现业务价值，但是执行速度、稳定性较差、定位问题较难。
        + 需要根据系统要求、技术架构等项目具体情况规划每层测试的合理占比，不能盲目的追求多而全的覆盖
    - 预防缺陷，而不是关注缺陷的数量。
        + 质量内建是敏捷测试追求的核心价值观，而质量内建本质上就是缺陷预防。
        + 敏捷测试需要团队把重心放在预防缺陷上，提高软件的内建质量，而只关注缺陷数量、甚至把缺陷数量当做考核指标的情况是违背这一核心价值观的
        + 对缺陷数量趋势的正确跟踪和对缺陷根因的深入分析，是帮助预防缺陷的有效手段，是值得推荐的。

* 敏捷阶梯模型，表示团队在互信的基础上，以消除“价值最大、质量最差”这个最大瓶颈为愿景，“尽早、频繁、小批”地进行PDCA（Plan/Do/Check/Adjust）迭代，一个迭代进步一点地进行改进

## [Manifesto for Agile Software Development](https://agilemanifesto.org/)

```
Individuals and interactions over processes and tools
Working software over comprehensive documentation
Customer collaboration over contract negotiation
Responding to change over following a plan
```

## 图书

* 解析极限编程
* 精益思想
* 《持续交付》Jez Humble
* 持续交付2.0：业务引领的DevOps精要 乔梁
* Agile IT organization design
* [Google工作法](https://www.yuque.com/heqingbao/msfy2c/zg56gm)
* 《Clean Agile》
* The Unicorn Project
* 软件需求与可视化模型
* 精益创业
    - MVP：优先最小化可行产品
* 大教堂与集市
* 《深入核心的敏捷开发》

## 工具

* 框架
    - Scrum
    - XP（eXtreme Programming）
    - OpenUP
* MyCollab
* Odoo
* OpenProject
* OrangeScrum
* Taiga
* Tuleap
* Jira Software from Atlassian
* conflurence : document
* VivifyScrum
* Binfire
* VersionOne
* Wrike
* Zoho Sprints
* PivotalTracker
* Assembla
* Planbox
* Axosoft
* [TAPD](https://www.tapd.cn/official/index):腾讯敏捷研发体系十余年的发展成果，为产品研发全生命周期提供解决方案，支持敏捷需求规划、迭代计划跟踪、测试与质量保证、持续构建交付等全过程研发实践
* [snipper](https://snipper.io):you collaborate with your friends on the same code in real time and keep track of versions.

## 参考

* [](https://www.atlassian.com/agile)
* [AGILE FLUENCY PROJECT](https://www.agilefluency.org/)
