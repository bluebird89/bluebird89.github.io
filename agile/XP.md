# 极限编程 Extreme Programming XP

* 一套软件开发方法是由一系列与开发相关的规则、规范和惯例
* Kent Beck 等人在上世纪九十年代发明的一种软件工程方法。极限编程是一种强调团队工作的工作方式，是多种敏捷方式的一种
* Scrum 是一种工作方式的框架，从组织到团队的设计，而XP关注的是具体的工程技术实践
* XP 旨在通过工程实践的合理搭配使用，使开发者们能够自信地响应客户需求。强调反馈环机制，客户与研发团队之间的反馈环，测试与开发的反馈环，具体代码实现跟单元测试之间的反馈环，结对之间的反馈环
* 极限”(Extreme):将认同的有效软件开发原理和实践应用到极限
* 极限编程认为在软件研发过程中，变化是无所不在的，人们不应回避变化，而应该适应变化，通过对反馈的检视，去适应变化
* 特点
  - 增量和反复式的开发----一次小的改进跟着一个小的改进
  - 反复性，通常是自动重复的单元测试，回归测试。参见JUnit
  - 结对程序设计
  - 在程序设计团队中的用户交互（在场的客户）
  - 软件重构
  - 共享的代码所有权
  - 简单
  - 反馈
  - 用隐喻来组织系统
  - 可以忍受的速度

## what

* support to agile mangement practice
* core of Agile

![XP Approach](../_static/xp_approach.png "Optional title")

## 价值

* 沟通（Communication）：项目的问题往往可以追溯到某人在某个时刻没有和其他人一起商量某些重要问题上
* 简单（Simplicity）：XP 就是打赌。它打赌今天最好做些简单的事...而不是做更复杂但可能永远也不会用到的事
* 反馈（Feedback）：更早和经常来自客户、团队和实际最终用户的具体反馈意见为您提供更多的机会来调整您的力量。反馈可以让您把握住正确的方向，少走弯路
* 勇气（Courage）

## XP for cooperation and communication

![XP for cooperation and communication](_static/XP_for_cooperation_and_communication.png "Optional title")

## 概念

* UserStory：开发人员要求客户把所有的需求写成一个个独立的小故事，每个只需要几天时间就可以完成。开发过程中，客户可以随时提出新的UserStory，或者更改以前的UserStory。
* StoryEstimates和开发速度：开发小组对每个UserStory进行估算，并根据每个开发周期（Iteration）中的实际情况反复计算开发速度。这样，开发人员和客户能知道每个星期到底能开发多少UserStory。
* ReleasePlan和ReleaseScope：整个开发过程中，开发人员将不断地发布新版本。开发人员和客户一起确定每个发布所包含的UserStory。
* Iteration（开发周期，或称迭代）和IterationPlan：在一个Release过程中，开发人员要求客户选择最有价值的UserStory作为未来一两个星期的开发内容。
* TheSeed：第一个迭代（Iteration）完成后，提交给客户的系统。虽然这不是最终的产品，但它已经实现了几个客户认为是最重要的Story，开发人员将逐步在其基础上增加新的模块。
* ContinuousIntegration（整合）：把开发完的UserStory的模块一个个拼装起来，一步步接近乃至最终完成最终产品。
* 验收测试（功能测试）：对于每个UserStory，客户将定义一些测试案例，开发人员将使运行这些测试案例的过程自动化。
* UnitTest（单元测试）：在开始写程序前，程序员针对大部分类的方法，先写出相应的测试程序。
* Refactoring(重构)：去掉代码中的冗余部分，增加代码的可重用性和伸缩性

## 用户vs程序员

* 用户拥有*what you get*
  - 范围：什么系统是必须作的。
  - 优先级：对于企业价值什么是最重要的。
  - 发行的组合：什么是必须在发行版中的，一定是有用的？
  - 发行的日期：什么时候需要发行？
* 程序员拥有*what it costs*
  - 评估添加一个特征的时间 ，以及每个特征的风险
  - 使用各种技术选项所花费的成本 ：程序员解释程序选择的结果，但是用户作决定
  - 过程：小组怎么样工作，团队怎么组织
  - 细节时间表：在一个迭代中特征先开发风险最大的那一个特征可以减轻风险

## 流程

* 计划
  - User stories的编写
  - 识别需求方面
  - 开发计划的制定
  - 经常构造版本
  - 版本控制
  - Load Factor因子的确定
  - 将项目分解为各个迭代期
  - 每个迭代期开始时制定计划
  - 人员集中
  - 站着开每日晨会
  - 当实施遇到困难时及时修正
* 测试
  - 所有代码均需进行单元测试
  - 发行之前所有代码必须通过单元测试
  - Bug发现后应马上测试 　
* 编码
  - 始终获得用户的支持
  - 代码的书写必须按照规范
  - 所有代码均采用配对开发
  - 一次只能有一对开发人员进行发行
  - 代码经常集成
  - 代码共享
  - 将优化放在最后
  - 不要加班
* 设计
  - 简单化
  - 采用编程规范
  - 设计时使用CRC卡片
  - 使用Spike Solution 方法
  - 不要过早添加新功能
  - 尽可能保持程序的简洁性

## 权利和义务

* 定义每个用户需求的商业优先级
* 制订总体计划，包括用多少投资、经过多长时间、达到什么目的
* 在项目开发过程中的每个工作周，都能让投资获得最大的收益
* 通过重复运行你所指定的功能测试，准确地掌握项目进展情况
* 能随时改变需求、功能或优先级，同时避免昂贵的再投资；能够根据各种变化及时调整项目计划
* 能够随时取消项目；项目取消时，以前的开发工作不是一堆垃圾，已开发完的功能是合乎要求的，正在进行或未完成的的工作则应该是不难接手的
* 知道要做什么，以及要优先做什么
* 工作有效率
* 有问题或困难时，能得到客户、同事、上级的回答或帮助
* 对工作做评估，并根据周围情况的变化及时重新评估
* 积极承担工作，而不是消极接受分配

## 实践

* 从内到外。最里圈为个人实践，中间层为团队实践，最外层为交付实践

![XP level](../_staic/xp_level.png "Optional title")

## 完整团队 whole team

* 一个团队中应包含完成工作需要的所有技能，包括 BA，UX，Dev，QA，DevOps等
* 在TW并不强调角色，因为一个人可以具备多种技能。BA 可以具备 UX 技能，Dev 可以具备QA技能。甚至不需要一个团队里具备所有技能，只要有成长型思维，什么都可以学嘛
* 所有参与者（开发人员、客户、测试人员等）一起工作在一个开放的场所中,场所的墙壁上随意悬挂着大幅的、显著的图表以及其他一些显示进度的东西。必须至少有一个人对用户需求非常清晰，能够提出需求、决定各个需求的商业价值（优先级）、根据需求等的变化调整项目计划等

## 规划策略 Planning Game

* 无论是用户还是开发人员都是随着项目的进展过程才逐步了解事物的。只有鼓励和信奉这种更改的方法才是有效方法。状态限定方法忽视更改。而 XP 则留心更改。它倾听所用的方法就是*规划策略*，一个由 Kent Beck 创造的概念。
* 主要思想是迅速地制定粗略计划，然后随着事物的不断清晰来逐步完善。规划策略的产物包括：
  - 一堆索引卡，每一张都包含一个客户素材，这些素材驱动项目的迭代
  - 对下一两个发行版的粗略计划，如 Kent Beck 和 Martin Fowler 在他们的 Planning Extreme Programming 中描述的那样
* 让这种形式的计划得以发挥作用的关键因素是让用户做企业决策，让开发小组做技术决策
* 计划是持续的、循序渐进的。每2周，开发人员就为下2周估算候选特性的成本，而客户则根据成本和商务价值来选择要实现的特性
  - 软件发布计划（ReleasePlanning）：客户阐述需求，开发人员估算开发成本和风险。客户根据开发成本、风险和每个需求的重要性，制订一个大致的项目计划。最初的项目计划没有必要（也没有可能）非常准确，因为每个需求的开发成本、风险及其重要性都不是一成不变的。而且，这个计划会在实施过程中被不断地调整以趋精确
  - 周期开发计划（IterationPlanning）：开发过程中，应该有很多阶段计划（比如每三个星期一个计划）。开发人员可能在某个周期对系统进行内部的重整和优化（代码和设计），而在某个周期增加了新功能，或者会在一个周期内同时做两方面的工作。但是，经过每个开发周期，用户都应该能得到一个已经实现了一些功能的系统。而且，每经过一个周期，客户就会再提出确定下一个周期要完成的需求。在每个开发周期中，开发人员会把需求分解成一个个很小的任务，然后估计每个任务的开发成本和风险
  - Story 的规模用点数表示，和时间没有关系，不关注每一个人的生产力，只关心整个团队一个迭代的速率
  - 关心一个 Story 的 Cycle Time 是否最短
  - 采用集体估算的方式，Dev，QA，BA 都可以参与
  - 故事点使用 Fibonacci 数列：1，2，3，5，8，13，21.大家一起亮出估算的点数，请点数最大的和点数最小的人分别发言。目的是分享出他们掌握的信息，让大家对齐。然后再估一轮，就比较容易达成一致了。如果还不一致，就取个平均数，不用太纠结，估算本来就是不准的，纠结是最大的浪费
  - 为什么不是 1，2，3，4...？因为对于估算来说，挨着的两个数就没什么差别。拉开一点距离，这个估的大了一点，那个估的小了一点，反而把误差就中和掉了

## 小发行版 Small releases

* 追求持续交付，最好每一行代码提交都能直接部署上线。反馈速度决定了学习速度，只有交付到用户手里，才能获得最真实的反馈
* 发行版应该尽可能地小，同时仍然提供足够的企业价值以证明它们值得。
* 只要觉得有意义就可以发布系统。这样就尽可能早为用户提供了价值（请记住，今天的钱比明天的钱来得值钱）。
* 将为开发人员提供具体的反馈意见，告诉哪些符合客户需要，哪些不符合客户需要。然后，小组可以将这些经验教训包括在其下一发行版的规划中

## 客户测试 Customer Tests

* 作为选择每个所期望特性的一部分，客户可以根据脚本语言来定义出自动验收测试来表明该特性可以工作
  - 团队里最好有真实的用户，但一般不太可能，但可以找到比较了解用户的代表，他可以帮我们测试软件是否符合他们的真实需求
* 要使功能最理想，XP 小组需要在现场有一位客户来明确素材，并做出重要的企业决策。
* 开发人员是不允许单独做这些事情的。让客户随时在场可以消除开发人员等待决策时出现的瓶颈。
* XP 不会假装素材卡是开发人员交付必要代码所需的唯一指示。
* 素材是对以后在客户和开发人员之间填写细节的对话的一项承诺。与将所有要求写在一个静态文档中不同，其思想是进行面对面的交流，减少产生误解的机会。
* 发现让客户在现场是可能最好的一种情形，但这不是解决问题的唯一方案。底线是客户必须随时在需要回答问题和根据企业价值为团队提供指示时有空。如果客户并非在现场专职陪伴团队的情况下就能做到这些，那很好。如果能和团队待在一起，这会更方便，但只是建议而已。

## 集体所有权 Collective Ownership

* 任何结对的程序员都可以在任何时候改进任何代码。没有程序员对任何一个特定的模块或技术单独负责，每个人都可以参与任何其它方面的开发
* 代码不再分责任田，那个模块是你的，这个模块是我的。我的模块你不要动，有什么需求你告诉我，我来改。集体所有权就是所有人共同拥有所有代码，每个人都有权限和自由去修改。
* 小组中的任何人都应该有权对代码进行更改来改进它。每个人都拥有全部代码，这意味着每个人都对它负责。这种技术可以让人们对部分代码进行必要的更改而不用经过代码拥有者个人的瓶颈。每个人都负责这一事实消除了无代码所有权所带来的混乱。
* 每人拥有所有代码*与*没人拥有代码*的说法并不一样。没人拥有代码时，人们可以随处进行破坏而不必负任何责任。而 XP 说，*如果是您破坏的，应该您来弥补。
* *我们有一些必须在每次集成之前和之后运行的单元测试。如果您破坏了某些事物，您要负责进行修补，无论它位于代码的哪一部分。这需要极端规则。可能这是名称中带有*极端的另一个原因

## 代码规范 Code Standard

* 所有人遵守同一套代码规范，持续集成服务器会对每一次提交的代码进行规范检查。 通过 Code Review 也可以保证代码规范性
* 拥有编码标准有两个目的：
  - 防止团队被一些例如事物没有以最大速度发展这种无关紧要的愚蠢争论搞得不知所措。
  - 如果没有编码标准，重新划分代码会更加困难，按应当的频度交换对更困难，快速前进也更困难。
* 目标应该是团队中没有人辨认得出是谁写的哪一部分代码。以团队为单位对某一标准达成协议，然后遵守这一标准。目标不是创建一个事无巨细的规则列表，而是提供将确保您的代码可以清晰交流的指导方针。
* 编码标准开始时应该很简单，然后根据团队经验逐步进化。不要预先花费太多时间。创建能够工作的最简单标准，然后逐步发展。

## 可持续速率 Sustainable Pace

* 每天工作 8 小时，每周工作 5 天
* 做计划时不应该算上额外的时间
* 结对编程会更消耗精力，结对一天就很累了
* 业余还要花时间去学习，保持技术先进
* Kent Beck 说他希望*...每天早晨都感到有活力有激情，每天晚上都感到疲惫而满足*
* 长时间地持续工作会扼杀工作绩效。疲劳的开发人员会犯更多错误，从长期来说，将比按*正常*时间表进行的开发慢得多
* 即使开发人员可以在长时间很好工作，这也不意味着他们应该这样。最终他们会厌倦，会离开他们的工作，或者产生影响他们工作绩效的非工作问题。如果打乱了人们的生活，将会尝到它所带来的恶果
* 加班并不是解决项目问题的答案。实际上，它是更大问题的症状

## 隐喻 Matephor

* 提供了系统各种组件以及它们是如何交互的画面 -- 一种映射，可以让开发人员了解新的代码部分适合放在哪里
* XP 中的系统比喻与大多数方法称作的体系结构差不多。比喻为团队提供了一致的画面，可以用它来描述现有系统的工作方式、新部件适合的位置，以及它们应该采取的形式
* 重要的是要记住，关键要让每个人理解系统是如何组合在一起的，而不是美丽的比喻
* 设计模式：工程模式，策略模式，百词斩：比喻自己是一个医生，治疗不会学习英语的病，本质是一种信息的传递，而需要做的就优化信道，使接收端收到更优质不是真的信息
* 将整个系统联系在一起的全局视图,是系统的未来影像，使得所有单独模块的位置和外观变得明显直观。如果模块的外观与整个隐喻不符，那么你就知道该模块是错误的

## 持续集成 Continuous Integration

* 在XP的实践中占据着非常重要的位置
* 集成:集成无非就是收集、打包和验证的过程。软件的代码由不同的人编写，需要将所有的代码从不同的位置收集到一处，然后进行编译，这就是一般SCM的概念（即软件配置管理），将编译出来的二进制文件部署到验证环境中，进行软件的验证，这就是一般传统理解的测试的概念。
* 持续:为了让产品可以持续地交付到客户那里，从客户处获得客户的反馈，就有必要让产品可以持续地集成，加快集成的频率，缩短集成的周期
* 为了让集成能够持续地运转，就有了持续集成系统，如Jekins帮助管理一个个持续集成的任务，Git或subversion做软件的配置管理，用自动化的编译工具对代码进行打包（因不同的开发语言而不同），自动化的单元测试，自动化的验收测试。
* 提供一个清晰快速的反馈机制等等。进而可以演化为通过持续集成系统可以对整个开发工作进行可视化，精益方法运用到持续集成的工作中，指导项目的管理等等。进而延伸到持续部署、持续交付。
* 如果XP的各个工程实践是珍珠的话，那么串起这些珍珠项链的绳子就是持续集成
* 经常进行代码集成可以帮助您避免集成梦魇。XP 团队在一天中集成了代码几次，每次都在所有单元测试对系统运行后执行。
* 传统方法工作方式如下：编写大量代码后执行一次大爆炸式的集成，然后花费相当长的时间来改正问题。这种笨拙的形式的确使项目速度减缓。大爆炸式的集成给团队立即带来大量问题，并且这些问题通常都有几百种可能的原因
* 如果经常进行集成，任何特定集成失败的原因都会非常明显（以前运行过测试，因此错误一定是新事物犯下的）。使用这种方法，当遇到问题时，可能的原因就相当有限。修改起来更容易，花的时间少得多，使团队保持最快速度前进

## 测试驱动开发 TDD Test-Driven Development

* 测试
  - 提供
    + 一组可能最完整的测试
    + 可能能工作的最简单的代码
  - 单元测试:开发人员在编写代码时同时编写,及时告诉开发人员系统在某一点上是否*工作*.编写代码之前为每种有可能失败的方法编写单元测试。然后编写足够的代码使之能通过测试.提供代码意图的明确景象
    * 只有在通过所有单元测试后才可以将代码检入到源代码资源库中
    * 使开发人员有信心相信代码能够工作。为其他开发人员留下线索，可以帮助理解最早的开发人员的意图
    * 给了开发人员勇气重新划分代码，因为测试失败可以立刻告诉开发人员存在错误
    * 应该将单元测试自动化，并提供明确的通过／失败结果
          - 验收测试:客户在定义了素材后编写验收测试。告诉团队系统是否执行用户希望执行的操作。用户负责确保每个素材都有验收测试来确认它们
    + 用户可以自己编写测试、可以征募组织中的其他成员（例如 QA 人员或业务分析员）编写它们，也可以将这两种方法结合起来。
    + 测试告诉系统是否具有应该具有的那些特性，以及是否可以正确工作。理想情况下，用户在迭代完成之前就应该写好迭代中那些素材的验收测试
    + 应该将验收测试自动化，并要经常运行来确保开发人员在实现新特性时没有破坏任何现有的特性
    + 客户需要来自开发团队的某些帮助来编写验收测试
    + 对一个项目开发一个可重用的自动验收测试框架，可以让用户在简单编辑器中输入他们的输入和所期望的输出
    + 框架将输入转换成 XML 文件、运行文件中的测试，然后为每个测试显示*通过*或*失败*
    + 不是所有验收测试都必须在所有情况下通过
    + 问题是验收测试帮助客户衡量项目*完成*的情况如何。还可以让客户获悉有关某些事物是否可以发行的决定
* 编写单元测试是一个验证行为，更是一个设计行为。同样，更是一种编写文档的行为。编写单元测试避免了相当数量的反馈循环，尤其是功能验证方面的反馈循环。程序员以非常短的循环周期工作，他们先增加一个失败的测试，然后使之通过。
* 单元测试被认为是描述单元需求（大部分是函数的需求）一种手段，测试用例成为一种自动化的单元测试代码，首先通过单元测试确定要实现什么，即所谓WAHT的部分，再实现产品代码，即HOW的部分，产品代码的编写始终以需求来驱动
* 原理：
  - 没有单元测试，不实现任何功能代码
  - 只编写仅能代表一种失败情况的测试代码
  - 只编写恰好能通过单元测试的产品代码
* 是你的商业安全网。因为测试是在编码之前完成的，所以写完的测试一定会运行失败，接下来再写代码使测试可以通过
* 保证产品功能，不管公司和技术团队实现的是大规模的变更还是小规模的变更

## 重构(Refactoring)

* 在不更改功能性的前提下对代码加以改进
* 重构时机
  - 实现特性之前：尝试确定更改现有代码是否可以让新特性的开发更容易
  - 之后：查看刚刚写好的代码，看是否有方法可以对它进行简化。例如，如果他们认为有抽象的机会，就会进行重构来从具体实现中除去重复的代码。
* 建议应该编写可能运行的最简单的代码
* 应该不断学习，将学到的知识加入到代码中，同时又不会破坏测试。使代码简练。意味着可以存在相当长的时间、为以后的开发人员引入更少问题，并为他们指引正确的方向
* 随时利用重构方法改进已经腐化的代码，保持代码尽可能的干净、具有表达力
* 评估不重构的成本
  - 估计现状（不重构）会造成的影响:需要针对您想重构的代码，收集在此代码上进行缺陷分析、修改和验证所花费的时间。当拿不到实际数据时，可以进行有根据的猜测(保守)。建议采用小时
  - 估计实施重构所需的工作量
  - 估计重构后能节省多少时间
  - 估计投资回收期

## 简单设计 Simple design

* 定义
    - 通过所有测试（Passes its tests） - 保证需求要满足 (Unit Test)
    - 尽可能消除重复 (Minimizes duplication) - 尽量消除重复代码
    - 尽可能清晰表达 (Maximizes clarity) - 该有的概念要在代码中体现
    - 更少代码元素 (Has fewer elements) - 减少类、接口、属性、方法、参数、变量等程序元素
    - 以上四个原则的重要程度依次降低
* 它能被几乎所有人理解,但只有极少数人能做出.或者反过来说也可以.简单设计是一种只有极少数人能做出的设计，但设计一旦做出后，能被所有人理解.
* 团队保持设计恰好和当前的系统功能相匹配。它通过了所有的测试，不包含任何重复，表达出了编写者想表达的所有东西，并且包含尽可能少的代码。
* 用最简单的办法实现每个小需求，前提是按照这些简单设计开发出来的软件必须通过测试。
* 这些设计只要能满足系统和客户在当下的需求就可以了，不需要任何画蛇添足的设计，而且所有这些设计都将在后续的开发过程中就被不断地重整和优化
* XP 的诽谤者说该过程忽略了设计。事实不是这样。问题是重量型方法建议您做的不过是提前完成大部分琐碎的设计任务。这就象是拍一张静态的地平线的照片，静止不动，然后尝试画一张如何到达那里的完美的地图
* 覆盖四个维度：需求、易修改性、可理解性、复杂度
* 这四条规则从上到下优先级递减，但是社区里对第二条和第三条的优先级有争议。（Martin Fowler 认为第二条和第三条同等重要）
    - 强调：简单固然好，但不能为了简单，而不去实现和客户约定好的需求。（当然，如果需求不合理，应该在前期通过和客户协商拒绝)
    - 比如，现在有两个类：它们之间有一部分重复代码。为了消除掉这个重复，我们将重复代码提取到一个新的类里。于是两个类变为三个类，增加了一个新的代码元素。这当然让设计变得更复杂了。但这种复杂度产生了更重要的价值（让软件更具备正交性，从而让软件更易于修改），所以，不能为了保持简单，而不去消除这个重复
    - 在简单和表达力之间，应该选择后者
    - 建立在前三条都成立的基础之上，不要为自己猜想出的未来可能性去增加系统的复杂度
* XP 说设计不应该在事物将保持不变的前提下预先仓促进行。XP 认为设计非常重要，因此应该是一个持续的事务。
* 总是先尝试使用能够工作的最简单的设计，然后随着现实的不断显现来更改它。 什么是可能工作的最简单的设计？它是符合以下条件的设计：
  - 运行所有测试
  - 不包含重复代码
  - 明确陈述程序员对所有代码的意图
  - 包含尽可能最少的类和方法
* 对简单设计的需求并不是说所有设计都很小，也不表示它们是无足轻重的。它们只不过需要尽可能简单，但是仍能工作。不要包括不使用的额外特性。我们称这样的事物为 YAGNI，表示*您将不需要它（You Aren't Going to Need It）。*不要让 YAGNI 破坏您成功的机会

## 结对编程 Pair Programming

* Smalltalk领域的大师级人物Kent Beck在1996年受聘领导克莱 斯勒公司的一个综合工资项目开发 C3(Chrysler Comprehensive Compensation)中首次采用, 并于1999年10月出版的《解析极限编程》一书中正式提出了这一软件开发方法
* 即两个人一起编写代码，共享显示器及键盘，一位同事担任的是navigator的角色，另一位是driver的角色
* Martin Fowler 说，*当人们说成对编程降低生产力时，我回答，'那是因为大多数耗费时间的编程部分是靠输入来完成的。'*
* 结对编程的前提是代码集体所有制（Collective Code Ownership），即代码为团队所共有，团队为代码的质量共同承担责任
  - 及时完成结对代码审查，减少代码的缺陷率
  - 帮助人员的能力提升
  - 帮助攻关
  - 提高编程工作的专注度
* 好处：
  - 培养新人，促进沟通，提升团队整体能力
  - 更好的知识共享和信息交流，促进团队协作
  - 促进团队成员的沟通，提升团队凝聚力
  - 所有设计决策都牵涉到至少两个人
  - 至少有两个人熟悉系统的每一部分
  - 几乎不可能出现两个人同时疏忽测试或其它任务。
  - 改变各对的组合在可以在团队范围内传播知识。
  - 代码总是由至少一人复查。 研究还显示成对的编程实际上比单独编程更有效
* 注意
  - 愿不愿意暴露自己编程的思路和技术水平，思维的透明化
  - 当Driver在写代码时，不能频繁地被打断
  - 一直霸者开发
  - 两个人的水平应该差不太多

* 硬件设置
  - 需要一个大的外接显示器和有一个可以调节高度的桌子（当然也可以用纸箱子DIY一个低配版:直接决定结对能不能作为一个可持续的团队工程实践.
  - 纸和笔永远是你（们）的好朋友，在实际动手写代码之前，请拿出纸笔来将要做的事情划分成更细粒度，可以验证的任务列表，贴在显示器的下边缘。最后，另外记得将手机调成震动模式，利人利己。
* 软件设置
  - 可以切换到自己熟悉的Keymap：在Intellij/WebStorm里 Ctrl+`来切换各种设置
  - 至少熟悉一个IDE/编辑器，比如通过纯键盘的操作完成
    + 按照名称查文件
    + 按照内容搜索
    + 定位到指定文件的指定行/指定函数
    + 选中变量，表达式，语句等
    + 可以快速执行测试（可以在命令行，也可以在IDE中）
  - 熟常基本Shell技能和常用命令行工具的使用，可以完成诸如
    + 文件搜索
    + 网络访问
    + 正则表达式的应用
    + 查找替换文件中的内容
* 结对双方会有一个人比较有经验，而另一个人则在某方面需要catchup：领航员和驾驶员(Driver-Navigator),有一个人来做主导，另一个人来观察，并在过程中交互，答疑解惑，共同完成任务
  - 主导者 Navigator
    + 引领代码的编写并负责审查代码
    + 考虑当前的实现方法是否正确，是否有别的做法，它是否会影响到其它功能模块，下一步是什么
    + 千万不要太投入，而无视peer的感受
    + 主导者太热心coach，而忽视了给新人实际锻炼的机会。这时候需要主导者给peer更多的实践机会：比如在带着新人编写了一个小的TDD循环（红绿重构）之后，可以抑制住自己接着写的冲动
    + 看到peer正在用一个不好的做法来完成任务时，可以即使让他停下来，并通过问问题的方式来启发他：还有更好的做法吗？你觉得XXX会不会更好？
  - 观察者Driver：抓住一切可能的机会来向peer学习
    + 实现当前任务的代码
    + 跟上领航员，负责完成代码的编写，保证代码质量
    + 快捷键的使用：通过快捷键删除了花括号（block）中的所有代码
    + 命令行工具参数的应用：将curl的返回值以prettify过的样式打印到控制台
    + 良好的编程习惯：通过命令行merge了一个PR
    + 保持你的专注力和好奇心
  - 实践的时候，可以采取Ping-Pong的方式来互换主导者和观察者的角色。比如，A写一个测试，B来写实现，A来重构，然后换B来写测试，A来实现，B来做重构等等
* 保持专注
  - 需要一起完成任务划分。这样可以确保你们可以永远关注在单一任务上，避免任务切换带来的损耗。
  - 在做完一项任务后，用mark笔轻轻将其从纸上划掉（或者打钩）。
    - 既可以将你们的工作进度很好的表述出来，
    - 在任何时候帮助你们回到正在做的事情上
    - 另外这个微小的具有仪式感的动作是对大脑的一个正向反馈，促进多巴胺的分泌
* 无法统一意见
  - 所坚持的只是一个假的“真理”，先前的坚持和做技术选型时的理由就变得很可笑：那只不过是为了使用自己熟悉的技术而编造的理由而已。保持open mind是一件知易行难的事情，希望大家在争辩时能念及这个小例子，可能会少一些无谓的争辩。
  - 难以统一意见的场景，我建议可以将其搁置，先按照某一种提议进行，知道发现明显的，难以为继的缺陷为止。
  - 技术选型时我自然的选了更早项目中使用的scss module，而团队里的另一个同事则提议使用styled-component。我们谁也没有说服谁，最后写代码的时候就有两种风格。直到有一天，我在代码库里看到了用styled-component写的很漂亮的组件，我自己尝试着把相关的scss重写成styled-component，结果发现确实比单独的scss文件要更好维护一些，而且也不影响既有的测试。
* 棘手任务
  - 两人分头研究，并严格控制时间。比如Time box 30分钟。不过很可能在30分钟后，你们中至少有一个人已经对要怎么做有了头绪，如果30分钟还没有头绪，则可以求助团队其他成员。
* 张弛有度
  - 普通人很难全神贯注在某件事情上超过30分钟。这时候一个短暂的break可以让大脑得到很好的休息。
    + 从Todo列表中找出下一个任务
    + 设置一个不可中断的25分钟，开始工作
    + 时间到了之后，休息5分钟
    + 重复2-3，4次之后休息15分钟
* 结对轮换
  - 需要定期或者不定期的轮转，比如一周轮换一到两次，A和C来写订单，B和D来写门店管理，这样可以保证领域知识，工程实践，工具的使用等等知识都很好的在团队内部共享。
  - 发现让不同角色的团队成员轮换结对所带来的好处（伴随着短期阵痛的）远胜过知识的隔离带来的坏处。团队中的前端开发如果花费一些时间和DevOps一起结对，他会对系统的整个架构更加清楚；而后端开发和DevOps结对则可能让他意识到代码中的潜在缺陷和解决方法
* 尊重
  - 如果你不愿意和某一特性的人结对，那么首先不要让自己成为那样的人
  - 尊重还体现在很多其他细节中。当你不得不中断结对而去做其他事情时，务必让你的peer知道。当你的peer回来之后，你需要及时和他catchup，告诉他你正在做什么，已经做到了哪一步等等。快速的将他带入到上下文中
* 控制情绪：具有很强传染性
  - 当工作任务收到各种blocker，被各种其他事情干扰而导致进度难以推进时，一定要注意自己情绪的控制
  - 如果你的peer一直在旁边唉声叹气，或者抱怨连连，你会变得非常沮丧，并且很难集中精力在积极解决问题上。
* 需要总结一下自己记录的知识点，这是一个绝佳的提升自己能力的方法。通过实战，发现自己的缺点，并通过近距离观察别人如何解决该问题，最终会以很深刻的印象记录下来，这时候针对性的查漏补缺是可以取得非常好的效果
* 乒乓模式
  - 结对双方可以一个人编写失败的测试，一个人写实现通过测试；然后交换角色，不断循环。对于结对双方经验相当的情况下，由于交互和交换的频率很快，就如打乒乓一般，所人们戏称这种方式为结对的乒乓模式
  - 合作场景：适用于各种组合，尤其双方经验相当的场景。乒乓模式由于它的角色分工清晰，交换频率相对较快，所以乒乓模式可以帮助精力不集中的小伙伴快速融入，也是避免键霸出现的一个很好的方式
* 建议
  - 多沟通。由一个人的工作变成了两个人的事，小伙伴们就要彼此尊重，多沟通。如果有其他的任务要暂时离开，请及时告诉你的小伙伴，以便彼此更好的安排工作，保证效率
  - 确定开发任务列表（Tasking）结对除了沟通，另一个挑战就是如何保持结对双方共同的开发节奏：一个小伙伴在做A功能，另一个小伙伴要做B功能。结对双方通过协商开发任务列表，能够提高对开发任务理解的一致性，确保开发节奏顺利进行
  - 定期交换小伙伴：可以使得知识得到充分分享，每个小伙伴都有机会充当不同的角色，了解不同的知识上下文。与此同时，新的小伙伴的加入往往可以激发新的解题思路，或帮助发现问题，同时也增加结对的乐趣
  - 可持续的结对工作 真正的结对会比一人工作更专注，紧凑，所以一天8小时的结对会很累，因此结对需要定时的休息，保持合理的节奏。可与结对的小伙伴一起协商休息时间，比如一个小时或两个小时休息一次，从而保证可持续的工作
  - 多给新人机会：与新加入的小伙伴结对，需要耐心，多给予他/她上手的时间与空间。通常建议开始时多讲解，多展示，给她/他学习的机会；比如一开始可以由熟悉代码的小伙伴写测试，而新加入的写实现；随后可采用鼠标键盘方式或者乒乓结对方式
  - 勇敢加勇敢 对于新加入的小伙伴，如果跟不上怎么办？要勇敢的叫停，打断结对的小伙伴，弄懂这个问题，这样做才是达到了结对的目的。曾经有人说我记下来回家去弄懂，我更建议及时弄清楚。就如前面提到的，结对是一个快速让自己学习和成长的机会；而且你的小伙伴通过讲解也会梳理自己的思路，能够更深入的理解这个问题或技术，互助互学。如果这个问题发现项目中其它成员也不懂的，那么我们还可以将这个对话扩展开来，分享给整个团队，提升团队的战斗力，所以更推荐及时解决，当然深度需要适当的把握。如果结对的时候遇到键霸怎么办？作为新人自带消除键霸光环，勇敢的把鼠标默默的递过去，把键盘牢牢的握在自己的手中，“亲，辛苦了，让我试一下，我来！”
  - 反馈 就如戴明环一样，做事情的环要闭合，有始有终，有序循环螺旋式改进。而反馈往往是最后一环，也是最有效的一环，是帮助自己和结对小伙伴的必要工具之一，温暖的“小黑屋”是可以经常光顾的
  - 不是所有的场景都适合结对 对于那些结果需要维护，能够促进沟通、知识传递等价值的开发行为都建议结对，而诸如方案调研、一些非常简单的问题（微小的缺陷修复如拼写错误）等是可以不用结对的

## 现场客户 On-site customer

## 实践

* 反馈环 —— 通过获得反馈，持续改进的方式来适应变化的能力。
* 不断实践，这不像学习别的东西，听个概念就可以跟人辩驳，XP是一门实践性非常强的方法，与Scrum和Kanban有着非常大的不同，Scrum是组织框架设计和角色定义，Kanban适用于团队局部优化，也适用于组织层面工作流的梳理，而XP却是实打实地技术实践。
* 小到可以从单个工程师编写代码养成良好地单元测试的习惯，再到两个人结对开发，进行可以做团队的持续集成，大到整个产品级别或系统级别的持续集成和交付

## 规模化极限编程

* 个人与团队的能力是软件开发最重要的基础。一切不提升个人与团队基本能力的敏捷都是鬼扯。
  - 一切技术不足管理补的所谓「规模化敏捷」都是扯淡.任何「规模化敏捷」、乃至任何「敏捷」的办法，必须基于极限编程的工程技术实践：测试驱动开发，持续集成，重构。
* 极限编程落地之难，实际上不是难在学的这一方，而是难在教的这一方。关于「怎么教新手学编程」这事，极限编程有一个固化在其方法论内的实践：结对编程。而「结对」这事，实际上隐含了一个假设：新手与熟手的人数之比，不能高于1:1，否则就会出现新手没人结对的情况。
  - 团队中新手与熟手的人数之比，或者叫团队的杠杆率，是影响极限编程落地的关键因素。
  - 高杠杆环境下结对编程的不可行，是极限编程在中国难以规模化推广的根本原因。
  - 反复练习和从事某一细分环节的工作，无法使新手获得完整交付软件所需的基本功。对于提升整个团队的基本功水平毫无帮助，这样做的团队注定被锁死在低效率、低质量的状态。
  - 新手程序员并不是不会理解需求、设计软件、保障代码质量，他们只是因为缺乏练习无法在较大的尺度上准确地进行这些动作。
  - 新手无法对较大尺度的需求进行下列操作将其变成较小尺度的开发任务：
    + 提出诊断性的问题，明确需求的范围和边界；
    + 进行分析性思考，列举明确的需求验收条件；
    + 运用概念性思考，用适当的对象模型映射需求。
  - 规模化极限编程（以及，任何形式的规模化敏捷）的必备要素：
    + 所有程序员，不论熟手还是新手，都进行端到端的需求交付；
    + 通过比经典的用户故事更细的需求拆分，降低对新手的认知要求；
    + 以少于4小时工作量的开发任务为基准，通过刻意练习快速训练新手的交付基本功；
* 验收条件
  - 在高杠杆率的环境下，熟手与新手的配合界面必然是比用户故事颗粒度更细、对认知能力要求更低的工件（artifact）,这种工件应该仍然大体符合INVEST原则，尤其是应该可以独立交付（I）、可评估工作量（E）、可测试（T）。当然最重要的是，这种工件应该比用户故事更小（S）：团队普遍水平的程序员应该能在1~4小时内完成其交付。
  - 熟手交给新手去交付的工件，应该是1~4小时颗粒度的验收条件
    + 能否将需求拆解成1~4小时颗粒度的验收条件。如果不能，说明团队欠缺拆解、细化的能力，说明熟手的工作没有做到位。
    + 能否在1~4小时内按照质量标准完成验收条件的交付。如果不能，说明团队欠缺编程基本功，说明新手的工作没有做到位。
  - 能否用给定的技术栈，按照给定的质量标准，在给定的时间要求内，实现给定的任务。对于一个典型的Java后端开发人员，他的能力指标
    + 使用SpringBoot（技术栈）
    + 在3个小时内（时间要求）
    + 实现「长度换算」的微服务版本（任务）
    + 要求测试覆盖率100%，且没有明显的坏味道（质量标准）
* 开发工序管理:把开发人员的工作步骤管理起来，以期其产出的代码达成组织期望的代码质量
  - 要有人把用户故事拆解成一系列足够简单的工序，并且写代码的人要在足够简单的工序中以规范的、高质量的方式来实现
  - 开发人员能不能生产出可以快速回归的软件
    + 强的开发人员能够按照架构设计把需求分解为可测试步骤组成的工序，并能按照工序高效得写出有测试保护的代码
    + 弱的人则只能拆解为写代码的步骤，至于能不能测试，就不再考虑范围之内了
  - 把需求分解为可测试步骤这件事：需要特定的胜任力——分析型思考和少量的概念性思考，而这两者在软件开发人员当中是很稀缺
  - 怎么做工序管理
    + 因为架构是指导如何进行工序分解的，对于怎么做日常编码工作是有强烈的指导意义的。如果架构本身就不是容易测试的，那么对应的工序也就很难形成，或者其中某些步骤的测试成本过高
    + 给Sr人员进行培训，可以做到“按照架构设计把需求分解为可测试步骤组成的工序，并能按照工序高效得写出有测试保护的代码”。然后由初级的人员，按照工序编写代码\
    + 工时管理:拆分出的每个任务，都应该在一个固定的时间内完成，如果没有在固定的时间内完成，我们则视为是一个事故，需要针对该事故做分析并提出改进计划
  - 落地细节
    + 架构师是否拆解工序:架构师首先应该学会这件事，毕竟他要能解决工序如何拆分的问题。
      * 所以还要打个样，看看工序怎么拆分，是不是可以拆为生产可测试代码的工序。
      * 然后他自己也要写一下代码，看看工序映射为代码的过程是否会遇到障碍，有时候自己写一下会发现之前很多关键细节没有想清楚
    + Sr首先自己要胜任
      * Sr首先自己要能拆出来可以测试的步骤，而这一点其实并不容易。
      * 首先是对于很多人来说，能够分解为可测试的每一步就已经很挑战了，而当把这些步骤映射为代码时候，会发现更多的人根本不能按照自己所划分的任务进行正确的映射。写代码的步骤可能和划分的步骤完全对不上，更不要说每一步都可测试了。这里是能力建设的一个关键点
    + 优化无止境
      * 通过对工序的完成时间进行追踪，我们不但可以得到高效的个人，还可以发现效率的瓶颈，进一步的改进工序
* 对一线开发能力的要求
  - 需要程序员掌握极限编程的技术实践，具备熟练运用测试驱动开发、重构和持续集成的能力
  - 编程能力 = 技术栈 + 任务 + 质量标准 + 时间
  - Secret Sauce：开发能力公式。这个公式描述的是一线程序员真正每天进行的工作，度量的是他们完成自己每天工作的能力
* 怎么考察员工能力是否达到要求
  - 拿出一个大小合适的任务，指定技术栈，指定质量标准，上好闹钟，考吧。规定时间内完成任务，功能完成，质量达标，你就合格。规定时间交不了卷，不好意思，请再去投个两万个球。——看，完美闭环的能力建设+考查体系
  - [科举](https://ketsu.cn/)
* 暂时没有达到要求的员工开展能力建设
  - 编程能力这事，它是一个实操的事,靠练。要掌握一个技术栈、一种质量要求的能力，就得在这个技术栈上、遵循着这种质量要求反复练习
  - 没有大量刻意练习的编程能力培训都是扯淡
  - 方法
    + 设定练习的题目
    + 对练习的结果给出反馈
    + 引导学员进行反思和改进

## 图书

* 解析极限编程-拥抱变化

## 参考

* [Extreme programming](http://www.extremeprogramming.org/)
* [eXtremeProgramming-cn/xp-gym-training](https://github.com/eXtremeProgramming-cn/xp-gym-training):Free open source training materials for eXtreme Programming practitioners and promoters
* [](http://www.extremeprogramming.cn/)
* [XPdeveloper](http://http://www.xpdeveloper.com/)
* [Xprogramming](http://www.xprogramming.com/)

* [What is Extreme Programming?](https://ronjeffries.com/xprog/what-is-extreme-programming/)
* [The Rules of Extreme Programming](http://www.extremeprogramming.org/rules.html)
* [Extreme Programming - Introduction](https://www.tutorialspoint.com/extreme_programming/extreme_programming_introduction.htm)
