# Extreme Programming

* 一套软件开发方法是由一系列与开发相关的规则、规范和惯例
* Kent Beck 等人在上世纪九十年代发明的一种软件工程方法。极限编程是一种强调团队工作的工作方式，是多种敏捷方式的一种。
* 与Scrum不同的是，Scrum是一种工作方式的框架，从组织到团队的设计，而XP关注的是具体的工程技术实践。
* XP旨在通过工程实践的合理搭配使用，使开发者们能够自信地响应客户需求。强调反馈环机制，客户与研发团队之间的反馈环，测试与开发的反馈环，具体代码实现跟单元测试之间的反馈环，结对之间的反馈环
* 极限编程认为在软件研发过程中，变化是无所不在的，人们不应回避变化，而应该适应变化，通过对反馈的检视，去适应变化

## 价值

* 沟通（Communication）：项目的问题往往可以追溯到某人在某个时刻没有和其他人一起商量某些重要问题上
* 简单（Simplicity）：XP 就是打赌。它打赌今天最好做些简单的事...而不是做更复杂但可能永远也不会用到的事
* 反馈（Feedback）：更早和经常来自客户、团队和实际最终用户的具体反馈意见为您提供更多的机会来调整您的力量。反馈可以让您把握住正确的方向，少走弯路
* 勇气（Courage）
* 遵守（Respect）

## 概念

* UserStory：开发人员要求客户把所有的需求写成一个个独立的小故事，每个只需要几天时间就可以完成。开发过程中，客户可以随时提出新的UserStory，或者更改以前的UserStory。
* StoryEstimates和开发速度：开发小组对每个UserStory进行估算，并根据每个开发周期（Iteration）中的实际情况反复计算开发速度。这样，开发人员和客户能知道每个星期到底能开发多少UserStory。
* ReleasePlan和ReleaseScope：整个开发过程中，开发人员将不断地发布新版本。开发人员和客户一起确定每个发布所包含的UserStory。
* Iteration（开发周期，或称迭代）和IterationPlan：在一个Release过程中，开发人员要求客户选择最有价值的UserStory作为未来一两个星期的开发内容。
* TheSeed：第一个迭代（Iteration）完成后，提交给客户的系统。虽然这不是最终的产品，但它已经实现了几个客户认为是最重要的Story，开发人员将逐步在其基础上增加新的模块。
* ContinuousIntegration（整合）：把开发完的UserStory的模块一个个拼装起来，一步步接近乃至最终完成最终产品。
* 验收测试（功能测试）：对于每个UserStory，客户将定义一些测试案例，开发人员将使运行这些测试案例的过程自动化。
* UnitTest（单元测试）：在开始写程序前，程序员针对大部分类的方法，先写出相应的测试程序。
* Refactoring(重构)：去掉代码中的冗余部分，增加代码的可重用性和伸缩性

## 特点

* 增量和反复式的开发----一次小的改进跟着一个小的改进
* 反复性，通常是自动重复的单元测试，回归测试。参见JUnit
* 结对程序设计
* 在程序设计团队中的用户交互（在场的客户）
* 软件重构
* 共享的代码所有权
* 简单
* 反馈
* 用隐喻来组织系统
* 可以忍受的速度

## 用户vs程序员

* 用户拥有*what you get*
	- 范围：什么系统是必须作的。
	- 优先级：对于企业价值什么是最重要的。
	- 发行的组合：什么是必须在发行版中的，一定是有用的？
	- 发行的日期：什么时候需要发行？
* 程序员拥有*what it costs*
	- 评估添加一个特征的时间 ，以及每个特征的风险
	- 使用各种技术选项所花费的成本 ：程序员解释程序选择的结果，但是用户作决定
	- 过程：小组怎么样工作，团队怎么组织
	- 细节时间表：在一个迭代中特征先开发风险最大的那一个特征可以减轻风险

## 流程

* 计划
	- User stories的编写
	- 识别需求方面
	- 开发计划的制定
	- 经常构造版本
	- 版本控制
	- Load Factor因子的确定
	- 将项目分解为各个迭代期
	- 每个迭代期开始时制定计划
	- 人员集中
	- 站着开每日晨会
	- 当实施遇到困难时及时修正
* 测试
	- 所有代码均需进行单元测试
	- 发行之前所有代码必须通过单元测试
	- Bug发现后应马上测试 　
* 编码
	- 始终获得用户的支持
	- 代码的书写必须按照规范
	- 所有代码均采用配对开发
	- 一次只能有一对开发人员进行发行
	- 代码经常集成
	- 代码共享
	- 将优化放在最后
	- 不要加班
* 设计
	- 简单化
	- 采用编程规范
	- 设计时使用CRC卡片
	- 使用Spike Solution 方法
	- 不要过早添加新功能
	- 尽可能保持程序的简洁性

## 权利和义务

* 定义每个用户需求的商业优先级
* 制订总体计划，包括用多少投资、经过多长时间、达到什么目的
* 在项目开发过程中的每个工作周，都能让投资获得最大的收益
* 通过重复运行你所指定的功能测试，准确地掌握项目进展情况
* 能随时改变需求、功能或优先级，同时避免昂贵的再投资；能够根据各种变化及时调整项目计划
* 能够随时取消项目；项目取消时，以前的开发工作不是一堆垃圾，已开发完的功能是合乎要求的，正在进行或未完成的的工作则应该是不难接手的
* 知道要做什么，以及要优先做什么
* 工作有效率
* 有问题或困难时，能得到客户、同事、上级的回答或帮助
* 对工作做评估，并根据周围情况的变化及时重新评估
* 积极承担工作，而不是消极接受分配

## 迭代计划 (Iterative Planning)

* 在每次迭代开始时调用迭代计划会议，以生成该迭代的编程任务计划。每次迭代为1到3周。
* 客户从发布计划中按照对客户最有价值的顺序选择用户故事进行此次迭代。还选择了要修复的失败验收测试。客户选择的用户故事的估计总计达到上次迭代的项目速度。
* 用户故事和失败的测试被分解为支持它们的编程任务。任务记录在索引卡上，如用户故事。虽然用户故事是客户的语言，但任务是使用开发人员的语言。可以删除重复的任务。这些任务卡将是迭代的详细计划。
* 开发人员注册执行任务，然后估计他们自己的任务需要多长时间才能完成。对于接受任务的开发人员而言，重要的是估计完成任务所需的时间。人们不可互换，而且要完成任务的人必须估计需要多长时间。
* 每项任务应估计为1,2或3（如果需要，添加1/2）持续时间的理想编程天数。如果没有干扰，理想的编程日期是完成任务需要多长时间。短于1天的任务可以组合在一起。超过3天的任务应该进一步细分。
* 现在再次使用项目速度来确定迭代是否超过预定。在任务的理想编程天中总计时间估计值，这不得超过上一次迭代的项目速度。如果迭代次数太多，那么客户必须选择要推迟的用户故事，直到稍后的迭代（也叫雪耕 - Snow Plowing）
* 如果迭代太少，则可以接受另一个故事。任务天的速度（迭代计划）会覆盖故事周的速度（发布计划）因为它更准确。
* 看到用户故事被雪覆盖通常令人震惊。不要惊慌。记住单元测试和重构的重要性。任何一个领域的债务都会让你失望。在安排之前避免添加任何功能。只需添加今天所需的内容。添加额外的东西会减慢你的速度。
* 不要试图改变你的任务和故事估计。规划过程依赖于一致估计的冷现实，将它们勉强降低会产生更多问题。
* 密切关注您的项目速度和积雪。您可能需要重新估算所有故事并每三到五次迭代重新协商发布计划，这是正常的。只要您始终首先实施最有价值的故事，您将始终尽可能为您的客户和管理层做好准备。
* 迭代开发风格可以为开发过程增加灵活性。通过不比当前迭代更远地规划特定的编程任务来尝试及时规划

## 核心实践

* 规划策略(Planning Game)：计划是持续的、循序渐进的。每2周，开发人员就为下2周估算候选特性的成本，而客户则根据成本和商务价值来选择要实现的特性。
    - 软件发布计划（ReleasePlanning）：客户阐述需求，开发人员估算开发成本和风险。客户根据开发成本、风险和每个需求的重要性，制订一个大致的项目计划。最初的项目计划没有必要（也没有可能）非常准确，因为每个需求的开发成本、风险及其重要性都不是一成不变的。而且，这个计划会在实施过程中被不断地调整以趋精确
    - 周期开发计划（IterationPlanning）：开发过程中，应该有很多阶段计划（比如每三个星期一个计划）。开发人员可能在某个周期对系统进行内部的重整和优化（代码和设计），而在某个周期增加了新功能，或者会在一个周期内同时做两方面的工作。但是，经过每个开发周期，用户都应该能得到一个已经实现了一些功能的系统。而且，每经过一个周期，客户就会再提出确定下一个周期要完成的需求。在每个开发周期中，开发人员会把需求分解成一个个很小的任务，然后估计每个任务的开发成本和风险
* 系统比喻(Metaphor):将整个系统联系在一起的全局视图,是系统的未来影像，使得所有单独模块的位置和外观变得明显直观。如果模块的外观与整个隐喻不符，那么你就知道该模块是错误的
* 测试(Testing)
* 重构（Refactoring）
* 成对编程(pair programming)
* 小发行版(Small releases)
* 简单设计(Simple design):团队保持设计恰好和当前的系统功能相匹配。它通过了所有的测试，不包含任何重复，表达出了编写者想表达的所有东西，并且包含尽可能少的代码。用最简单的办法实现每个小需求，前提是按照这些简单设计开发出来的软件必须通过测试。这些设计只要能满足系统和客户在当下的需求就可以了，不需要任何画蛇添足的设计，而且所有这些设计都将在后续的开发过程中就被不断地重整和优化
* 集体代码所有权(Collective ownership):任何结对的程序员都可以在任何时候改进任何代码。没有程序员对任何一个特定的模块或技术单独负责，每个人都可以参与任何其它方面的开发
* 持续集成(Continuous integration):团队总是使系统完整地被集成。一个人拆入（Check in）后，其它所有人责任代码集成
* 现场客户(On-site customer)
* 编码标准(Coding standards)
* 一周40小时 (40-hour week)

* 团队协作(Whole Team)：所有参与者（开发人员、客户、测试人员等）一起工作在一个开放的场所中，他们是同一个团队的成员。这个场所的墙壁上随意悬挂着大幅的、显著的图表以及其他一些显示他们进度的东西。必须至少有一个人对用户需求非常清晰，能够提出需求、决定各个需求的商业价值（优先级）、根据需求等的变化调整项目计划等
* 客户测试(Customer Tests)：作为选择每个所期望的特性的一部分，客户可以根据脚本语言来定义出自动验收测试来表明该特性可以工作

## 规划策略

* 无论是用户还是开发人员都是随着项目的进展过程才逐步了解事物的。只有鼓励和信奉这种更改的方法才是有效方法。状态限定方法忽视更改。而 XP 则留心更改。它倾听所用的方法就是*规划策略*，一个由 Kent Beck 创造的概念。
* 主要思想是迅速地制定粗略计划，然后随着事物的不断清晰来逐步完善。规划策略的产物包括：
	- 一堆索引卡，每一张都包含一个客户素材，这些素材驱动项目的迭代
	- 对下一两个发行版的粗略计划，如 Kent Beck 和 Martin Fowler 在他们的 Planning Extreme Programming 中描述的那样
* 让这种形式的计划得以发挥作用的关键因素是让用户做企业决策，让开发小组做技术决策

## 系统比喻

* 提供了系统各种组件以及它们是如何交互的画面 -- 一种映射，可以让开发人员了解新的代码部分适合放在哪里
* XP 中的系统比喻与大多数方法称作的体系结构差不多。比喻为团队提供了一致的画面，可以用它来描述现有系统的工作方式、新部件适合的位置，以及它们应该采取的形式
* 重要的是要记住，关键要让每个人理解系统是如何组合在一起的，而不是美丽的比喻

## 测试驱动开发 (TDD: Test-Driven Development)

* 测试：
	- 提供
		+ 一组可能最完整的测试
		+ 可能能工作的最简单的代码
	- 单元测试:开发人员在编写代码时同时编写,及时告诉开发人员系统在某一点上是否*工作*.编写代码之前为每种有可能失败的方法编写单元测试。然后编写足够的代码使之能通过测试.提供代码意图的明确景象
		* 只有在通过所有单元测试后才可以将代码检入到源代码资源库中
		* 使开发人员有信心相信代码能够工作。为其他开发人员留下线索，可以帮助理解最早的开发人员的意图
		* 给了开发人员勇气重新划分代码，因为测试失败可以立刻告诉开发人员存在错误
		* 应该将单元测试自动化，并提供明确的通过／失败结果
    - 验收测试:客户在定义了素材后编写验收测试。告诉团队系统是否执行用户希望执行的操作。用户负责确保每个素材都有验收测试来确认它们
		+ 用户可以自己编写测试、可以征募组织中的其他成员（例如 QA 人员或业务分析员）编写它们，也可以将这两种方法结合起来。
		+ 测试告诉系统是否具有应该具有的那些特性，以及是否可以正确工作。理想情况下，用户在迭代完成之前就应该写好迭代中那些素材的验收测试
		+ 应该将验收测试自动化，并要经常运行来确保开发人员在实现新特性时没有破坏任何现有的特性
		+ 客户需要来自开发团队的某些帮助来编写验收测试
		+ 对一个项目开发一个可重用的自动验收测试框架，可以让用户在简单编辑器中输入他们的输入和所期望的输出
		+ 框架将输入转换成 XML 文件、运行文件中的测试，然后为每个测试显示*通过*或*失败*
		+ 不是所有验收测试都必须在所有情况下通过
		+ 问题是验收测试帮助客户衡量项目*完成*的情况如何。还可以让客户获悉有关某些事物是否可以发行的决定
* 编写单元测试是一个验证行为，更是一个设计行为。同样，更是一种编写文档的行为。编写单元测试避免了相当数量的反馈循环，尤其是功能验证方面的反馈循环。程序员以非常短的循环周期工作，他们先增加一个失败的测试，然后使之通过。
* 单元测试被认为是描述单元需求（大部分是函数的需求）一种手段，测试用例成为一种自动化的单元测试代码，首先通过单元测试确定要实现什么，即所谓WAHT的部分，再实现产品代码，即HOW的部分，产品代码的编写始终以需求来驱动
* 原理：
	- 没有单元测试，不实现任何功能代码
	- 只编写仅能代表一种失败情况的测试代码
	- 只编写恰好能通过单元测试的产品代码
* 是你的商业安全网。因为测试是在编码之前完成的，所以写完的测试一定会运行失败，接下来再写代码使测试可以通过
* 保证产品功能，不管公司和技术团队实现的是大规模的变更还是小规模的变更

## 验收测试驱动开发(ATDD:Acceptance Test-Driven Development)

* ATDD强调的也是需求的澄清，通过举例的手段对用户故事需求进行澄清，再接着让这些例子变成一个个的测试用例，在功能需求被实现后，用这些测试用例去验证功能实现是否满足需求，而这需求的澄清和测试用例的实现是前置在具体的开发实现之前的
* 因为是通过举例的形式来描述功能的需求说明，也称之为SbE（Specification by Example，中文译为实例化需求），其同样要求测试前置。
* 可以比较着TDD的概念来理解，TDD是对函数级别的需求说明，再驱动实现，而ATDD是对用户故事的级别的需求说明，分析，再驱动实现，都要求测试前置，即关注WHAT
* 测试自动化是一种缩短反馈周期，实现回归测试（Regression Test）的手段。结合着持续集成系统，可以实现一键自动化的集成与部署。

## 结对编程（Pair Programming）

* 即两个人一起编写代码，共享显示器及键盘，一位同事担任的是navigator的角色，另一位是driver的角色
* Martin Fowler 说，*当人们说成对编程降低生产力时，我回答，'那是因为大多数耗费时间的编程部分是靠输入来完成的。'*
* 结对编程的前提是代码集体所有制（Collective Code Ownership），即代码为团队所共有，团队为代码的质量共同承担责任
	- 及时完成结对代码审查，减少代码的缺陷率
	- 帮助人员的能力提升
	- 帮助攻关
	- 提高编程工作的专注度
* 好处：
	- 所有设计决策都牵涉到至少两个人
	- 至少有两个人熟悉系统的每一部分
	- 几乎不可能出现两个人同时疏忽测试或其它任务。
	- 改变各对的组合在可以在团队范围内传播知识。
	- 代码总是由至少一人复查。 研究还显示成对的编程实际上比单独编程更有效
* 注意
    - 愿不愿意暴露自己编程的思路和技术水平，思维的透明化
    - 当Driver在写代码时，不能频繁地被打断
    - 一直霸者开发
    - 两个人的水平应该差不太多

## 持续集成 (Continuous Integration)

* 在XP的实践中占据着非常重要的位置
* 集成:集成无非就是收集、打包和验证的过程。软件的代码由不同的人编写，需要将所有的代码从不同的位置收集到一处，然后进行编译，这就是一般SCM的概念（即软件配置管理），将编译出来的二进制文件部署到验证环境中，进行软件的验证，这就是一般传统理解的测试的概念。
* 持续:为了让产品可以持续地交付到客户那里，从客户处获得客户的反馈，就有必要让产品可以持续地集成，加快集成的频率，缩短集成的周期
* 为了让集成能够持续地运转，就有了持续集成系统，如Jekins帮助管理一个个持续集成的任务，Git或subversion做软件的配置管理，用自动化的编译工具对代码进行打包（因不同的开发语言而不同），自动化的单元测试，自动化的验收测试。
* 提供一个清晰快速的反馈机制等等。进而可以演化为通过持续集成系统可以对整个开发工作进行可视化，精益方法运用到持续集成的工作中，指导项目的管理等等。进而延伸到持续部署、持续交付。
* 如果XP的各个工程实践是珍珠的话，那么串起这些珍珠项链的绳子就是持续集成。
* 经常进行代码集成可以帮助您避免集成梦魇。XP 团队在一天中集成了代码几次，每次都在所有单元测试对系统运行后执行。
* 传统方法工作方式如下：编写大量代码后执行一次大爆炸式的集成，然后花费相当长的时间来改正问题。这种笨拙的形式的确使项目速度减缓。大爆炸式的集成给团队立即带来大量问题，并且这些问题通常都有几百种可能的原因。
* 如果经常进行集成，任何特定集成失败的原因都会非常明显（以前运行过测试，因此错误一定是新事物犯下的）。使用这种方法，当遇到问题时，可能的原因就相当有限。修改起来更容易，花的时间少得多，使团队保持最快速度前进。

## 重构(Refactoring)

* 在不更改功能性的前提下对代码加以改进
* 重构时机
	- 实现特性之前：尝试确定更改现有代码是否可以让新特性的开发更容易
	- 之后：查看刚刚写好的代码，看是否有方法可以对它进行简化。例如，如果他们认为有抽象的机会，就会进行重构来从具体实现中除去重复的代码。
* 建议应该编写可能运行的最简单的代码
* 应该不断学习，将学到的知识加入到代码中，同时又不会破坏测试。使代码简练。意味着可以存在相当长的时间、为以后的开发人员引入更少问题，并为他们指引正确的方向
* 随时利用重构方法改进已经腐化的代码，保持代码尽可能的干净、具有表达力
* 评估不重构的成本
	- 估计现状（不重构）会造成的影响:需要针对您想重构的代码，收集在此代码上进行缺陷分析、修改和验证所花费的时间。当拿不到实际数据时，可以进行有根据的猜测(保守)。建议采用小时
	- 估计实施重构所需的工作量
	- 估计重构后能节省多少时间
	- 估计投资回收期

## 小发行版

* 发行版应该尽可能地小，同时仍然提供足够的企业价值以证明它们值得。
* 只要觉得有意义就可以发布系统。这样就尽可能早为用户提供了价值（请记住，今天的钱比明天的钱来得值钱）。
* 将为开发人员提供具体的反馈意见，告诉哪些符合客户需要，哪些不符合客户需要。然后，小组可以将这些经验教训包括在其下一发行版的规划中

## 简单的设计

* XP 的诽谤者说该过程忽略了设计。事实不是这样。问题是重量型方法建议您做的不过是提前完成大部分琐碎的设计任务。这就象是拍一张静态的地平线的照片，静止不动，然后尝试画一张如何到达那里的完美的地图。X
* P 说设计不应该在事物将保持不变的前提下预先仓促进行。XP 认为设计非常重要，因此应该是一个持续的事务。我们总是先尝试使用能够工作的最简单的设计，然后随着现实的不断显现来更改它。 什么是可能工作的最简单的设计？它是符合以下条件的设计：
	- 运行所有测试
	- 不包含重复代码
	- 明确陈述程序员对所有代码的意图
	- 包含尽可能最少的类和方法
* 对简单设计的需求并不是说所有设计都很小，也不表示它们是无足轻重的。它们只不过需要尽可能简单，但是仍能工作。不要包括不使用的额外特性。我们称这样的事物为 YAGNI，表示*您将不需要它（You Aren't Going to Need It）。*不要让 YAGNI 破坏您成功的机会。

## 集体代码所有权

* 小组中的任何人都应该有权对代码进行更改来改进它。每个人都拥有全部代码，这意味着每个人都对它负责。这种技术可以让人们对部分代码进行必要的更改而不用经过代码拥有者个人的瓶颈。每个人都负责这一事实消除了无代码所有权所带来的混乱。
* 每人拥有所有代码*与*没人拥有代码*的说法并不一样。没人拥有代码时，人们可以随处进行破坏而不必负任何责任。而 XP 说，*如果是您破坏的，应该您来弥补。
* *我们有一些必须在每次集成之前和之后运行的单元测试。如果您破坏了某些事物，您要负责进行修补，无论它位于代码的哪一部分。这需要极端规则。可能这是名称中带有*极端的另一个原因。

## 现场客户

* 要使功能最理想，XP 小组需要在现场有一位客户来明确素材，并做出重要的企业决策。
* 开发人员是不允许单独做这些事情的。让客户随时在场可以消除开发人员等待决策时出现的瓶颈。
* XP 不会假装素材卡是开发人员交付必要代码所需的唯一指示。
* 素材是对以后在客户和开发人员之间填写细节的对话的一项承诺。与将所有要求写在一个静态文档中不同，其思想是进行面对面的交流，减少产生误解的机会。
* 发现让客户在现场是可能最好的一种情形，但这不是解决问题的唯一方案。底线是客户必须随时在需要回答问题和根据企业价值为团队提供指示时有空。如果客户并非在现场专职陪伴团队的情况下就能做到这些，那很好。如果能和团队待在一起，这会更方便，但只是建议而已。

## 编码标准

* 拥有编码标准有两个目的：
	- 防止团队被一些例如事物没有以最大速度发展这种无关紧要的愚蠢争论搞得不知所措。
	- 如果没有编码标准，重新划分代码会更加困难，按应当的频度交换对更困难，快速前进也更困难。
* 目标应该是团队中没有人辨认得出是谁写的哪一部分代码。以团队为单位对某一标准达成协议，然后遵守这一标准。目标不是创建一个事无巨细的规则列表，而是提供将确保您的代码可以清晰交流的指导方针。
* 编码标准开始时应该很简单，然后根据团队经验逐步进化。不要预先花费太多时间。创建能够工作的最简单标准，然后逐步发展。

## 一周40小时

* Kent Beck 说他希望*...每天早晨都感到有活力有激情，每天晚上都感到疲惫而满足。*
* 长时间地持续工作会扼杀工作绩效。疲劳的开发人员会犯更多错误，从长期来说，将比按*正常*时间表进行的开发慢得多。
* 即使开发人员可以在长时间很好工作，这也不意味着他们应该这样。最终他们会厌倦，会离开他们的工作，或者产生影响他们工作绩效的非工作问题。如果您打乱了人们的生活，将会尝到它所带来的恶果。
* 加班并不是解决项目问题的答案。实际上，它是更大问题的症状

## 实践

* 反馈环 —— 通过获得反馈，持续改进的方式来适应变化的能力。
* 不断实践，这不像学习别的东西，听个概念就可以跟人辩驳，XP是一门实践性非常强的方法，与Scrum和Kanban有着非常大的不同，Scrum是组织框架设计和角色定义，Kanban适用于团队局部优化，也适用于组织层面工作流的梳理，而XP却是实打实地技术实践。
* 小到可以从单个工程师编写代码养成良好地单元测试的习惯，再到两个人结对开发，进行可以做团队的持续集成，大到整个产品级别或系统级别的持续集成和交付

## 规模化极限编程

* 个人与团队的能力是软件开发最重要的基础。一切不提升个人与团队基本能力的敏捷都是鬼扯。
	- 一切技术不足管理补的所谓「规模化敏捷」都是扯淡.任何「规模化敏捷」、乃至任何「敏捷」的办法，必须基于极限编程的工程技术实践：测试驱动开发，持续集成，重构。
* 极限编程落地之难，实际上不是难在学的这一方，而是难在教的这一方。关于「怎么教新手学编程」这事，极限编程有一个固化在其方法论内的实践：结对编程。而「结对」这事，实际上隐含了一个假设：新手与熟手的人数之比，不能高于1:1，否则就会出现新手没人结对的情况。
	- 团队中新手与熟手的人数之比，或者叫团队的杠杆率，是影响极限编程落地的关键因素。
	- 高杠杆环境下结对编程的不可行，是极限编程在中国难以规模化推广的根本原因。
	- 反复练习和从事某一细分环节的工作，无法使新手获得完整交付软件所需的基本功。对于提升整个团队的基本功水平毫无帮助，这样做的团队注定被锁死在低效率、低质量的状态。
	- 新手程序员并不是不会理解需求、设计软件、保障代码质量，他们只是因为缺乏练习无法在较大的尺度上准确地进行这些动作。
	- 新手无法对较大尺度的需求进行下列操作将其变成较小尺度的开发任务：
		+ 提出诊断性的问题，明确需求的范围和边界；
		+ 进行分析性思考，列举明确的需求验收条件；
		+ 运用概念性思考，用适当的对象模型映射需求。
	- 规模化极限编程（以及，任何形式的规模化敏捷）的必备要素：
		+ 所有程序员，不论熟手还是新手，都进行端到端的需求交付；
		+ 通过比经典的用户故事更细的需求拆分，降低对新手的认知要求；
		+ 以少于4小时工作量的开发任务为基准，通过刻意练习快速训练新手的交付基本功；
* 验收条件
	- 在高杠杆率的环境下，熟手与新手的配合界面必然是比用户故事颗粒度更细、对认知能力要求更低的工件（artifact）,这种工件应该仍然大体符合INVEST原则，尤其是应该可以独立交付（I）、可评估工作量（E）、可测试（T）。当然最重要的是，这种工件应该比用户故事更小（S）：团队普遍水平的程序员应该能在1~4小时内完成其交付。
	- 熟手交给新手去交付的工件，应该是1~4小时颗粒度的验收条件
		+ 能否将需求拆解成1~4小时颗粒度的验收条件。如果不能，说明团队欠缺拆解、细化的能力，说明熟手的工作没有做到位。
		+ 能否在1~4小时内按照质量标准完成验收条件的交付。如果不能，说明团队欠缺编程基本功，说明新手的工作没有做到位。
	- 能否用给定的技术栈，按照给定的质量标准，在给定的时间要求内，实现给定的任务。对于一个典型的Java后端开发人员，他的能力指标
		+ 使用SpringBoot（技术栈）
		+ 在3个小时内（时间要求）
		+ 实现「长度换算」的微服务版本（任务）
		+ 要求测试覆盖率100%，且没有明显的坏味道（质量标准）
* 开发工序管理:把开发人员的工作步骤管理起来，以期其产出的代码达成组织期望的代码质量
	- 要有人把用户故事拆解成一系列足够简单的工序，并且写代码的人要在足够简单的工序中以规范的、高质量的方式来实现
	- 开发人员能不能生产出可以快速回归的软件
		+ 强的开发人员能够按照架构设计把需求分解为可测试步骤组成的工序，并能按照工序高效得写出有测试保护的代码
		+ 弱的人则只能拆解为写代码的步骤，至于能不能测试，就不再考虑范围之内了
	- 把需求分解为可测试步骤这件事：需要特定的胜任力——分析型思考和少量的概念性思考，而这两者在软件开发人员当中是很稀缺
	- 怎么做工序管理
		+ 因为架构是指导如何进行工序分解的，对于怎么做日常编码工作是有强烈的指导意义的。如果架构本身就不是容易测试的，那么对应的工序也就很难形成，或者其中某些步骤的测试成本过高
		+ 给Sr人员进行培训，可以做到“按照架构设计把需求分解为可测试步骤组成的工序，并能按照工序高效得写出有测试保护的代码”。然后由初级的人员，按照工序编写代码\
		+ 工时管理:拆分出的每个任务，都应该在一个固定的时间内完成，如果没有在固定的时间内完成，我们则视为是一个事故，需要针对该事故做分析并提出改进计划
	- 落地细节
		+ 架构师是否拆解工序:架构师首先应该学会这件事，毕竟他要能解决工序如何拆分的问题。
			* 所以还要打个样，看看工序怎么拆分，是不是可以拆为生产可测试代码的工序。
			* 然后他自己也要写一下代码，看看工序映射为代码的过程是否会遇到障碍，有时候自己写一下会发现之前很多关键细节没有想清楚
		+ Sr首先自己要胜任
			* Sr首先自己要能拆出来可以测试的步骤，而这一点其实并不容易。
			* 首先是对于很多人来说，能够分解为可测试的每一步就已经很挑战了，而当把这些步骤映射为代码时候，会发现更多的人根本不能按照自己所划分的任务进行正确的映射。写代码的步骤可能和划分的步骤完全对不上，更不要说每一步都可测试了。这里是能力建设的一个关键点
		+ 优化无止境
			* 通过对工序的完成时间进行追踪，我们不但可以得到高效的个人，还可以发现效率的瓶颈，进一步的改进工序
* 对一线开发能力的要求
	- 需要程序员掌握极限编程的技术实践，具备熟练运用测试驱动开发、重构和持续集成的能力
	- 编程能力 = 技术栈 + 任务 + 质量标准 + 时间
	- Secret Sauce：开发能力公式。这个公式描述的是一线程序员真正每天进行的工作，度量的是他们完成自己每天工作的能力
*  怎么考察员工能力是否达到要求
	-  拿出一个大小合适的任务，指定技术栈，指定质量标准，上好闹钟，考吧。规定时间内完成任务，功能完成，质量达标，你就合格。规定时间交不了卷，不好意思，请再去投个两万个球。——看，完美闭环的能力建设+考查体系
	- [科举](https://ketsu.cn/)
*  暂时没有达到要求的员工开展能力建设
	- 编程能力这事，它是一个实操的事,靠练。要掌握一个技术栈、一种质量要求的能力，就得在这个技术栈上、遵循着这种质量要求反复练习
	- 没有大量刻意练习的编程能力培训都是扯淡
	- 方法
		+ 设定练习的题目；
		+ 对练习的结果给出反馈；
		+ 引导学员进行反思和改进

## 参考

* [Extremeprogramming](http://www.extremeprogramming.org/)
* [XPdeveloper](http://http://www.xpdeveloper.com/)
* [Xprogramming](http://www.xprogramming.com/)
* [What is Extreme Programming?](https://ronjeffries.com/xprog/what-is-extreme-programming/)
* [The Rules of Extreme Programming](http://www.extremeprogramming.org/rules.html)
* [Extreme Programming - Introduction](https://www.tutorialspoint.com/extreme_programming/extreme_programming_introduction.htm)
