# 测试驱动开发 Test-Driven Development TDD

* 正确软件的开发套路
* 提高软件认知能力的方法
* 敏捷开发中的一项核心实践和技术，也是一种设计方法论
* 原理
  - 在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码
  - 分离关注点，一次只戴一顶帽子
  - 只在没有信心的地方写测试代码
  - 红：写一个失败的测试，它是对一个小需求的描述，只需要关心输入输出，这个时候根本不用关心如何实现
  - 绿：专注在用最快的方式实现当前这个小需求，不用关心其他需求，也不要管代码的质量多么惨不忍睹
  - 重构：既不用思考需求，也没有实现的压力，只需要找出代码中的坏味道，并用一个手法消除它，让代码变成整洁的代码
* 测试驱动开发是戴两顶帽子思考的开发方式
  - 先戴上实现功能的帽子，在测试的辅助下，快速实现其功能
  - 再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量
* 测试驱动着整个开发过程
  - 驱动代码的设计和功能的实现
  - 驱动代码的再设计和重构
* XP（Extreme Programming）的核心实践
* 优点
  - 降低开发者负担：通过明确的流程，让我们一次只关注一个点，思维负担更小
  - 保护网：TDD 的好处是覆盖完全的单元测试，对产品代码提供了一个保护网，让我们可以轻松地迎接需求变化或改善代码的设计。所以如果你的项目需求稳定，一次性做完，后续没有任何改动的话，能享受到 TDD 的好处就比较少了。
  - 提前澄清需求：先写测试可以帮助我们去思考需求，并提前澄清需求细节，而不是代码写到一半才发现不明确的需求。
  - 快速反馈：有很多人说 TDD 时，我的代码量增加了，所以开发效率降低了。但是，如果没有单元测试，你就要手工测试，你要花很多时间去准备数据，启动应用，跳转界面等，反馈是很慢的。准确说，快速反馈是单元测试的好处
  - 细化与澄清需求，分Task(Test Driver Business)
  - 分离关注点
  - 快速定位Bug,易于调试
  - 快速得到反馈，增加开发人员信心
  - 帮组系统的设计灵活、松耦合(Test Driver Design)
  - 可执行的以及永远最新的说明文档(Live Document)
  - 更少的回归测试,正确率提高.
  - 安全重构(经验值：80%)
* 重要的不是测试代码本身，是解决问题的思维:小步快跑，快速反馈，实现刚好，设计优美，价值优先，增量完美
* 三层含义
  - Test-Driven Development，测试驱动开发
  - Task-Driven Development，任务驱动开发，要对问题进行分析并进行任务分解
  - Test-Driven Design，测试保护下的设计改善。TDD 并不能直接提高设计能力，只是给更多机会和保障去改善设计
  - Testability Driven Design 可测试性驱动设计，在每一个小步、每一行代码都必须先考虑“怎么测”，可测试性是潜移默化地植根在软件整个建造过程中的，所以用TDD方法开发出来的软件具有极佳的可测试性，质量也自然地更可靠
* 测试具有业务价值，测试的粒度，测试即文档
* DD增加我们的信心，促进反馈周期，价值的稳定的叠加
* 重构是程序员的一项有利工具

## 分类

* UTDD Unit Test Driven Development 单元驱动测试开发
  - 首先编写单元测试用例，然后编写实现代码直到单元测试通过
* ATDD Acceptance Test-Driven Development 验收测试驱动开发
  - BA或者QA编写验收测试用例，然后Dev通过验收测试来理解需求和验收条件，并编写实现代码直到验收测试用例通过
  - 强调的也是需求的澄清，通过举例的手段对用户故事需求进行澄清，再接着让这些例子变成一个个的测试用例，在功能需求被实现后，用这些测试用例去验证功能实现是否满足需求，而这需求的澄清和测试用例的实现是前置在具体的开发实现之前的
  - 因为是通过举例的形式来描述功能的需求说明，也称之为SbE（Specification by Example，中文译为实例化需求），其同样要求测试前置
  - 可以比较着TDD的概念来理解，TDD是对函数级别的需求说明，再驱动实现，而ATDD是对用户故事的级别的需求说明，分析，再驱动实现，都要求测试前置，即关注WHAT
  - 测试自动化是一种缩短反馈周期，实现回归测试（Regression Test）的手段。结合着持续集成系统，可以实现一键自动化的集成与部署
  - BDD（Behavior Driven Development） 以软件的行为为验收标准
  - EDD（Example Driven Development） 以特定的实例数据为验收标准
  - FDD（Feature Driven Development）
  - CDCD（Consumer Driven Contract Development）以Web Service API消费者提出API契约来驱动API提供者开发API
* 单元测试：可以进行的最低级别的测试。通常是在类内部测试方法。单元测试不直接与其他类交互，而是与模拟交互。这使单元测试变得孤立，并且易于调试和重构
* 集成测试：涉及多个类别。因此，它测试了类之间的集成，即依赖关系。它用于测试数据库是否为我们提供了正确的结果，外部 API 是否为我们提供了正确的数据等。它用于测试实际的类和功能，而不是使用模拟。与运行的单元测试相比，它要慢得多，因为它们与数据库和外部提供程序进行交互
* 功能测试：一种测试整个功能的测试，可能需要很多依赖。通常，将测试路由以获取正确的响应，或者测试与应用程序中某些功能相关的 Controller 方法。它们比集成测试慢，因为它们涉及更多的依赖关系
* 验收测试：验收测试是最高级别的测试。只关心该功能是否可以通过客户的有利位置工作。测试流程通过网站单击并提交表格，并期望得到正确的结果。为此，我们使用了 Selenium 之类工具

## 需求设计

* 这个程序，打算怎么给人用呢？
* 软件功能：到底做什么，做到什么程度
  - 确认自己听到的需求，是不是真实、完整的需求
* 软件形态：考虑代码将会如何被使用
* 现象
  - 无视设计
  - 过度设计
* 敏捷，既不是做过度复杂的设计，也不是完全不做设计埋头就开始编码
  - 敏捷，既不是做过度复杂的设计，也不是完全不做设计埋头就开始编码
  - TDD 正是能够快速获得合理设计、并能迅速做出设计调整的能力

## 驱动力 drive

* 设计接口是体现测试驱动开发“驱动力”的重要一点。之所以先编写测试，就是希望开发人员站在调用者和业务价值的角度去思考，即所谓“意图导向编程”。从调用的角度思考，可以驱动思考并达到如下目的：
  - 如何命名被测试类以及方法，才能更好地表达设计者的意图，使得测试具有更好的可读性
  - 被测对象的创建必须简单，这样才符合测试哲学，从而使得设计具有良好的可测试性
  - 测试使我们只关注接口，而非实现

## 流程

* 需求分析
  - 协作需求梳理：澄清-》验收条件-》测试案例
  - Alice (actor) liked (verb) photo ... (object) on Cynthia's album (target). 从中抽取出四个要素：actor，verb，object，target(optional)，通过这四个要素，我们可以描述一个用户的行为
  - 系统组成
    + activity receive and persistence - 当一个行为产生后，外部系统会调用 news feed 来创建 activity；
    + feed generator - 当 activity 创建成功后，它会扩散到所有 subscribers 那里生成 feed；
    + subscription generator - 当 activity 是某种特定 verb 的 activity， 我们维护 object 的 subscription 表（添加/删除）
* 代码设计
  - 定义接口
  - interface review
  - 开发：需要不断地为更加细分的接口设计添加新的测试例
    + 用户级。对于很多项目来说，用户级的接口是 API。这里可能是 rest API，GraphQL，RPC，私有协议等等
    + app级。注意，这里说的 app 并非指一个单独的应用程序，而是逻辑上的概念。一个系统可以逻辑上分解成若干个内部的 app，它们互相作用，最后构成了这个系统。app 间如何互相调用，非常重要。
    + 模块级。我们只需要关心模块的公共接口。私有接口无所谓。
    + 对系统中不确定的，或者变化大的部分，不要引入过多的 case，而对于系统中确定的，或者接口已经发展稳定地部分，不妨把 TDD 延伸到模块级。
  - 分层
    + 把顶层的，用户级别的接口放在一个目录下，app 级别的按 app 名放在不同的子目录，模块级的按模块名放在不同的子目录，不要混在一起。用户级别的接口应该是最稳定的，添加新接口无妨，但是如果已有的接口要改变，我们需要从中分析原因并吸取经验
      * 是需求分析出了岔子，没有明确完整的需求？
      * 是接口设计阶段考虑的不够周全？
      * 是设计水平不够，导致接口不够对变化开放？
* 先分解任务，分离关注点:开卡、验卡，实现验收测试、
  - 确定测试实例化最关键：保证对业务理解一致
* 列 Example，用实例化需求，澄清需求细节
* 写测试，只关注需求，程序的输入输出，不关心中间过程
* 写实现，不考虑别的需求，用最简单的方式满足当前这个小需求即可,方式：红，绿，重构
  - 写一个测试用例
  - 运行测试
  - 写刚好能让测试通过的实现
  - 运行测试
  - 识别坏味道，用手法修改代码
  - 运行测试
* 写完，手动测试一下，基本没什么问题，有问题补个用例，修复
* 转测试，小问题，补用例，修复
* 代码整洁且用例齐全
* 重构，用手法消除代码里的坏味道
* 实践
  - 描述：产品代码的外部行为
  - 新功能：现有代码已有测试保证
  - 失败的：不满足于现状的诉求
  - 刚好：述求简练而有针对性
  - 一次只写一个：小步前进

## 原则

* 简单，只测试一个需求
* 符合 Given-When-Then 格式
* 没有失败的测试就不允许修改软件的行为。
* 在保证不改变软件行为的前提下，可以对代码进行重构，消除其中的坏味道。
* 键盘操作优于鼠标操作。
* 搜索优于导航。
* 对于要处理的数据，首先创建一个对象来表示它。
* 发现一个bug时，首先编写一个失败的测试来描述这个bug。
* 速度快
* 包含断言
* 三大定律 Uncle Bob (Robert Martin)
  - You are not allowed to write any production code unless it is to make a failing unit test pass.不允许编写任何产品代码，除非目的是为了让失败的测试通过
  - You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures. 不允许编写多于一个的失败测试，编译错误也是失败
  - You are not allowed to write any more production code than is sufficient to pass the one failing unit test.不允许编写多于恰好能让测试通过的产品代码
* 防止过度设计

## Unit Test 单元测试

* 动机
  - 驱动和验证功能实现
  - 保护已有的功能不被破坏
* 不能针对方法编写测试，而应根据业务编写测试用例。一个测试方法只能做一件事情，代表一个测试样本和一个业务规则
* 用例太过具体容易忽略测试意图:应该明确描述待测方法的行为，而不是陈述一个例子
  - 生成式测试 Generative Testing，也称Property-Based :会基于输入假设输出，并且生成许多可能的数据来验证假设正确性
    + 先声明传入数据可能的情况，然后使用生成器生成符合入参情况的数据，调用待测方法，最后进行验证
    + Given阶段:Clojure 1.9（Alpha）新内置的Clojure.spec可以很轻松地做到这点
      * 两个参数可能出现的情况或者称为规格（specification）
    + Then阶段:助test.check
    + 凡是想到的情况都能测试，但是想不到情况也需要测试，这才是生成式测试的价值所在
* 测试完备性:找一个明显异常路径进行测试
  - 使用较少的用例做到有效覆盖，比如：等价类、边界值、判定表、因果图、pairwise等等
* Test Double 类型
  - Stub： 测试桩是用来接受SUT内部的间接输入（indirect inputs），并返回特定的值给SUT
  - Spy： Test Spy只负责获取内部情报，并把情报发出去，不负责验证情报的正确性
  - Mock： Mock Object和Test Spy有类似的地方，不同的是，Mock Object还负责对情报（intelligence）进行验证，总部（外部的测试案例）信任Mock Object的验证结果
  - Fake： 仅仅是用来替代一个实际的对象，并且拥有几乎和实际对象一样的功能，保证SUT能够正常工作。实际对象过分依赖外部环境，Fake Object可以减少这样的依赖
  - Dummy：Dummy Objects泛指在测试中必须传入的对象，而传入的这些对象实际上并不会产生任何作用，仅仅是为了能够调用被测对象而必须传入的一个东西
* 命名规则
  - should_not_charge_addition_fare_when_given_distance_is_less_than_base_meter
  - should_charge_addition_fare_when_given_distance_is_more_than_base_meter
* 从依赖的角度看,并不一定需要优先选择前序任务,因为我们可以使用 Mock 的方式驱动出当前任务需要依赖的接口,而不用考虑实现。
* 对于任务的重要性,主要是判断任务是否整个系统(模块)的核心功能。一个 判断标准是确定任务是功能的主要流程还是异常流程
* 从消费者的角度去思考用例
* 选择测试样本 (从易到难，高风险到低风险)
* 参考
  - [改善单元测试的新方法](https://insights.thoughtworks.cn/improve-the-effectiveness-of-unit-testing/)

```
;; 定义输入参数的可能情况：两个整型参数
(s/def ::add-operators (s/cat :a int? :b int?))
;; 尝试生成数据
(gen/generate (s/gen ::add-operators))
;; 生成的数据
-> (1 -122)

(def test-add
(prop/for-all [a (gen/int)
              b (gen/int)]
             (= (add a b) (+ a b))))

;; 随机生成100组数据测试add方法
(tc/quick-check 100 test-add)

;; 测试结果
-> {:result true, :num-tests 100, :seed 1477285296502}
```

## Mock

* 依赖注入（DI）
* 面向接口设计，而不是面向实现
* 限制对外部的依赖
* 不要Mock私有方法，只Mock需要的方法
* 不要自欺欺人
* 什么时候使用

## Test

* 验收条件细化

## 用例分析

* 从消费者的角度去思考用例
* 选择测试样本 (从易到难，高风险到低风险)，用数据来驱动（输入和输出）实现
* 驱动承担该职责的对象,根据意图设计接口
* 实例化需求： Given-When-Then

## Wirte Test first process - Red 需求澄清

* Given
  - 创建被测对象
  - initial input Object or Data
  - 思考它与其他对象的协作
* When
  - 思考被测接口的方法命名,以及它需要接收的传入参数
  - 考虑行为方式,究竟是命令式(verify)还是查询式(assert)方法
* Then
  - 驱动我们分析被测接口的返回值

## Test dirven implementation 实现与设计

* 测试通过：唯一目的
  - 失败的测试：实现新功能的时机
  - 刚好：简单、快捷、频繁验证
  - 不写任何额外的或无关的代码
* 原则
  - 最简单实现
  - 吝啬(结果导向)
  - 尽量少制造坏味道
  - 测试也是一个精打细算的过程
* 仅当Test Case达到2个或更多，并且第2个Case需要更一般化的解决方案时，才对代码实施一般化（泛化/抽象/模式）。

## 设计

* 简单设计 ，并不是没有设计
* 测试过程包括了需求分析和建模
* 测试驱动接口
* 重构，可以从无设计到简单设计，也可以从过度设计到简单设计

## 实践

* 掌握测试驱动开发的方法，练好基本功、改进工作方式，提高开发效率
* 测试前移
* 项目：
  - 要求
    + 代码整洁，没有重复代码
    + 有单元测试，单元测试覆盖率100%
    + 10分钟内完成
  - 技能点
    + JUnit单元测试
    + 测试驱动开发
    + IDEA快捷键
  - 能力目标
    + IDE的快捷键操作
    + 用JUnit编写单元测试
    + 编写失败的测试，驱动出产品代码
    + 充分利用代码生成
    + 刻意练习的节奏

## 重构

* 只在测试全部通过的前提下，做代码重构，或开始新加功能
  - 目前开始了的功能已被实现
  - 已有的产品代码已有测试保证
* 添加新功能与重构显然在同一时刻不共存(两顶帽子)
* 小步提交，随时可以停止

## 分区

* 基于泛化的：给定一个或多个用例，是否可以编写能处理所属分区所有成员的代码？如果是这样，则“铁”变成“金”。
* 将集合划分为子集（也称为分区）
  - 没有分区为空
  - 所有分区的并集是原始集合
  - 没有两个分区具有相同的值
* 选择分区
  - 确定抽象行为相同的分区
    + 不必预先定义所有分区，还可以在实现过程中切换分区
  - 硬编码结果:只需选择下一个输入值，然后添加完成的代码即可
  - 泛化（转换）:适用于特定值的代码转移到支持很多输入的代码,使用现有的测试作为防护网–必须不断使它们通过
    + 当不对每个分区中的值检查时，我们是否可以写出适用于该分区的每个值的泛化代码？
  - 扩大分区:条件反映分区的全部范围
  - 确认测试
  - 统一代码:目标是使两个或更多代码段更加相似，因为可以合并它们的分区。
    + 统一是实施Kent的“三角测量”策略的一种方法：实现多个用例，然后尽可能地统一它们
  - 重构：合并条件分支
* 显示更多信息：
  - 红色–从分区中选择示例输入值。为此编写一个失败的测试。
  - 绿色–编写使测试通过的代码。
    + 显而易见的实现-不用理会用例，只需实现代码即可。
    + 伪造（直至完成）-首先返回一个常数，然后逐步将其替换为变量，直到获得完整的实现。
    + 三角测量–从两个或多个用例泛化。
  - 泛化–修改代码，以便所有测试仍然可以通过，其余分区也可以工作。
  - 重构–改进实现代码，并尽可能在分区之间泛化。
  - 重复直到处理完所有分区

## 问题

* 不会合理拆分任务
* 不会写测试
* 不会写刚好的实现
* 不会重构
* 有没有Tasking?
  - 将一个原本的较大的需求，分解成一个个很小的需求,往往是非常容易的。通过这样的方式，可以缩短我们红绿重构的周期，得到快速的反馈
* 有没有选择最简单的Task先做？

## 实例

* 需求描述
  - Part A (总计 40 分) 首先,“羽毛球场管理系统”需要提供“询价”服务，当用户输入"How much?"的时候，系统应返回如下信息：

```
    ********Price********
    Welcome to badminton
    -------Workday-------
    9:00~12:00 30 yuan/h
    12:00~18:00 50 yuan/h
    18:00~20:00 80 yuan/h
    20:00~22:00 60 yuan/h
    -------Weekend-------
    9:00~12:00 40 yuan/h
    12:00~18:00 50 yuan/h
    18:00~22:00 60 yuan/h
    **Have a good day !**
```

- 注意！价目表会实时变动，我们在文件 BadmintonDataLoader 中提供了函数 LoadWorkdayPriceList()和函数 LoadWeekendPriceList(),用来分别提供工作日和周末的价目表，当我修改价目表时程序仍需能正常工作。
- 需求点/得分点
  + (5 分）能正确输出第一行、第二行和最后一行，如：

```
    ********Price********
    Welcome to badminton
    **Have a good day !**
```

    + (15 分）能正确输出 workday 部分，如：

```
    -------Workday-------
    9:00~12:00 30 yuan/h
    12:00~18:00 50 yuan/h
    18:00~20:00 80 yuan/h
    20:00~22:00 60 yuan/h
```

    + (10 分）能正确输出 weekend 部分，如：

```
    -------Weekend-------
    9:00~12:00 40 yuan/h
    12:00~18:00 50 yuan/h
    18:00~22:00 60 yuan/h
```

    + (10 分）能按正确的顺序打印以上三个部分

- Part B (总计 60 分)同时系统需要提供预定场地的功能，当用户想预定场地时，需要告知系统用户ID、时间，以及场地号，因此用户向系统输入的格式为：Book {用户ID} {yyyy-MM-dd HH:mm~HH:mm} {场地编号} 例如：用户 0001 想预定 3 号场地，且时间为：2019 年 12 月 1 号 14:00 到 15:00 时，用户需要向系统输入以下信息：Book 0001 2019-12-01 14:00~15:00 3
  + 如果场地预定成功，那么系统会返回预定成功的提示以及所需费用。 例如：Success! You can use the No.3 court during 2019-12-11 14:00~15:00.
  + 为了保证系统正常运行，以下情况将会预定失败：
    - 预定时间不是整小时,指定场地在该时间段(部分或全部)已经被预定了
    - 预定结束时间早于开始时间，如：15:00 ～ 14:00
    - 预定的开始时间早于 9:00，如：8:00 ～ 10:00
    - 预定的结束时间晚于 22:00，如：20:00 ～ 23:00
    - 如果不幸预定失败，那么系统会返回失败提示：Sorry! Something wrong, please call the manager!
- 需求点/得分点
  + (5 分) 假设预定成功，程序能打印出关键信息点：“success”, 场地编号, 预定的时间区间. 例如： Success! 3 2019/12/11 14 - 15
  + (15 分) 可以成功预定且程序打印出来的信息完全正确。
  + (6 分) 当预定时间不是整小时时，系统会返回失败提示。
  + (12 分) 当指定场地在该时间段(部分或全部)已经被预定了时，系统会返回失败提示。
  + (6 分) 当预定结束时间早于开始时间，如：15:00 ～ 14:00时，系统会返回失败提示。
  + (6 分) 当预定的开始时间早于 9:00，如：8:00 ～ 10:00时，系统会返回失败提示。
  + (6 分) 当预定的结束时间晚于 22:00，如：20:00 ～ 23:00时，系统会返回失败提示。
- Part C (附加题,总分 50 分)为了方便客户，系统还需提供取消预定的功能，当用户想取消预定时，也需要告知系统用户ID、时间，以及场地号，相应的，用户向系统输入的格式为：Cancel {用户ID} {yyyy-MM-dd HH:mm~HH:mm} {场地编号}，例如：Cancel 0001 2019-12-11 14:00~15:00 3
  + 如果取消成功，那么系统会返回成功的提示：Cancel Success! Look forward to your next visit！
  + 假如取消的时候产生了违约金，系统返回的提示将变为：Cancel Success! You need pay 25 yuan as penalty. Look forward to your next visit！
  + 以下情况将会取消失败：
    - 取消预定时间不是整小时用户并没有预定指定场地的指定时间段(必须和预定时间段完全一致)
    - 当取消预定失败时，系统会返回失败提示：Sorry! Something wrong, please try again!
- 需求点/得分点
  + (15 分) 可以取消成功，且不论是否产生违约金，程序能打印出:Cancel Success! Look forward to your next visit！
  + (15 分）可以取消成功，且产生了违约金，程序打印出来的信息完全正确。
  + (10 分）当预定时间不是整小时时，系统会返回失败提示。
  + (10 分)当用户并没有预定指定场地的指定时间段(必须和预定时间段完全一致)时，系统会返回失败提示。

## 图书

* 《测试驱动开发》Kent Beck
* Grow Object-Oriented Software Guided by Tests

## 工具

* Dbunit
* Rest-Assusred
* [hoverfly](https://github.com/SpectoLabs/hoverfly):Lightweight service virtualization/API simulation tool for developers and testers <https://hoverfly.io>

## 参考

* [dojo-scaffold](https://github.com/gigix/dojo-scaffold):A Java/Gradle scaffold for coding dojos
