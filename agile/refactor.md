# Refactor 重构

一种对软件内部结构的改善，目的是在保证既有功能的外部行为不变的前提下，提高其可理解性，降低其修改成本

* 一种以可控的方式整理代码的技术，在不改变软件可观察行为的前提下改善其内部结构。
* 时刻保证代码质量
* 随着系统的演进，重构代码也是不可避免
* 如何通过高效安全地改善内部设计以使之适应外部的不确定性和频繁变化

## 为什么

* 让软件始终可以维护，保证开发效率。
* No code is perfect(不要怕删除代码)
* 改进设计
  - 消除坏味道
  - 提高可扩展性
* 提高可读性
  - 代码是写给人看的而不是编译器
  - 明确的表达业务意图
* 帮助发现Bug

## 如何做

* 什么时候开始
  - 重构不应该是一个单独的环节，应该融入到开发软件编写代码的过程中，就像使用版本控制系统提交代码一样，是一个必须做的动作。你不会跟项目经理说，我需要申请一段时间来提交代码，所以也不用说服项目经理给你时间重构。你可以在开发新功能，修复 Bug 的过程中就把重构做了，除了你的程序员同伴，没有人知道你做了什么。而他们会认为你做了一件了不起的事情，因为你让代码结构更清晰了，以后添加新特性就会更容易，而 Bug 也无处藏身。
  - 如果采用 TDD 的方式（测试驱动开发），那重构已完全融入到了开发过程中。如果没有采用 TDD，通常有四个时机可以考虑要不要重构：
    + 事不过三:如果有段代码让你修改起来很不舒服，前两次还可以忍耐，第三次就无需再忍了，果断操起 IDE 重构之。因为出现了三次修改，说明有很大概率以后还会修改，这是一笔划算的投资。
    + 添加新功能:有时候我们发现要添加一个新功能很难，我们可以对代码做一些重构，让添加新功能变得容易。
    + 修复缺陷:在修 Bug 时，我们大部分的时间会花在定位 Bug 上，为什么这么难以找到呢？多半是因为代码结构不清晰，如果代码在同一抽象层次上，每个方法都在 10 行以内，每个方法名和变量名都能清晰地表达意图，Bug 就再无藏身之处。所以，通过重构代码，可以让 Bug 自动浮现出来。
   + 代码评审:Code Review 已是一个广泛采用的实践，在 Code Review 时，其他程序员会提出代码修改的意见，记录下来，等 Code Review 结束之后就可以开始重构了。
* 什么时候停止 简单设计四条原则：
  - 通过所有测试
  - 没有重复
  - 表达意图
  - 最少化程序元素（类，接口，变量，方法等）
* 前提条件
  - 现代 IDE，尤其是 JetBrains 公司的一系列产品，支持常用的重构手法，极大地降低了重构的风险。但为了保证不改变软件的可观察行为，还是需要完善的测试。我也做过一些没有测试代码保护的重构，通常会加一个端到端测试以保证不破坏最重要的功能。实在很难编写测试代码，至少也要手工测试来保证重构真的没有改变软件行为。
  - 另一个重要前提是，使用版本控制系统，比如 Git。因为我们的重构并不一定总是令人满意，也有可能出现错误，导致软件变得不可用，所以最好是小步提交，以保证可以随时放弃变更，回到上一次满意的状态。
* 重构的过程
  - 测试保护:如果没有测试代码，就要先添加测试代码。如果有测试代码，先运行一下，保证在开始重构之前，测试是运行通过的。还要认真审查一下测试代码，看是否有遗漏一些场景，有遗漏的话要补充遗漏的测试场景。
  - 识别味道:《重构》一书中列举了 22 中常见的味道，如果你看《Clean Code》的话，会发现还有更多.不过，他们并没有给出一个具体的标准，而是需要我们的直觉来判断
  - 采用手法
  - 运行测试
    + 在采用了手法修改代码之后，就要执行测试以确保真的没有改变软件的行为。可能有时会发现，做了重构之后测试会失败，但实现并没有问题，我们需要修改测试代码让它成功。这就说明测试写的不合理，给重构带来了负担，所以我们测试的粒度要把握好，太细的粒度就会增加维护成本。比如，有些人会给每个私有方法都写单元测试，那有可能采用「内联函数」这个手法之后这个方法就不存在了，就需要修改测试。这里说起来话就长了，以后再写一篇如何写有效的测试的文章吧。重点是重构之后，一定要执行测试，不管是手工测试或自动化测试。
  - 提交代码
    + 如果采用了一个比较复杂的手法，或者即将采用一个复杂的手法，最好先提交一下代码，以保证出现意外后能快速回滚，避免浪费时间。
  - 采取「小步快跑」的原则，尽量采用安全的手法，让测试一直处于通过的状态。 从低级的坏味道开始，消除低级味道之后，高级味道才会浮现出来。

## 标准

* 消除味道：一个重构应该是从识别一个坏味道（Bad Smell）开始，以消除一个坏味道结束，任何不以消除坏味道为目标的重构都是耍流氓。
* 始终工作：即重构定义中的“在不改变软件可观察行为的前提下”，说白了就是重构过程不能破坏甚至改变软件外在功能。
* 持续集成：不需要为重构单建分支，重构过程可以做到Feature开发在同一分支上持续集成持续交付。
* 随时中止：例如一个方法重命名，需要修改100个调用点，当改到50个的时候有个紧急的Feature，我可以随时暂停重构，立即切换到Feature开发上，且不需要回滚已做的重构。
* 断点续传：还是上边的例子，假如我已经完成了紧急Feature的开发，可以随时继续之前的重构，完成剩下50个调用点的重命名。
* 过程可逆：对于重构，经常有人会问：你怎么保证重构就会更好而不是更坏呢？重构的伟大就在于他跳出了对错之争，将关注点放到如何快速平滑安全的变化上，当然也包括反向重构。所以我的回答是：无法保证，但是我可以一分钟就重构回来。如果仔细看，《重构》书里的所有重构手法都是双向的，比如“Extract Method”和“Inline Method”

## 坏味道

* 膨胀剂
  - Long Method
    + 拥有短函数的对象会活的比较好、比较长。
    + 绝大部分情况下，要把函数变小，只需要使用Extract Method(提炼函数)。
    + 使用Extract Method(提炼函数)时，如果函数中有个别参数和临时变量，可以把他们当做参数，传递给被提炼出来的新函数。
    + 如果被提炼函数内有大量的参数和临时变量，可以运用Replace Temp with Query(以查询取代临时变量)来消除这些临时元素。
    + 使用Introduce Parameter Object(引入参数对象)可以将过长的参数列变得更简洁一些。
    + 如果被提炼函数仍然有太多临时变量和参数，可以使用Replace Method with Method Object(以函数对象取代函数)。
    + 注释通常能够指出应该被提炼的代码。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数去。
    + 可以使用Decompose Conditional(分解条件表达式)处理条件表达式。
    + 你应该将循环和其内的代码提炼到一个独立的函数中。
  - Large Class
    + 如果想利用单个类做太多事情，其内往往就会出现太多实例变量。一旦如此，重复代码也就接踵而至了。
    + 可以运用Extract Class(提炼类)将几个彼此相关的实例变量一起提炼至新类内。如果被提炼出的类适合作为一个子类，使用Extract Subclass(提炼子类)往往比较简单。
    + 有时候类并非所有时刻都使用所有实例变量。你可以多次使用Extract Class(提炼类)或Extract Subclass(提炼子类)。
    + 和“太多实例变量”一样，类内如果有太多代码，也是代码重复、混乱并最终走向死亡的源头。
    + 如果有五个“百行函数”，他们之中有很多代码相同，那么你也许可以把他们变成五个“十行函数”和十个提炼出的“双行函数”。
    + 和“太多实例变量”一样，类内如果有太多代码，往往也适合使用Extract Class(提炼类)或Extract Subclass(提炼子类)。
    + 如果你的过大的类是一个GUI类，你可能需要把数据和行为移到一个独立的类中。
  - Primitive Obsession(基类类型偏执)
    + 大多数编程环境都有两种数据：结构类型允许你将数据组织成有意义的形式；基本类型则是构成结构类型的积木块。
    + 对象技术的新手通常不愿意在小任务上运用小对象——像是结合数值和币种money类、由一个起始值和一个结束值组成的range类、电话号码或邮政编码等的特殊字符串。
    + 你可以运用Replace Data Value with Object(以对象取代数据值)将原本单独存在的数据值替换为对象，从而走出洞窟，进入炙手可热的对象世界。
    + 如果想要替换的数据值是类型码，而它并不影响行为，则可以运用Replace Type Code with Class(以类取代类型码)将它换掉。
    + 如果有与类型码相关的条件表达式，可运用Replace Type Code with Subclass(以子类取代类型码)或Replace Type Code with State/Strategy(以State/Strategy取代类型码)加以处理。
    + 如果有一组应该总是被放在一起的字段，可运用Extract Class(提炼类)。
    + 如果在参数列中看到基本类型数据，不妨试试Introduce Parameter Object(引入参数对象)。
    + 如果发现自己正从数组中挑选数据(数组中的元素各自代表不同的东西)，可运用Replace Array with Object(以对象取代数组)。
  - Long Parameter List(过长参数列)
    + 太长的参数列难以理解，太多参数会造成前后不一致、不易使用。
    + 刚开始学习编程时，老师教我们：把函数所需的所有东西都以参数传递进去。这可以理解，因为除此之外只能选择全局数据，而全局数据是邪恶的东西。
    + 对象技术改变了这一情况：如果你手上没有所需的东西，总可以叫另一个对象给你。有了对象，函数需要的东西多半可以在函数的宿主类中找到。面向对象程序中的函数，其参数列通常比在传统程序中短的多。
    + 如果向已有的对象发出一条请求就可以取代一个参数，那么你应该激活重构手法Replace Parameter with Method(以函数取代参数)。
    + 你还可以运用Preserve Whole Object(保持对象完整)将来自同一对象的一堆数据收集起来，并以该对象替换他们。
    + 如果某些数据缺乏合理的对象归属，可使用Introduce Parameter Object(引入参数对象)为他们制造出一个“参数对象”。
    + 这里有一个例外：有时候明显不希望造成“被调用对象”与“较大对象”间的某种依赖关系。这时候将数据从对象拆解出来单独作为参数，也很合情合理。但是请权衡其所引发的代价。
  - Data Clumps(数据泥团)
    + 数据项就像小孩子，喜欢成群结队地待在一块儿。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。
    + 首先运用Extract Class(提炼类)将他们提炼到一个独立对象中，然后将注意力转移到函数签名上，运用Introduce Parameter Object(引入参数对象)或Preserve Whole Object(保持对象完整性)为它减肥。这样做可以缩短参数列，简化函数调用。
    + 如果删掉众多数据中的一项，其他数据不再有意义，那么他们应该以一个对象的形式存在。
    + 一旦拥有新对象，你就有机会让程序散发出一种芬芳。可以将适当的程序行为移至新类。不必太久，所有的类都将在他们的小小社会中发挥价值。
* OO 使用不合理
  - Switch Statements
    + 面向对象程序的一个最明显特征就是：少用switch语句。从本质上说，switch语句的问题在于重复。面向对象中的多态概念可为此带来优雅的解决办法。
    + 使用Extract Method(提炼函数)将switch语句提炼到一个独立函数中，再以Move Method(搬移函数)将它搬移到需要多态性的那个类里。
    + 必须决定是否使用Replace Type Code with Subclass(以子类取代类型码)或Replace Type Code with State/Strategy(以State/Strategy取代类型码)。一旦这样完成继结构之后，就可以运用Replace Conditional with Polymorphism(以多态取代条件表达式)了。
    + 如果只是在单一函数中使用switch语句，多态就有点杀鸡用牛刀了。这种情况下Replace Parameter with Explicit Methods(以明确函数取代参数)是个不错的选择。如果你的选择条件之一是null，可以试试Introduce Null Object(引入null对象)。
  - Alternative Classes with Different Interfaces(异曲同工的类)
    + 如果两个函数做同一件事，却有着不同的签名，请运用Rename Method(函数改名)根据他们的用途重新命名。
    + 反复运用Move Method(搬移函数)将某些行为移入类，直到两者的协议一致为止。如果你必须重复而赘余地移入代码才能完成这些，或许可运用Extract Superclass(提炼超类)为自己赎点罪。
  - Temporary Field
    + 有时会看到这样的对象：其内某个实例变量仅为某种特定情况而设。这样的代码让人不宜理解，因为通常认为对象在所有时候都需要它的所有变量。
    + 请使用Extract Class(提炼类)给这个可怜的孤儿创造一个家，然后把所有和这个变量相关的代码都放进这个新家。
    + 或许还可以使用Introduce Null Object(引入Null对象)在变量不合法的情况下创建一个Null对象，从而避免写出条件式代码。
    + 如果类中有一个复杂算，需要好几个变量，实现者不希望传递一长串参数，所以他把这些参数放进字段中，导致坏味道。这些字段只在使用该算法时才有效，你可以利用Extract Class(提炼类)把这些变量和其相关函数提炼到一个独立类中。提炼后的新对象将是一个函数对象。
  - Refused Bequest
    + 子类应该继承超类的函数和数据。但如果他们得到所有礼物，却只从中挑选几样来玩！又该怎么办呢？
    + 按传统做法，你需要为这个子类新建一个兄弟类，再运用Push Down Method(函数下移)和Push Down Field(字段下移)把所有用不到的函数从超类下推给那个兄弟。这样，超类就只持有所有子类共享的东西。
    + 不建议胡乱修改继承体系，应该运用Replace Inheritance with Delegation(以委托取代继承)来达到目的。
* 难以修改
  - Divergent Change(发散式变化)
    + 我们希望软件能够更容易被修改。一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改。
    + 如果某个类经常因为不同的原因在不同的方向上发生变化， Divergent Change(发散式变化)就出现了。
    + 针对某一外界变化的所有相应修改，都只应该发生在单一类中。为此，应该找出某特定原因而造成的所有变化，运用Extract Class(提炼类)将他们提炼到另一个类中。
  - Shotgun Surgery(散弹式修改)
    + Shotgun Surgery(散弹式修改)类似Divergent Change(发散式变化)，但恰恰相反。
    + 如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是Shotgun Surgery(散弹式修改)。
    + 如果需要修改的代码散布四处，你不但很难找到他们，也很容易忘记某个重要的修改。
    + 你应该使用Move Method(搬移函数)和Move Field(搬移字段)把所有需要修改的代码放进同一个类。
    + 如果眼下没有合适的类可以安置这些代码，就创造一个。通常可以运用Inline Class(将类内联化)把一系列相关行为放进同一个类。
    + Divergent Change(发散式变化) 是指“一类受多种变化的影响”。
    + Shotgun Surgery(散弹式修改)则是指“一种变化引起多个类响应修改”。这两种情况你都希望整理代码，使“外界变化”与“需要修改的类”趋于一一对应。
  - 发散式变化和散弹式修改是比较容易混淆的两个味道。前者指一个类的职责过多，有很多因素会引起它的变化，具体的表现就是，不同的需求都会修改同一个文件，导致经常冲突，不能顺利地并行开发。后者指的是改一个需求要修改很多个文件，说明没有把强内聚的代码归拢到一起。
  - Parallel Inheritance Hierarchies
    + Parallel Inheritance Hierarchies(平行继承体系)其实是Shotgun Surgery(散弹式修改)的特殊情况。在这种情况下，每当你为某个类添加一个子类，必须也为另一个类相应增加一个子类。
    + 让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用Move Method(搬移函数)和Move Field(搬移字段)，就可以将引用端的继承体系消弭于无形。
* 可有可无
  - Comments
    + 注释本身不是一种坏味道，事实上他们还是一种香味呢。
    + 有时候，注释之所以存在乃是因为代码很糟糕。把注释当做除臭剂是一种坏味道。
    + 很多时候，注释可以帮助我们找到代码的坏味道。找到坏味道之后，我们首先应该以各种重构手法把坏味道去除。完成之后我们常常会发现：注释已经变得多余了，因为代码已经清晰说明了这一切。
    + 如果需要注释来解释一块代码做了什么，试试Extract Method(提炼函数)；如果函数已经提炼出来，但还是需要注释来解释其行为，试试Rename Method(函数改名)；如果需要注释说明某些系统的需求规格，试试Introduce Assertion(引入断言)。
    + 当感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。
    + 注释应该用来记述将来的打算、标记你并无十足把握的区域。你可以在注释里写下自己“为什么做某某事”。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。
  - Duplicated Code
    + 如果在一个以上的地点看到相同的程序结构，设法将他们合而为一，程序会变得更好
    + 同一个类的两个函数含有相同的表达式，采用Extract Method(提炼函数)提炼出重复的代码
    + 两个互为兄弟的子类含有相同的表达式，首先对两个类都使用Extract Method(提炼函数)，然后再对提炼出来的代码使用Pull Up Method(函数上移)，将它推入超类
    + 如果代码之间只是类似，并非完全相同，运用Extract Method(提炼函数)将相似部分和差异部分分割开，然后可以运用Form Template Method(塑造模板函数)获取一个莫模板方法
    + 如果有些函数以不同算法做相同的事情，你可与选择其中较清晰的一个，使用Substitute Algorithm(替换算法)将其他函数的算法替换掉
    + 如果两个毫不相关的类出现重复代码，应考虑对其中一个使用Extract Class(提炼类)，将重复代码提炼到一个独立的类中
    + 重复代码所在的函数应该只属于某一个类，另一个类调用它；或者应该属于第三个类，另两个类引用这第三个类。决定重复函数的最合适位置，确保只有一份
  - Lazy Class
    + 创建的每一个类，都得有人去维护它。如果一个类的所得不值其身价，就应该消失。
    + 如果某些子类没有做足够的工作，试试Collapse Hierarchy(折叠继承体系)。
    + 对于几乎没用的组件，你应该以Inline Class(将类内联化)对付他们。
  - Data Class(幼稚的数据类)
    + 幼稚的数据类是指：他们拥有一些字段，以及用于访问(读写)这些字段的函数，除此之外一无长物。
    + 这样的类只是一种不会说话的数据容器，他们几乎一定被其他类过分细锁地操纵着。
    + 应该运用Encapsulate Collection(封装集合)把他们封装起来。对于那些不该被其他类修改的字段，请运用Remove Setting Method(移除设值函数)。
    + 找出这些取值/设值函数被其他类运用的地点。尝试Move Method(搬移函数)把那些调用行为搬移到Data Class(幼稚的数据类)来。如果无法搬移整个函数，就运用Extract Method(提炼函数)产生一个可被搬移的函数。不久以后你就可以运用Hide Method(隐藏函数)把这些取值/设置函数隐藏起来了。
    + Data Class(幼稚的数据类)就像小孩子。作为一个起点很好，但若要让它们像成熟的对象那样参与整个系统的工作，它们就必须承担一定责任。
  - Speculative Generality(夸夸其谈未来性)
    + 当有人说“噢，我想我们总有一天需要做这事”，并企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。
    + 如果所有装置都会被用到，那就值得那么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬开吧。
    + 如果你的某个抽象类其实没有太大作用，请运用Collapse Hierarchy(折叠继承体系)。
    + 不必要的委托可运用Inline Class(将类内联化)除掉。
    + 如果函数的某些参数未被用上，可对它实施Remove Parameter(移除参数)。
    + 如果函数名称带有多余的抽象意味，应该对它实施Rename Method(函数改名)，让它更现实一些。
* 耦合
  - Feature Envy
    + 对象技术即是一种“将数据和对数据的操作行为包装在一起”的技术。
    + Feature Envy(依恋情节)指的是：函数对某个类的兴趣高过对自己所处类的兴趣。
    + 常常看到某个函数为了计算某个值，从另一个对象那儿调用了几乎半打的取值函数。此时，应该使用Move Method(搬移函数)把它移到它该去的地方。
    + 先使用Extract Method(提炼函数)，将这个函数分解为数个较小函数并分别置于不同地点，有助于Move Method(搬移函数)重构手法的实施。
    + 如果一个函数用到几个类的功能，那么需要判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起
  - Inappropriate Intimacy(狎昵关系)
    + 有时你会看到两个类过于亲密，花费太多时间去探究彼此的私有成分。如果这发生在两个“人”之间，我们不必做卫道士；但对于类，我们希望他们严守清规。
    + 可以采取Move Method(搬移函数)和Move Field(搬移字段)帮他们划清界限，从而减少狎昵关系。
    + 你也可以看看是否可以运用Change Bidirectional Association to Unidirectional(将双向关联改为单向关联)，让其中一个类对另一个斩断情丝。
    + 如果两个类实在是情投意合，可以运用Extract Class(提炼类)把两者共同点提炼到一个安全地点，让他们坦荡地使用这个新类。或者也可以尝试运用Hide Delegate(隐藏“委托关系”)让另一个类来为他们传递相思情。
    + 继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得是该让这个孩子独自生活了，请运用Replace Inheritance with Delegation(以委托取代继承)让它离开继承体系。
  - Message Chains(过度耦合的消息链)
    + 如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。
    + 应该使用Hide Delegate(隐藏“委托关系”)。
    + 先观察消息链最终得到的对象时用来干什么的，看看能否以Extract Method(提炼函数)把使用该对象的代码提炼到一个独立函数中，再运用Move Method(搬移函数)把这个函数推入消息链。
  - Middle Man(中间人)
    + 对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随委托。
    + 人们可能过度运用委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。
    + 这时应该使用Remove Middle Man(移除中间人)，直接和真正负责的对象打交道。
    + 如果这样“不干实事”的函数只有少数几个，可以运用Inline Method(内联函数)把他们放进调用端。
    + 如果这些中间人还要其他行为，可以运用Replace Delegation with Inheritance(以继承取代委托)把它变成实责对象的子类，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。
  - Incomplete Library Class
    + 复用常被视为对象的终极目的。许多编程技术都建立在程序库的基础上。
    + 库类构筑者没有未卜先知的能力，我们不能因此责怪他们。库往往构造的不够好，而且往往不可能让我们修改其中的类使它完成我们希望完成的工作。
    + 如果你只想修改库类的一两个函数，可以运用Introduce Foreign Method(引入外加函数)；如果想要添加一大堆额外行为，就得运用Introduce Local Extension(引入本地扩展)。

## 实践

* 方法
  - 旧的不变
    + 做内部结构调整时，先不要直接修改旧的结构，保持旧的结构不变，先按照新的设计思路创建一个新的结构，因为这个过程中对于旧的内部结构没有任何影响，所以是安全的，可持续集成的
  - 新的创建
  - 一步切换：并不是说整个重构的切换过程必须是一步完成的，一步切换指的是每一个调用点的切换过程
    + 当新的结构构件完成时，再把对于旧结构的依赖一个个的切换到新的结构上，即所谓的”一步切换“。
  - 旧的再见
    + 最后当确认所有对于旧的结构都切换到新的结构上，而且没有问题后，再将已经没有任何引用的旧结构删除掉，完成整个重构过程

* 大型重构:顶层代码设计包括：系统、模块、代码结构、类与类之间的关系等的重构
  - 分层、模块化、解耦、抽象可复用组件
* 小型:代码细节
  - 规范命名、规范注释、消除超大类或函数、提取重复代码
  - 提取类或接口
    + 在父子类之间转移方法
      * Pull Members Up 选项将子类方法上移到父类中
      * Push Members Down
  - 提取方法、变量、字段
    + Extract Method 提炼函数
  - 提取/内联变量
  - 提取方法/功能
  - 重命名
  - 重构接口
    + 抽象出来构建一个接口
* 封装变量、参数
* 用多态替换条件
* 重构依赖于单元测试和可测试的代码（即短小、可 mock 的代码）

* 过度if嵌套
  - 拦截法：只要符合条件立马返回结果，不再嵌套的if
  - 逆向思维
* 过度try-catch嵌套
  - 尽可能业务最上层包裹异常 除非网络IO请求函数。
  - 如果非要异常嵌套 需要定义每个异常的类型。
  - 尽可能根据特定的异常进行catch 不建议直接catch Exception。
  - 异常和日志是个cp，还是不要忘记了
* 不要用if-else做错误类型判断
  - 用mapping错误码：配置错误信息数组到专门枚举文件内
* 用全局错误码来控制错误
* 擅用middleware
  - 身份检测
  - 权限判断
  - 请求参数filter调整
  - 记录接口信息
  - 接口限流
* 函数单一职责
  - 能把业务的流程图画的特别清晰，那么你的函数的职责也就定下来了

## 常用手法

* 重组函数
  - 抽取方法
  - 分解临时变量
  - 内联方法
  - 移除对参数赋值
  - 抽取变量
  - 以函数对象取代函数
  - 内联临时变量
  - 替换算法
  - 查询取代临时变量
* 搬移特性
  - 搬移函数
  - 隐藏“委托关系”
  - 搬移字段
  - 移除中间人
  - 提炼类
  - 引入外加函数
  - 内联类
  - 引入本地扩展
* 组织数据
  - 自封装字段
  - 以对象取代数组
  - 以对象取代数据值
  - 复制被监视数据
  - 将值对象改为引用对象
  - 单项关联到双向关联
  - 引用对象改为值对象
  - 双向关联到单向关联
  - 字面常量取代魔法数
  - 数据类取代记录
  - 类型取代类型码
  - State/Strategy取代类型码
  - 封装字段
  - 封装集合
  - 子类取代类型码
  - 字段取代子类
* 简化条件
  - 分解条件表达式
  - 卫语句取代嵌套条件
  - 合并条件表达式
  - 多态取代条件
  - 合并重复条件片段
  - 引入Null对象
  - 移除控制标记
  - 引入断言
* 简化调用
  - 函数改名
  - 零函数携带参数
  - 添加参数
  - 用函数取代参数
  - 移除参数
  - 保留完整对象
  - 引入参数对象
  - 用函数取代参数
  - 移除设值函数
  - 隐藏函数
  - 以测试取代异常
  - 封装向下转型
  - 以异常取代错误码
  - 以工厂函数取代构造函数
  - 将查询函数与修改函数分离
* 处理概括
  - 字段上移
  - 字段下移
  - 函数上移
  - 构造子嘞
  - 构造函数本体上移
  - 抽取超类
  - 函数下移
  - 抽取接口
  - 折叠继承关系
  - 塑造函数模版
  - 以委托取代继承
  - 以继承取代委托

## 命名

* 做有意义的区分

## 层次

* 业务架构的审查重构:这是最高层次的代码审查重构。其实，这个阶段的审查并未真正涉及到具体的代码实现，而是针对客户需求，对相应的业务逻辑的设计进行审查，目的在于使业务逻辑架构的设计与用户需求保持精确一致。
  - 审查复杂且完整的业务逻辑的架构，比如支付相关的业务逻辑架构，导航，map，语音相关的业务等等。这个层次的审查需要我们充分了解相关的业务知识，进而审查业务架构的合理性与准确性。以支付为例，我们需要熟悉支付方式以及支付的整个流程，另外还有其中涉及的一些关键问题。最终确保我们的业务逻辑的架构设计符合这一系列的需求。
  - 审查简单的单个功能点的业务逻辑设计实现，例如用户的注册与登录功能。我们需要确保这些业务逻辑的设计完全符合UX的设计，并最终符合用户需求。
* 代码架构的审查重构:项目中采用的具体的架构模式，目的在于审查代码是否符合架构模式。在我们目前的项目中采用的是mvvm架构模式，因此在这个层次的代码审查的时候应注重审查代码是否遵循了mvvm的基本原则。
  - View部分：其中包含了view组件以及ViewController主要的功能应在于处理界面的显示，而不应有任何的业务逻辑的处理；
  - ViewModel部分：应主要负责业务逻辑的处理，并不涉及任何页面的展示逻辑。
  - Model部分：应主要负责业务数据模型的建立，使用它可以根据业务逻辑建立相应的业务数据。
* 设计模式的审查重构:主要针对的是面向对象开发中的类之间的组织结构以及类自身行为属性的设计，这可能就会涉及到一些设计模式的使用。通过使用设计模式，可以使我们的代码更加的可复用，可扩展以及可测试。这是我们这个阶段进行设计模式的审查重构的目的。然而设计模式的过度使用也会使代码陷入“万恶的深渊”，提前设计与设计过度同样不可取。
  - 代码应尽量保持简单，只有在必要的时候才使用设计模式，避免过度设计与提前设计。
  - 设计应遵循面向对象编程的SOLID原则。
  - 使用规范化的设计模式的“术语”编写，如设计模式中类的命名等相关“术语”应标准化，规范化。
  - 使用结构型设计模式进行类的组织结构设计。这其中包括：Composite, Decorator, Adapter, Bridge, Facade, Proxy, Flyweight。
  - 使用行为型设计模式进行类方法的设计, 进行封装变化，对象做为参数的封装，对象间通信，类间解耦合。包括：Strategy, State, Template method, Visitor, Command, Memento, Observer, Mediator, Iterator, Interpreter, Chain of responsibility。
  - 使用创建型设计模式进行类型的创建初始化。它包括：Factory method, Abstract factory, Builder, Prototype, singleton。
* 最优算法的审查重构:审查重构针对的是代码算法的使用，主要审查面向对象类中方法的算法设计实现。这里说的算法的使用并非一定要使用那些经典的算法，例如排序算法，查找算法等，而指的是使用合理的数据结构进行时间与空间最优化的代码编写，不分配不必要的空间，尽量设计时间复杂度更低的的代码段。总之，设计更为高效的代码段。
* 语言与代码规范的审查重构
  - 语言最佳实践的审查与重构:代码编写首先应符合使用的编程语言的语法规范，除此之外，我们还应该努力践行编程语言的最佳实践，比如尽量使用语言已提供的库中的API，避免重复建造轮子。我们项目中采用的是swift语言，在涉及到集合类的遍历处理的时候，我们不应该自己编写for in loop来实现遍历的功能，而应使用集合类的从sequenceType中继承而来的foreach方法，通过闭包的方式讲要处理的行为变量传人，从而实现遍历处理的功能。
  - 代码风格的规范的审查与重构:统一的代码风格规范是团队开发的重要要素之一。代码规范的统一有利于代码的阅读维护，有利于代码的“集体所有制”。
    + 命名：使用帕斯卡命名法命名类名，即名称中每个单词首字母大写，采用形容词+名词的形式；驼峰法命名函数与属性，即名称中除第一个单词首字母小写外，其他单词首字母均大写。函数命名采用动词+名词的组合形式。属性命名采用形容词+名词的形式。通过使用有意义的命名，使属性与函数通过名称可以自我表达，从而取代注释。
    + 函数：保证每个函数的单一功能性，让每个函数只做一件事情。采用“To”方法编写函数，就是将函数分步编写，使每个步骤单独成为一个新的函数。函数参数个数应尽量减少，可以封装在一起的尽量封装起来。
    + 避免重复：应避免代码的随处拷贝，拷贝是重复的根源之一。应将可复用的部分提取出来，供不同的使用者调用。
    + 代码一致性：一致性可以使代码更整洁美观。项目中为了保持一致性，我们需要一些约定俗成的事情，例如命名规则，要不要使用宏定义等等。
    + 去除魔幻数：不应在代码中硬编码一些数据，比如：expectedValue = actualValue*5 + 20，类似这种代码，没人能看明白代码中的5和20是神马意思。我们可以使用宏定义或者创建静态属性的方式实现，定义成为可被理解阅读的代码。
    + 封装条件表达式中的条件判断：代码中的条件表达式中如果有很多的条件判断时，对于阅读代码的人来说，很难读懂到底为了判定什么东西设立的这些条件。将条件表达式中的条件判断封装成为一个单独的方法，并命名一个有意义的名称，可以极大的提高代码的可读性。
    + 函数异常处理：保持代码的安全性，需要时刻注意异常的处理。异常处理分为两个部分，首先是空值的判定，避免程序因空值造成的crash。空值判定主要包括函数参数的空值判定以及内部局部变量的空值判定；其次是异常的处理，比如io异常等等。
    + 单元测试：单元测试的重要性相信大家都应该清楚，只是鉴于开发进度压力，往往被忽视。对于小型并不复杂的项目而言，可能单元测试的作用没有完全体现出来，但是对于复杂度很高，团队规模较大的项目而言，单元测试就无比重要了。我目前所做的项目，复杂度非常高，团队规模也很大，并且需要与欧美团队协同开发，因此保证单元测试的代码覆盖度非常重要。因此，应保证每段代码都应被单元测试覆盖
    + 多线程并发处理。开发中会经常涉及到多线程的问题，因此多线程的并发处理需要高度重视，很多问题就是由于多线程并发造成。

## 能力

* UT 覆盖率
* 代码复杂度
* 代码耦合度
* 语言是否对 refactor 提供支持

## IDE重构

借助 IDE 对代码进行重构

* 编写代码的过程中，看到可以重构的地方，按下IDE 的快速键，迅速地完成战斗
* 应该作为日常开发的一部分，而不是额外的花费时间进行重构
* 只要能开始去改变，那就是一个好的开始
* 一种有限的代码质量改善

## 环境

* 如果花几天、一天、两天的时间，要对之前一个月的代码重构，那么并不存在问题——业务在不断叠加，每隔一段时间都会出现代码、架构上的问题。这个时候的抢救，能及时把设计正确的方式。再往后推移，可能会影响整个系统的架构，成功地实现了“千里之堤，溃于蚁穴”
* 如果一处代码的重构，需要花费四五天的时间，那么就需要正视这个问题。它不是一个小问题，可能存在多个问题。对它的重构和改善，往往需要和团队里的资深程序员一起讨论。

![](../_static/refactor.png "Optional title")

## 重构与设计的关系

* 有了重构技术，不用在前期做非常详细的设计，做适当的设计，然后通过重构让设计浮现出来。不用在乎软件是否符合模式，只要符合原则即可。

## 大型遗留系统的重构

* 分类
  - 不会被执行的烂代码
  - 运行稳定，基本不会改动的烂代码
  - 经常发现 Bug 的烂代码
  - 经常需要变更的烂代码
* 真正有价值，值得重构的，投入产出比最高的，是经常出问题和经常会有需求变更的烂代码。优化了这部分代码，可以减少 Bug 和进行需求变更的时间。

## 《重构》第二版

* 重构不应改变原有程序的可观测的行为
* 把添加新功能和重构当做两件不同的事情来对待，就像两顶帽子，在开发过程中我们经常两顶帽子换着戴
* 小步重构，更安全的前进，让代码在绝大部分时间处于可工作的状态
* 捡垃圾式的重构：发现一个垃圾时，不想跑题太多，同时也不想将垃圾留在原地；如果此时很容易重构，就立即完成，否则就记录下来，等后续再来重构
* 绝大多数的重构是见机行事的，而非单独安排的一项工作
* 重构的唯一目的是让我们开发更快，用更少的工作量创造更高的价值；重构不是来自“整洁的代码”“良好的工程实践”等道德要求，而是纯粹从经济角度出发的考量
* 自测试代码是重构的基石，也是持续集成的关键环节。要想“敏捷”做到名副其实，必须要做好这三大实践–自测试代码、持续集成、重构（自测试代码和重构一起构成了TDD）
* 小步重构
  - 用封装变量将类型码封装到一个函数内部
  - 创建一个工厂函数，根据类型构造不同的子类
  - 创建其中一个子类
  - 在工厂函数中替换构造出来的对象
  - 对每个类型重复上述操作
  - 去除类型码
  - 使用函数下移重构和以多态处理条件表达式重构来处理原来的函数调用处的代码
* 营地法则
  - 每个人都应当在提交代码时停下来想一下，这次提交是让代码更健康了，还是更腐化了，还是没变化？只有我们每次提交代码都至少没有让代码更腐化，代码才能越来越健康。一些腐化的例子比如我们引入了一个坏味道，我们测试覆盖率降低了等等。而一个健康的例子就是我们在增加功能的时候，顺便重构了原来的代码，让其可读性更高，可复用性更好等等
  - 应该至少在离开营地时，让营地比来时更干净。如果每次经过一段代码，都让其变得更干净，积少成多，垃圾总是会被处理掉
* PR进行代码复审还是专门组织代码复审活动:
  * 可以在阅读他人代码之后，如果有一些点子，就可以直接进行重构，从而获得比想象出来的更直观的认识。这样的代码复审活动最好能有代码作者一起pair，不仅可以有机会充分理解原来的代码，还能一起分享重构的意图
  * 以Pull Request的方式进行代码复审和合并。看起来由于多了一道关卡，我们合入主干的代码质量能有所提高。但是这样的分支管理策略是不够敏捷的，它之所以适合在GitHub上推行，是由于GitHub上面的项目多是由分布式的团队完成。有一大群水平参差不齐的，对代码理解也差异巨大的开发者可能要一起修改代码，并且大家还要跨地域跨时区进行协作。要支持这样的团队开发，多分支策略有其优势。但是对于我们日常的敏捷团队而言，大家每天坐一起，专注在同一个项目上，这样的多分支策略就显得过于重量级了，发挥不出团队可以随时沟通交流的优势
  * 少数人pair的方式进行复审，我个人更推荐回归到每天的团队代码复审活动中来
* 重构与单分支管理策略
  - 特性分支游离的时间越长，合并越痛苦。基于单分支的策略，只要代码能通过测试，我们就可以随时将本地可用的代码推送到分支上，随时集成。这对于重构带来的压力将会小很多很多
* 重构与测试
  - 测试是重构的保护伞，需要有一组可靠的测试才能放手进行重构
  - 测试达到一定程度之后，其边际效用会递减。如果编写太多测试，我们可能因为工作量太大而气馁.应该把注意力集中在最容易出错和最没有信心的地方
* 不依赖于某个特定测试框架进行测试
  - 用到了 mocha和chai两个JavaScript的测试工具，还有一个用来模拟对象的库sinon
  - 基于工具而非某个特定框架去组织测试的实践使我在平常工作中获益良多，而基于某个特定框架实现的测试往往维护困难

## 图书

* 架构腐化之谜
* 修改代码的艺术
* 《编写可读代码的艺术》
* 《[重构：改善既有代码的设计（第2版）(Refactoring: Improving the Design of Existing Code)](https://www.amazon.cn/gp/product/B011LPUB42)》 Martin Fowler
* [《系统重构与迁移指南》](https://github.com/phodal/migration) 手把手教你分析、评估现有系统、制定重构策略、探索可行重构方案、搭建测试防护网、进行系统架构重构、服务架构重构、模块重构、代码重构、数据库重构、重构后的架构守护 https://migration.ink/
* 《代码整洁之道》
* 《设计模式 - 可复用面向对象软件的基础》
* 《重构与模式》
* Transformation Priority Premise
* 用 IntelliJ IDEA 重构
* 重构十六字心法
* 练习重构的 Kata

## 参考

* [Js重构](https://github.com/hankzhuo/Blog/blob/master/JS/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84.md)
* [代码审查与重构的5个层次](http://www.techug.com/post/five-level-of-code-review.html)
* [refactoring-kata](https://github.com/aikin/refactoring-kata):Refactoring Kata：涵盖所有重构手法练习的栗子和测试。重构刻意练习。
* [Refactoring Guru](https://refactoring.guru/)
