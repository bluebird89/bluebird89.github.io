# 代码整洁之道

* 代码大部分时候是用来维护的，而不是用来实现功能的
  - 一方面是编译好让机器执行，完成功能需求；
  - 另一方面，是写给身边的队友和自己看的，需要长期维护
* 优秀的代码大部分是可以自描述的，好于文档和注释
  - 注释不能让写的烂的代码变的更好。如果别人只能依靠注释读懂你的代码的时候，你一定要反思代码出现了什么问题
  - 比较适合写注释的两种场景：
    + public interface，向别人明确发布你功能的语义，输入输出，且不需要关注实现。
    + 功能容易有歧义的点，或者涉及比较深层专业知识的时候。比如，如果你写一个客户端，各种config参数的含义等
* 设计模式只是手段，代码清晰才是目的
  - 防止过度设计
  - 大部分抽象只有一个实现的时候，要好好思考一下，是不是设计有点过度了，清晰永远是第一准则

## Practice

* code review
  - 凡是能通过机器检查出来的事情，无需通过人
  - 更应该关注代码的设计与风格:一段功能是不是应该属于一个类、是不是有很多相似的功能可以抽取出来复用、代码太过冗长难懂等等
  - 集体code review，因为很多时候，组里相对高级的工程师能够一眼发现代码存在较大设计缺陷，提出改进意见或者重构方式。我们可以在整个小组内形成一个好的文化传承和风格统一，并且很大程度上培养了大家对clean code的热情
* 勤于重构
  - 掌握一些常见的“无痛”重构技巧，这在下文会有具体讲解。
  - 小步快跑，不要企图一口吃成个胖子。改一点，测试一点，一方面减少代码merge的痛苦，另一方面减少上线的风险。
  - 建立自动化测试机制，要做到即使代码改坏了，也能保证系统最小核心功能的可用，并且保证自己修改的部分被测试覆盖到。
  - 熟练掌握IDE的自动重构功能。这些会很大程度上减少我们的体力劳动，避免犯错。
* 静态检查
  - 多读开源代码和身边优秀同学的代码
  - 开源社区，为我们提供了这么好的学习机会。无论是JDK的源码，还是经典的Netty、Spring、Jetty，还是一些小工具如Guava等

* 先理解程序的总体结构
* 高内聚低耦合的结构能减少软件复杂度
* 数据与代码的分离
* 优先使用不变的对象
* 多用接口少用类
* 对模块应用良好的原则
  - 尽可能减少依赖
  - 每个项目应该有一个明确的职责
  - 不要重复自身
* 避免继承
* 将测试作为设计和开发的一部分:开始编码时先编写测试代码会使得代码十分自然地遵循许多指导原则。
* 优先使用标准库而不是手写的
* 避免编写新的代码

## skills

* 单一职责
  - 要定义的东西，如果不能用一句话描述清楚职责，就把它拆掉
  - 把方法拆细，这是复用的基础
* 优先定义整体框架
  - 写很多空实现，来把整体的业务流程穿起来
  - 良好的方法签名，用入参和出参来控制流程。这样能够避免陷入业务细节无法自拔
  - 脑海中先定义清楚流程的几个阶段，并为每个阶段找到合适的方法／类归属.无论读到什么深度，都可以清晰地了解每一层的职能，如果不care下一层的实现，完全可以跳过不看，并且方法的粒度也会恰到好处
  - 写代码的时候“广度优先”而不是“深度优先
* 清晰的命名
  - 思考一个方法命名的时间，比写一段代码的时间还长。原因还是那个逻辑：每当你写出一个类似于"temp"、"a"、"b"这样变量的时候，后面每一个维护代码的人，都需要用几倍的精力才能理顺
  - 代码自描述最重要的基础
* 避免过长参数
  - 参数长度超过4个，就需要警惕了
    + 没有人能够记得清楚这些函数的语义
    + 代码的可读性会很差
  - 如果参数非常多，意味着一定有很多参数，在很多场景下，是没有用的
  - 解决:构造paramObject。用一个struct或者一个class来承载数据，一般这种对象是value object，不可变对象。这样，能极大程度提高代码的可复用性和可读性。在必要的时候，提供合适的build方法，来简化上层代码的开发成本
* 避免过长方法和类
  - 横向拆分:根据业务，把建立／更新／修改／通知等逻辑拆到不同的类里去
  - 纵向拆分:把数据库操作/MQ操作/Cache操作/对象校验等，拆到不同的对象里去，让主流程尽量简单可控，让同一个类，表达尽量同一个维度的东西
* 让相同长度的代码段表示相同粒度的逻辑:尽量多地去抽取private方法，让代码具有自描述的能力
* 面向对象设计技巧
  - 贫血与领域驱动
  - 为每个方法找到合适的类归属，数据和行为尽量要在一起:主张数据和行为在一起
    + service对象。如果操作一个对象数据的所有方法都建立在对象内部，可能使对象承载了很多并不属于它本身职能的方法
    + 如果一个行为，无法明确属于哪个领域对象，牵强地融入领域对象里，会显得很不自然。这时候，无状态的service可以发挥出它的作用。但一定要把握好这个度，回归本质，要把属于每个模型的行为合理的去划定归属
  - 警惕 static
    + 真正适用场景：工具方法，而不是业务方法
  - 巧用method object
    + 一个有数据有行为的对象。依赖的数据会成为这个对象的变量，所有的行为会成为这个对象的内部方法
    + 利用成员变量代替参数传递，会让代码简洁清爽很多。并且，把一段过程式的代码转换成对象代码，为很多面向对象编程才可以使用的继承／封装／多态等提供了基础
* 面向接口编程
  - 正确使用继承和组合
    + protected abstract 这种是最值得使用继承的，父类保留扩展点，子类扩展
    + protected final 这种方法，子类是只能使用不能修改实现的
      * 抽象出主流程不能被修改的，然而一般情况下，public final更适合这个职能。如果只是流程的一部分，需要思考这个流程的类归属，大部分变成public组合到其他类里是更合适的
      * 父类是抽象类无法直接对外提供服务，又不希望子类修改它的行为，这种大多数情况下属于工具方法，比较适合用另一个领域对象来承载并用组合的方式来使用
    + protected 这种是有争议的，是父类有默认实现但子类可以扩展的。凡是有扩展可能的，使用继承更理想一些。否则，定义成final并考虑成组合
    + 继承更多的是为扩展提供便利，为复用而存在的方法最好使用组合的方式
* 代码复用技巧
  - 模板方法
    + 每当有两个行为类似但又不完全相同的代码段时
    + 提取公共流程和可复用的方法到父类，保留不同的地方作为abstract方法，由不同的子类去实现
    + 在合适的时机refactor，pull method up（复用）或者 pull method down（特殊逻辑）
    + 把不属于流程的、但可复用的方法，判断是不是属于基类的领域职责，再使用继承或者组合的方法，为这些方法找到合适的安家之处
  - extract method
  - 责任链
    + 一连串类似的行为，只是数据或者行为不一样。如一堆校验器，如果成功怎么样、失败怎么样；或者一堆对象构建器，各去构造一部分数据。碰到这种场景，我总是喜欢定义一个通用接口，入参是完整的要校验／构造的参数
    + 出参是成功/失败的标示或者是void。然后有很多实现器分别实现这个接口，再用一个集合把这堆行为串起来。最后，遍历这个集合，串行或者并行的执行每一部分的逻辑
    + 好处：
      * 很多通用的代码可以在责任链原子对象的基类里实现；
      * 代码清晰，开闭原则，每当有新的行为产生的时候，只需要定义行的实现类并添加到集合里即可；
      * 为并行提供了基础
  - 为集合显式定义操作封装起来
  - 对于有明确语义的集合的一些操作，尤其是全局的集合或者被经常使用的集合，做一些封装和抽象，如把Map封装成一个Cache类或者一个config类，再提供GetFromCache这样的方法

## 函数

* 函数的第一规则是要短小
* 函数应该做一件事,做好这件事
* 每个函数一个抽象层级。自顶向下读代码
  - 每个函数都应该保留一个抽象层级，而且尽量只做一件事
  - 抽象:指代要做的事情的概念，而不是具体的细节实现
