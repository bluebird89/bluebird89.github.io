
## 作用域

* 代码块分显式代码块和隐式代码块
* 有花括号一般都存在作用域的划分
* := 简式声明会屏蔽上层代码块中的变量和常量
* 在 if 等语句中存在隐式代码块，需要注意
* 闭包函数可以理解为一个代码块，并且可以使用包含它的函数内的变量

## 代码结构化与项目管理

* 当某个包被导入时，如果该包还导入了其他的包，那么会先将其他包导入进来，再对这些包中的包级常量和变量进行初始化，接着执行 init() 函数，依次类推。
* 当所有被导入的包都加载完毕之后，就会对 main 包中的包级常量和变量进行初始化，然后执行 main 包中的 init() 函数，最后执行 main() 函数。
* init 函数
    - 用于程序执行前进行包的初始化，例如初始化包中的变量
    - 每个包可以拥有多个 init 函数
    - 包中的每个源文件也可以拥有多个 init 函数
    - 同一个包中的 init 函数执行顺序不定
    - 不同包中的 init 函数按照导入的依赖关系决定该函数的执行顺序
    - init 函数不能被其他函数调用，其在 main 函数执行之前，自动被调用
* go build/install：用来编译包和其依赖的包
    - go build 只对 main 包有效，在当前目录编译生成一个可执行的二进制文件
        + 依赖包生成的静态库文件放在 $GOPATH/pkg
    - go install 一般生成静态文件，放在 $GOPATH/pkg 目录下，文件扩展名为 a
    - go run 只能作用与 main 包文件，先运行 compile 命令编译生成 a 文件，然后链接命令生成最终可执行文件并运行程序
        + 此过程中产生的是临时文件，在 go run 推出钱会删除这些临时文件（包括链接文件和二进制文件？），最后直接在命令行控制台输出运行结果。
        + 当再次运行的时候会检查导入的包是否变化，如果没变化，则不会进行模块再次编译。
* go mod
    - GO111MODULE=off：不使用 Go Mod，继续沿用 GOPATH 机制
    - GO111MODULE=on：源代码不必放在 GOPATH 下，会忽略 GOPATH，只根据根目录的 go.mod 下载依赖的包，但是它还是会把依赖的包下载到 GOPATH/pkg/mod 目录下
    - GO111MODULE=auto：如果源代码在 GOPATH/src 外并且根目录包含 go.mod，那么启动 go mod，否则不启用。
* 复合数据类型
    - 数组长度也是数组类型的一部分，所以 [5]int 和 [10]int 是属于不同类型的
    - Go 语言中的数组是一种值类型（不是指针），所以可以使用 new 来构建
    - 数组参数是值传递（所以传递数组可能会耗费很多内存），避免方法是
        + 数组指针
        + 切片
    - 数组的大小最大为 2G
    - 切片是一个引用类型（和数组不一样）
    - 一旦初始化，切片始终与保存其元素的基础数组相关联
    - 明确说明长度（包括 [...]）的初始化是数组，没有明确指定的是切片
    - 如果有多个切片引用同一个底层数组，会导致底层数组无法 GC，从而导致内存占用过高（规避方法为使用 copy）
    - 如果切换添加元素导致底层数据扩张，或产生一个新的底层数组，但是，如果有多个切片引用原来的数组，那么这些切片不是引用到新的数组（结果就是两个切片数据不一样了）
    - map 如果大概知道容量，最好先提前声明，因为数据到达 map 的容量之后，每次添加都是只 +1
    - map 的 range 时数据的副本，直接修改不能对原 map 产生影响

## type 关键字

* 不常用的基础类型：complex64/ complex128/error/rune/string/uinptr
* Go 语言不支持隐式类型转换，因此所有的转换都必须显式说明

| 数据类型 | 自定义类型                                           | 类型别名              |
|:-----|:------------------------------------------------|:------------------|
| 概念   | 一种新的数据类型                                        | 只是一个类型的别名         |
| 语法   | type MyTYpe int                                 | type MyType = int |
| 数据结构 | 拥有数据结构但是不会拥有原基础类型所附带的方法（尤其是针对于 struct 类型）       | 和原类型这俩个类型完全一致     |
| 方法   | 接口方法或组合类型的内嵌元素则保留原有的方法（用 type struct 实现类似集成的效果） | 和原类型这俩个类型完全一致     |

```go
type NewMutex Mutex    // 两个类型的数据结构一样，但是 NewMutex 方法是空的
type PrintableMutex Struct {
Mutex
}    // PrintableMutex 拥有 Lock 和 Unlock 方法
```

## 错误处理与 defer

* 一般不要随意用 panic() 来中止程序，必须尽力补救异常和错误以便让程序能继续运行
* 在自定义包中需要做好错误处理和异常处理，这是所有自定义包都应该遵守的规则
    - 在包内部，应该用 recover() 对运行时异常进行捕获
    - 向包的调用者返回错误值（而不是直接发出异常）
* recover() 的调用仅当它在 defer 修饰的函数中被直接调用时才有效
* recover() 用于取得异常传递过来的错误值；如果是正常执行，调用 recover() 函数会返回 nil（如果 panic 的参数是 nil，那么 recover 返回的值也是 nil）
* defer 的规则
    - defer 声明时，其后面函数参数会被实时解析
    - defer 执行顺序为先进后出
    - defer 可以读取函数的有名返回值（并且修改，修改之后返回值就是修改后的值）
        + 原因是 return 不是原子操作，具体流程为
            * 所有返回值在进入函数时，都会被初始化为其类型的零值
            * 退出时，先给返回值赋值
            * 执行 defer 命令
            * return 操作
* 利用 defer 的延迟执行的特性，可以利用它来计算代码块的执行时间

## 函数

* 在进行函数调用时，像 slice/map/interface/channel 和 指针等这样的引用类型都是默认使用引用传递

| 函数      | make                                                             | new                                |
| :---     | :-----                                                           | :----                              |
| 使用情况  | 只用于 slice/map 和 channel 这三种引用数据类型的内存分配和初始化 | 用于值类型的内存分配，并且置为零值 |
| 初始化    | 数据结构内的元素为零值                                       | 变量为零值                         |
| 返回值    | make(T) 返回的类型 T 的值                                  |  new(T) 分配类型 T 的零值并且返回其地址（T 的指针）|

##  结构体

* Go 语言中，结构体和它所包含的数据在内存中是以连续的块的形式存在的，即使结构体中嵌套有其他的结构体；这在性能上带来了很大的优势。
* 标签的内容不可以在一般的编程中使用，只有 reflect 包能获取它。
* reflect 包可在运行时反射得到类型，属性和方法。
* 如果考虑结构体和接口的嵌入组合方式一共有 3 种
    - 在接口中嵌入接口
        + 接口不能嵌入接口本身，否则编译会出错
    - 在接口中嵌入结构体：这种在 Go 语言中是不合法的，不能通过编译
    - 在结构体中内嵌接口
        + 如果结构体实现了接口，那么在构建实例的时候可以不传接口对应的字段；
        + 也可以在构建实例的时候给接口字段传递一个实现了该接口的实例。
* 在结构体中嵌入结构体
    - 可以在结构体中嵌入结构体，但是不能嵌入自身值类型，可以嵌入自身的指针类型（即递归嵌套）；
    - 在初始化时，内嵌结构体也进行赋值；
    - 外层结构自动获得内嵌结构体定义的字段和实现的方法；
    - 内嵌结构体的字段可以逐层选择来使用，如 stu.Human.name；如果外层结构体中没有同名的 name 字段，也可以直接选择使用，如：stu.name
    - 当结构体两个字段拥有相同的名字，那么外层的名字会覆盖内层的名字（但是可以通过全路径访问）；
    - 当相同的名字在同一层级出现两次，那么这个名字将不能被直接引用（否则会引发一个错误），可以采用逐级选择使用的方式来避免这个错误。
    - ！！！如果结构体 A 中嵌入结构体 B，那么无论接受者是 B 还是 *B 的方法都可以被 A 或者 *A 使用；
    - ！！！如果结构体 A 中嵌入指针 *B，因为默认不会初始化 *B，所以如果 *B 为 nil 的话，无论是调用接受者为 B 还是 ×B 的方法都会出错，但是如果初始化了 B，那么调用接受者是 B 和 ×B 的方法都是可以的；
    - ！！！无论接受者是 A 还是 *A，都可以使用接受者是 A 或者 *A 的方法；
* 通过结构体指针 stu.name 相当于 (*stu).name，这是一个语法糖，一般都使用 stu.name 方式来调用，但要知道有这个语法糖存在。
* Go 语言中的接口通常很简短，会包含 0～3 个方法
* 当想知道一个接口类型的真实类型时，有以下几种方式
    - type-switch 做类型判断
    - comma-ok 类型断言

## 方法

* 接收器除了不能是 接口 和 指针 类型之外，可以是其他任何类型（包括函数）
* 接收器不能是 指针 类型，但是可以是类型的指针
* 方法的接收器为 (t T) 时称为值接收器，该方法称为值方法；方法的接收器为 (t *T) 时称为指针接收器，该方法称为指针方法
    - 区别：如果想要方法修改接收器的数据，那么就用指针方法；值方法是不能修改接收器的数据的
* 类型 T（或者 ×T）上的所有方法的集合叫做类型 T（或 ×T）的方法集
* 如果用类型 T 的变量调用指针方法，那么 x.m() 其实是 (&x).m() 的简写，是一种语法糖
* 可以利用选择器显式得取得方法值，并可以将其赋给其他变量
* 类型和方法必须在同一个包中定义，否则会发生编译错误
* 实现接口不能混用指针方法和值方法
    - 如果使用指针方法来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口
    - 如果使用值方法来实现一个接口，那么那个类型的值和指针都能够实现对应的接口
* 怎么选择值方法和指针方法
    - 选择值方法（一般情况下接收器是分配在栈上，节省内存 GC）
        + 如果接收器是一个 字典/函数或者通道，那么选择值方法，因为它们本身就是引用类型
        + 如果接收器是一个 切片，并且方法不执行切片重组操作，也不重新分配内存，那么也可以使用值方法
        + 如果接收器是一个小的数组或者原声的值类型数据结构体类型（time.Time），并且没有可修改的字段和指针又或者接受器是一个简单的基本来行
    - 选择指针方法
        + 方法需要修改接收器的数据
        + 接收器是一个包含了 sync.Mutex 或者类似同步字段的结构体（这样可以避免复制）
        + 接收器是一个大的结构体或者数组（更加高效）
        + 接收器是一个结构体/数组和切片，元素可能被修改，建议使用指针方法，增加可读性
* 内嵌继承规则
    - 如果 S 包含了匿名字段 T，那么 S 和 *S 的方法集都继承了 T 的的方法集；同时类型 *S 还额外集成了 *T 的方法集
    - 如果 S 包含了匿名字段 *T，那么 S 和 *S 的方法集都集成了 T 和 *T 的方法集
    - 但是，如果发现 S 类型也可以调用 *T 的方法，不是因为规则失效，而是因为 Go 中的语法糖 ，对于值类型 s 调用方法 s.Private() 其实是 (&s).Private()

##  面向对象和内存

* Go 语言没有类概念，而是松耦合的类型，方法以及接口的实现；
* Go 语言用接口实现多态；
* 指针变量在 32 位计算机上占用 4B 内存，在 64 位机器计算机上占用 8B 内存，并且与它所指向的值大小无关；
* 不能得到一个数字或常量的地址；
* 什么时候用指针参数，什么时候用值参数
    - 在需要改变参数的值或者避免复制大批量数据而节省内存时都会选择指针
    - 指针的频繁使用也会导致性能下降，指针也可以指向另外一个指针，并且可以进行任意深度的嵌套，形成多级的间接引用，但会使代码结构不清晰；
* new 和 make
    - new 返回指针，make 返回值；
    - new 分配内存，并且置为空值；make 完成内存分配和初始化；
* 当内存资源不足时，调用 runetime.GC()，此函数的执行会让系统立即释放不再使用的变量或对象占用的内存；
* func Set Finalizer(obj interface{}, finalizer interface{}) 有两个参数
    - obj 必须指向指针类型
    - finalizer 是一个函数，参数类型是 obj 的类型，没有返回值；
* GOGC 可以用于设置垃圾回收百分比，如果车给你需占用内存达到 (1 + GOGC/100)MB 的两倍时，即可触发 GC。

## 并发处理

* MPG
* 关闭 channel 后，无法再向通道发送数据（否则引发运行时错误），但是，可以接续从 channel 接收数据
* 对于 nil channel，无论是发送还是接收都会被阻塞
* Mutex
    - 同一个协程中同步调用使用 Lock 加锁后，不能再对其加锁，否则又是一个运行时异常
    - 如果使用 Unlock 前没有加锁，就会引发一个运行错误；
    - 已经锁定的 Mutex 不与 goroutine 绑定，可以在 goroutine A 中加锁， goroutineB 中解锁。
    - Mutex 零值是可以操作的锁了
* 读写锁
    - 如果未加（读/写）锁就解锁，会引发一个运行时异常；
    - 写解锁时，会试图唤醒所有因进行读锁定而被阻塞的协程；
    - 读解锁时，会试图唤醒所有因进行写锁定而被阻塞的协程；
    - sync.RWMutex 零值也是可以操作的锁了
* sync.WaitGroup
    - Add(-1) 和 Done() 效果一致
* sync.Once
    - sync.Once(f func()) 能保证 Do() 方法只执行一次
* sync.Map
    - 在 Go1.9 中增加了一个新的特性：sync.Map

## 测试与调优

* 断言函数
    - t.Fail：标记这个测试失败，并且继续执行其他的（包括该文件中的）
    - t.FailNow：标记这个测试失败，并且该文件中的测试都不执行了，继续下一个文件的测试
    - t.Log：将格式化的日志打印到错误日志中
    - t.Fatal：先执行（3），然后再执行 （2）
* 调优
    - 如果使用 testing 包进行基准测试功能，则可以用 go test 的标准的 -cpuprofile 和 -memprofile 标志向指定文件写入 CPU 和内存使用情况报告；
    - pprof

## 系统标准库

* 反射
    - 反射是应用程序动态检查其所拥有的结构，尤其是类型对象的一种能力
    - Go 中反射机制就是运行时动态检测调用对象的方法和属性
    - 反射的 value 是实际变量值，type 是实际变量类型，不能是接口类型
    - Type 的主要方法：
        + Kind 返回的是一个常量，便是具体的类型的底曾类型
        + Elem() 反馈指针/数组/切片 字典通道等类型
    - 反射针对性能有一定影响，避免使用
    - Type 返回的是静态类型(MyInt)，kind 返回的是基础类型(int)
    - 通过 CanSet() 判断原始反射对系那个 v reflect.Value 是否可以写，CanAddr 是否可寻址
    - 虽然反射可以越过 Go 语言的导出规则限制读取结构提中未导出的成员，但是不能修改他们
* unsafe
    - Go 语言的指针与 int 类型在内存中占用的字节数相同，ArbitraryType 类型的变量有可以是指针
    - uintptr 这个基础类型的字节长度与 int 一致
    - uintptr 和 unsafe.Pinter 可以相互转换
* Sort
    - sort 包中实现了几种基本的排序算法
    - search 返回能够使用 F(i) == true 成立的最小下标 i，并且会假定如果 F(i) == true，则 F(i+1) == true
    - 如果 x 不存在，search（x）返回切片的长度
* IO
    - 内核中的缓冲：无论进程是否提供缓冲，内核都是提供缓冲的，系统对磁盘的读写都会提供一个缓冲（内核高速缓冲），将数据写入到块缓冲进行排队，当块缓冲达到一定的量时，才把数据写入磁盘；
    - 进程中的缓冲：是对输入输出流进行改进，提供一个流缓冲，当调用一个函数向磁盘写数据时，才把数据写入缓冲区，当达到某个条件，这时候才会把数据一次送往内核提供的块缓冲中，再经块缓冲写入磁盘。
    - bufio 读同一个文件耗费时间最少

## 网络服务

* 上下文：使用上下文时需要遵循以下规则
    - 上下文变量需要作为地一个参数使用，一般命名为 ctx
    - 不要传入一个 nil 的上下文，如果不确定，用 context.TODO
    - 使用上下文的 Value 下给你管方法之传递请求的相关元数据，不要传递可选参数
    - 同样的上下文可以用来传递给不同的协程，上下文在多个协程中是安全的

## 数据格式与存储

* Json
    - 在 Go 中，Marshal 默认是设置 escapeHTML = true，会自动把< > 等字符转换成 \u003e
    - encoding/json 包提供 Decoder 和 Encoder 类型，NewDecoder 和 NewEncoder 函数分别封装了 io.Reader 和 io.Writer 接口
    - json.RawMessage 将在解码后继续以字节数组方式存在
* SQL
    - 在 Go 中对数据类型要求很严格，一般查询数据时先定义数据类型，但是查询数据库中的数据有三种状态：存在值，存在零值和未赋值 NULL，因此可以将待查询的数据类型定义为 sql.NullXXX 类型，通过判断 Valid 值来判断查询到的值是赋值状态还是未赋值 NULL 状态

* LevelDB
    - 性能不可预知，在数据量小的时候性能很好，但随着数据量的增加，读性能会越来越糟糕。并且做合并的县城也会在服务器上出现问题;
    - LevelDB 实现了一个日志结构化的 MergeTree，让它不需要每次有数据更新就将数据写入到磁盘中
    - 将有序的 KV 对存储在不同的文件中，在 db 目录下有很多数据文件，通过 “层级” 把它们分开
    - 周期性地将较小的文件合并为较大的文件，这让随机写速度很快
* BotlDB
    - 会在数据文件中获取一个文件锁，所以多个进程不能同时打开同一个数据库
    - BoltDB 支持完全可序列化的 ACID 事务
        + 数据保存在内存映射的文件中，没有 WAL，没有线程压缩和垃圾回收
        + 通过 COW 技术，可以实现无锁的读写并发，但是不能实现无锁的写写并发，注定了读性能超高，但是*写×性能一般，适合读多写少的场景

## 网络爬虫

* 爬虫框架：[Colly](https://github.com/gocolly/colly)
* 特点
    - 清晰的 API
    - 快速
    - 管理每个域的请求延迟和最大并发数，抓取频率
    - 自动 cookie 和会话处理
    - 同步/异步/并行抓取
    - 高速缓存
    - 自动处理非 Unicode 编码
    - 支持 Robots.txt
    - 定制 Agent 信息
* HTML 处理工具
    - [Goquery](https://github.com/PuerkitoBio/goquery)
    - 类 jQuery 语法

## Web 框架：Gin

* [gin](https://github.com/gin-gonic/gin) > [Martini](https://github.com/go-martini/martini)
* 特点：
    - 运行速度快
    - 分组的路由
    - 良好的异常捕获和错误处理
    - 非常好的支持中间件和 Json
