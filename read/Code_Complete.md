# Code Complete

* Conquer Complexity 软件架构设计的首要目标是管理或征服复杂性，通过工程纪律(流程)、惯例和抽象等手段，来减轻我们大脑的认知负担，从而让我们更好的管理复杂性，开发更高质量和大规模的系统。
* Pick Your Process 质量不应该只是事后考量，从需求分析、架构设计、代码实现，测试，到最后部署+运维，在软件开发的每一个阶段都需要考虑质量，设置相应的质量关卡。即便是在敏捷和快速迭代流行的今天，强调前期的需求和架构设计仍然必要，你在前期的需求和架构设计投入的越多，那么你就越可能生产出高质量的软件。
* Write Programms for People First, Computers Second 代码的可读性，对于软件可维护性(包括可理解性，可评审性，错误率，可修复性，可修改性，还有后续的开发成本和质量)很重要，也就是要先写出对人友好的程序。在此基础上，再考虑代码对计算机硬件的友好性，这个是后续可以不断迭代优化的。
* Program into Your Language, Not it it 不要被你的编程语言所提供的API所限制(只会用API)，如果某编程语言不提供某种功能API，初级程序程序员往往只能干瞪眼，而中高级程序员会深入一种编程语言，如果所需的功能API没有提供，他们能够超越这种编程语言，自己去实现这种抽象(API)。
* Focus Your Attention with the Help of Conventions 通过引入惯例结构可以帮助我们管理复杂性，从而让我们的最宝贵资源～我们的注意力可以得到更高效的使用。为啥要用有意义的变量名？为啥要写职责单一的类和函数(把类和函数都写得小小的)，为啥要尽量减少全局变量的使用(让变量的声明和使用的距离尽可能靠近)，为啥要尽量减少状态数据？为啥要尽量减少复杂的条件判断逻辑？为啥要放弃聪明但是难以理解的算法？这些做法的目标都是通过惯例减轻我们的认知负担，释放我们的大脑，帮我们把注意力投放到开发更高质量和更大规模的系统上，否则你的注意力很容易陷入复杂性的沼泽。
* Program in Terms of the Problem Domain 尽可能在高层次抽象上进行工作，顶层代码应该看上去上像讲故事一样，例如订购商品OrderProduct -> 支付订单PayOrder -> 交付订单DeliverOrder， 而不是addItemToList -> callXXXBankAPI -> callXXXDeliveryAPI。产品和用户关心的是问题领域术语，不是操作系统和编程语言等底层细节。要做到像讲故事一样写程序，需要培养良好的抽象思维能力。
* Watch for Falling Rocks 尽可能设置严格的编译器选项，对编译器提示的每一个警告都要追根溯源，不容马虎。
* Iterate, Repeatedly, Again and Again 对需求、设计、估算、编码和调优都需要不断迭代。优质软件离不开一开始的架构设计，同时更是不断迭代演进的结果。
* Thou Shalt Render Software and Religion Asunder 保持好奇心，多动手实践，不要变成顽固不化的狂热分子(某某技术的死忠)，这种狂热只会限制你的进步。保持灵活，避免陷入手中有锤子，满世界都是钉子的狭隘中。切记，技术世界里没有银弹，真正的复杂性在业务领域中。
* Personal Character of top programmer 成长性思维 ~ 技术能力非天生，只要不断努力学习实践，技术能力就会不断成长。谦虚，好奇，理性诚实，遵守工程纪律，富有创新和探索精神，动手实践而非坐而论道。优秀程序员和普通程序员之间的差异，不是一倍二倍，而是十倍(McConnell Steve)，甚至五十倍(乔布斯)。
