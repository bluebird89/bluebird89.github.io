# 开发的工程能力

业务团队最主要的提高的能力是业务抽象和架构能力，通过业务场景，不断思考如何通过合理的架构和业务抽象能快速支持业务，降低运维成本。同时在这个过程中锻炼技术能力，比如写一些技术框架来快速支持业务，做到技术驱动业务。

- 可配置化的方式支持业务：设计业务的领域模型，把不随着业务逻辑变化的领域模型做成系统能力，把随着业务逻辑变化功能，做成可配置化，上一个新业务，通过配置的方式或少量开发就能支持。在做客户后台功能时，由于需要展示的数据种类非常多，每种数据展示可能需要花费几天的时间，所以设计了一个通用的技术框架，实现了通过配置化的方式展示各种数据。
- 写框架解决业务问题：我在上家公司经常做一些CRUD的业务功能，我就自己开发了一个快速做CRUD的框架jdbcutil,通过配置实体生成SQL语句，实现了子类只要继承父类，就自动拥有CRUD的能力。后面还写过生成CRUD页面代码的程序。目前我们团队在做的TITAN框架通过模块化开发的方式，解决易变的业务系统在多人开发时遇到的问题。
- 技术驱动业务：在业务团队，一定要不断的思考如何利用技术来支持快速支持业务，配置化是一种思路，但是有些功能配置复杂度比较高，配置加验证的工作量，可能需要一个星期的时间，那么能不能减少人工配置，实现系统自动化配置，于是可以研究下人工智能，通过人工智能的方式实现，系统告诉人需要配置哪些东西，然后交给人来进行确认，这样可以大大减少人工成本，更快的支持业务。

# 
工程自动化，应该是所有开发者的一种基础追求，当你搭建建好工程体系，以后你将专注于产品功能的开发，而不会花大量不必要的时间去手动构建。作为前端，可能我们已经熟悉了 web 应用的构建和部署，但是客户端程序有其本身的特点，相比较 web 应用最大也是我认为最根本的一点区别在于「你的应用是被用户下载过去安装在用户本地再跑起来的」。

## 持续集成

持续集成（Continuous integration，简称CI）是一种软件开发实践，即团队开发成员经常集成它们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。

持续集成的优点：

* 快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。
* 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。

持续集成的一些原则：

* 所有的开发人员需要在本地机器上做本地构建，然后再提交的版本控制库中，从而确保他们的变更不会导致持续集成失败。
* 开发人员每天至少向版本控制库中提交一次代码。
* 开发人员每天至少需要从版本控制库中更新一次代码到本地机器。
* 需要有专门的集成服务器来执行集成构建,每天要执行多次构建。
* 每次构建都要100%通过。
* 每次构建都可以生成可发布的产品。
* 修复失败的构建是优先级最高的事情。

## 灰度发布

灰度发布是在发布新版本的时候，先切分部分流量给新版本，稳定了之后再切分所有流量到新版本。这样一旦有问题，马上修改切分的流量就可以，不需要重新发布，减少了发布风险。这种基于ABTest分流的灰度发布方式已经成为很多公司发布的一个必经流程。在灰度发布过程中，产品团队根据用户的反馈及时完善产品相关功能。


## Web 前后端分离

前后端只通过 JSON 来交流，组件化、工程化不需要依赖后端去实现

### Facebook

需要specialist，但是 senior 的人都应该了解整个 E2E (end-to-end) 过程的。


在 Facebook 我们不分前端和后端，只分 product 和 infrastructure。做 product 的通常都是 full stack，不需要对特定的技术非常精通，但要求学习能力和灵活性足够好，不能只做自己 comfort zone 以内的事情，do whatever it takes to get your product shipped。通常聪明的应届生都会先进入 product，因为他们学什么都很快，也不会说浪费了在某个领域的积累。infrastructure 拥有更多各个领域的 specialist，前端只是其中之一。infrastructure 的客户就是 product，要做的事情就是让 product 开发实际产品时觉得爽，就这么简单。至于真正 senior 的人，必须了解整个 E2E 过程。这有点像那个「在浏览器地址栏按下回车后都发生了什么」的答案，也就是掌握大局同时了解细节。因为具体的问题可疑扔给 junior 的人去解决，所以 senior 的存在价值就是在众多问题当中寻找值得解决的问题。学过计算机体系结构的人都应该知道，性能优化只应该在瓶颈上做，因为做在非瓶颈上就是浪费资源。同理技术或产品的优化都应该是做在瓶颈上的，所以 senior 的人应该熟悉整套系统并且能够有效找到当前的瓶颈。这时候就不存在前端或者后端的概念了，因为 specialist 在特定领域再精通，不了解整个 E2E 的过程就没办法再往上提升。@winter 提到「联调」，我想说我很久没听说过这个词了，因为这个词没有对应的英语版本，美国公司的产品开发过程通常不包括联调。product 要做什么，就自己学习对应的技术，学习公司内部的 infrastructure，然后调用公司内部的 API 就可以了。一个产品的逻辑，要分前端和后端两个团队的人实现，然后还要协调实现的结果，这我只在中国公司见过。当然这不仅仅要求公司 infrastructure 好，还要求有开放的文化。我进 Facebook 之前只写 JS，在 Facebook 要用 PHP 我随便学学就开始写，反正写得不好 code review 时会有人指出。只要保持开放的学习心态，同一个错误不要一犯再犯，别人都乐意帮助你进步。现在我的 PHP/Hack 就仅仅是够用的程度，但这不妨碍我工作。我的工作当然要用到别人的 infrastructure，偶尔用起来有点小不爽，我就会想要改动一下。管它是 Python、Java 还是 C++，反正我不爽就必须亲自研究源代码弄懂了自己该。原本的作者不一定有时间处理我的小需求，我就按照我的理解去改，改好提交 code review，别人都会帮忙看然后提点建议。所谓联调，无非就是有些事情你自己做不了非要以来于别人帮你做，然后别人就会成为阻塞你的环节。（通常都是前端依赖后端，很少有说后端因为前端没完成就必须停下来等的。）这种做不了就停下来等的态度是不对的，不能说那是别人的问题就等别人解决。总之阻塞了产品发布的问题就是你的问题，无论需要你学习什么新技术，无论需要你编写和调试什么不熟悉的代码，do whatever it takes，just get the product launched。@齐泰然 那个木工和电工的比喻大致也是对的。在中国公司，这就是木工和电工的分离。在美国公司，有一帮人使用 3D 打印机、激光切割机、数控机床，外加 Arduino 或 Raspberry Pi，迅速把新一代电子产品的原型做出来；还有另外一帮人研究新一代的 3D 打印机，考虑如何让上述 maker 更快地把头脑中的产品原型变为现实。在中国公司，木工和电工整天吵架，木工说电工不把线路板面积确定下来他就没办法做木盒子，电工说他在电动机大小不确定的情况下线路板没办法定稿。
