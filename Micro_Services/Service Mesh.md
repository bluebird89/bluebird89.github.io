# Service Mesh 服务网格

* Service Mesh 本质上就是微服务的动态链接器（Dynamic Linker）。它的基础是一个网络代理，这个网络代理会接管微服务的网络流量，然后通过一个中央控制面板进行管理，将这些流量转发到该去的地方，并在这个代理的基础之上，扩展出一系列的流量监控、限流、熔断甚至是灰度发布、分布式跟踪等能力，而不需要应用本身做出任何修改，让开发者摆脱了 SDK 之苦，也避免了由于 SDK 使用不当造成的一系列问题。同时，这个代理工作是在网络层，一般情况下也不会成为性能瓶颈。
* 服务网格（ Service Mesh ）是解决微服务之间的网络问题和可观测性问题的(事实)标准，并且正在走向标准化

## 历程

* 服务间通信
* 独立的网络层
* 出现网络层（4层协议）控制的需求
* 控制逻辑下移到网络
* 出现新的应用层（7层协议）需求（服务发现、熔断、超时重试等）
* 封装成三方库（服务发现：Dubbo/HSF）
    - 原本在进程中互相调用那么简单的事情，都要变成一次在 7 层网络上的远程调用
    - 原本公共工具类做的事情，现在需要写成二方库 SDK 等，在每一个进程中使用，版本迭代成为了灾难
    - 原本是内部透明调用的不需要做任何防护，分离后却要额外增加安全防护和隔离的工作
    - 不再是代码即文档，需要维护大量的 API 定义和版本管理
* Sidecar模式 
    - 服务网格技术中常用的(其中)一种设计架构，在 Kubernates 中，不同的容器允许被运行在同一个 Pod 中（即多个进程运行在同一个 cgroup 下），这在很大程度上给 Sidecar 模式提供了良好的土壤
    - 微服务之间的调用在架构图中是横向的，被称为东西流量。服务暴露到外部被公网可见的外部调用，被称为南北流量
    - Consumer 与 Provider 就是微服务互相调用的一种解决方案
    - Dubbo 架构：解决的正是东西流量的问题
        + 基于 SPI 机制以一种较为隔离的方式侵入到运行时的代码中
        + 只能限定 Java 这样被官方支持的语言来开发服务应用
    - 问题：流量管理（服务发现、负载均衡、路由、限流、熔断、容错等）、可观测性（监控、日志聚合、计量、跟踪）、安全（认证、授权），再甚至更高级的动态配置、故障注入、镜像流量等
    - Sidecar 的模式更为巧妙并更进一步。通过容器机制，在进程上是隔离的，基于 L7 代理进行通讯，允许微服务是由任何语言进行开发的
* 所有使用中间件的服务组成了一个大的服务网格。服务网格基于 Kubernates 这样的容器技术，将东西流量的问题解决得更加透明无感

## Sidecar 注入

* 概念
    - Sidecar 模式：容器应用模式之一，Service Mesh 架构的一种实现方式
    - Init 容器：Pod 中的一种专用的容器，在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。
    - iptables：流量劫持是通过 iptables 转发实现的
* Sidecar 模式解决微服务之间的网络通讯（远程调用），通常通讯层的实现方式，有以下选择：
    - 在微服务应用程序中导入 SDK 类库：调用方式是进程内的，没有安全隔离的包袱。但是随着编程语言的发展，很多新的语言为特定的场景而生，而SDK库的方式限制了使用方必须用支持列表中的语言
    - 节点代理（使用纵向的API网关或者是本地 Agent ），代理接口的调用路由规则，转发到特定的机器：使用一个特定的服务专门代理微服务中的请求，是一个中间人的角色。但这个代理人的安全性要求非常高，因为它需要处理来自不同微服务的请求，并鉴别它们各自的身份
    - 用 Sidecar 容器的形式运行，和应用容器一同运行，透明地劫持所有应用容器的出入流量：介于 SDK 库和节点代理中间的一种形式，相当于是给每个微服务都配上一个自己独有的代理，每个微服务自己的 Sidecar 就代表了自己特定的身份，有利于调用的安全审计

## 参考

* [ServicemeshCN/awesome-servicemesh](https://github.com/ServicemeshCN/awesome-servicemesh):A curated list for awesome service mesh architectures https://servicemesh.gitbooks.io/aweso…
